{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue128;\red0\green0\blue0;\red128\green0\blue128;\red0\green102\blue204;\red0\green128\blue128;\red255\green0\blue0;\red255\green99\blue71;\red255\green0\blue255;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Untitled}}
\deflang1033\pard\plain\f0\fs20 \cf0\i \{ @abstract(This unit contains advanced graphic functions used by KControls suite.)
\par   @author(Tomas Krysl (tk@tkweb.eu))
\par   @created(5 May 2004)
\par   @lastmod(6 Jul 2014)
\par 
\par   Copyright © Tomas Krysl (tk@@tkweb.eu)<BR><BR>
\par 
\par   <B>License:</B><BR>
\par   This code is distributed as a freeware. You are free to use it as part
\par   of your application for any purpose including freeware, commercial and
\par   shareware applications. The origin of this source code must not be
\par   misrepresented; you must not claim your authorship. You may modify this code
\par   solely for your own purpose. Please feel free to contact the author if you
\par   think your changes might be useful for other users. You may distribute only
\par   the original package. The author accepts no liability for any damage
\par   that may result from using this code. \}
\par 
\par \i0\cf1\b unit\b0  KGraphics\cf2 ;
\par 
\par \cf1\i \{$include kcontrols.inc\}
\par \{$IFNDEF REGISTER_PICTURE_FORMATS\}
\par \i0  \i \{$WEAKPACKAGEUNIT ON\}
\par \{$ENDIF\}
\par 
\par \i0\b interface
\par 
\par uses
\par \b0\i \{$IFDEF FPC\}
\par \i0  \cf0\i // use the LCL interface support whenever possible
\par \i0\cf1  \i \{$IFDEF USE_WINAPI\}
\par \i0   Windows\cf2 ,
\par \cf1  \i \{$ENDIF\}
\par \i0   GraphType\cf2 ,\cf1  IntfGraphics\cf2 ,\cf1  LCLType\cf2 ,\cf1  LCLIntf\cf2 ,\cf1  LMessages\cf2 ,\cf1  LResources\cf2 ,
\par \cf1\i \{$ELSE\}
\par \i0   Windows\cf2 ,\cf1  Messages\cf2 ,
\par \cf1  \i \{$IFDEF USE_PNG_SUPPORT\}
\par \i0   PngImage\cf2 ,
\par \cf1  \i \{$ENDIF\}
\par \{$ENDIF\}
\par \i0   Classes\cf2 ,\cf1  Forms\cf2 ,\cf1  Graphics\cf2 ,\cf1  Controls\cf2 ,\cf1  Types\cf2 ,\cf1  KFunctions
\par \i \{$IFDEF USE_THEMES\}
\par \i0   \cf2 ,\cf1  Themes
\par  \i \{$IFNDEF FPC\}
\par \i0   \cf2 ,\cf1  UxTheme
\par  \i \{$ENDIF\}
\par \{$ENDIF\}
\par \i0   \cf2 ;
\par 
\par \cf1\b const
\par \b0   \cf0\i \{ PNG Support \}
\par \i0\cf1   PNGHeader \cf2 =\cf1  \cf3\ul #137\ul0\cf4 'PNG'\cf3\ul #13#10#26#10\ul0\cf2 ;
\par \cf1   MNGHeader \cf2 =\cf1  \cf3\ul #138\ul0\cf4 'MNG'\cf3\ul #13#10#26#10\ul0\cf2 ;
\par 
\par \cf1\b type
\par \b0   \cf0\i \{ Declares possible values for the Style parameter of the @link(BrightColor) function. \}
\par \i0\cf1   TKBrightMode \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ The Color will be brightened with Percent of its entire luminosity range. \}
\par \i0\cf1     bsAbsolute\cf2 ,
\par \cf1     \cf0\i \{ The Color will be brightened with Percent of its current luminosity value. \}
\par \i0\cf1     bsOfBottom\cf2 ,
\par \cf1     \cf0\i \{ The Color will be brightened with Percent of the difference of its entire
\par       luminosity range and current luminosity value. \}
\par \i0\cf1     bsOfTop
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ Declares RGB + Alpha channel color description allowing both to
\par     access single channels and the whole color item. \}
\par \i0\cf1   TKColorRec \cf2 =\cf1  \b packed\b0  \b record
\par \b0     \b case\b0  Integer \b of
\par \b0       \cf5 0\cf2 :\cf1  \cf2 (\cf1 R\cf2 ,\cf1  G\cf2 ,\cf1  B\cf2 ,\cf1  A\cf2 :\cf1  Byte\cf2 );
\par \cf1       \cf5 1\cf2 :\cf1  \cf2 (\cf1 Value\cf2 :\cf1  Cardinal\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \cf0\i \{ Pointer to TKColorRec. \}
\par \i0\cf1   PKColorRec \cf2 =\cf1  \cf2 ^\cf1 TKColorRec\cf2 ;
\par 
\par \cf1   \cf0\i \{ Dynamic array for TKColorRec. \}
\par \i0\cf1   TKColorRecs \cf2 =\cf1  \b array\b0\cf2 [\cf5 0\cf2 ..\cf1 MaxInt \b div\b0  SizeOf\cf2 (\cf1 TKColorRec\cf2 )\cf1  \cf2 -\cf1  \cf5 1\cf2 ]\cf1  \b of\b0  TKColorRec\cf2 ;
\par \cf1   \cf0\i \{ Dynamic array for TKColorRecs. \}
\par \i0\cf1   PKColorRecs \cf2 =\cf1  \cf2 ^\cf1 TKColorRecs\cf2 ;
\par \cf1   \cf0\i \{ Dynamic array for TKColorRec. \}
\par \i0\cf1   TKDynColorRecs \cf2 =\cf1  \b array\b0  \b of\b0  TKColorRec\cf2 ;
\par 
\par \cf1   \cf0\i \{ String type for @link(ImageByType) function. \}
\par \i0\cf1   TKImageHeaderString \cf2 =\cf1  \b string\b0\cf2 [\cf5 10\cf2 ];
\par 
\par \cf1\i \{$IFDEF USE_PNG_SUPPORT\}
\par \i0  \i \{$IFDEF FPC\}
\par \i0    \cf0\i \{ @exclude \}
\par \i0\cf1   TKPngImage \cf2 =\cf1  TPortableNetworkGraphic\cf2 ;
\par \cf1  \i \{$ELSE\}
\par \i0   \i \{$IFDEF COMPILER12_UP\}
\par \i0    \cf0\i \{ @exclude \}
\par \i0\cf1   TKPngImage \cf2 =\cf1  TPngImage\cf2 ;
\par \cf1   \i \{$ELSE\}
\par \i0    \cf0\i \{ @exclude \}
\par \i0\cf1   TKPngImage \cf2 =\cf1  TPngObject\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0  \i \{$ENDIF\}
\par \{$ENDIF\}
\par 
\par \i0   \cf0\i \{ Declares possible values for the Attributes parameter in the @link(DrawAlignedText) function. \}
\par \i0\cf1   TKTextAttribute \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Bounding rectangle is calculated. No text is drawn. \}
\par \i0\cf1     taCalcRect\cf2 ,
\par \cf1     \cf0\i \{ Text will be clipped within the given rectangle. \}
\par \i0\cf1     taClip\cf2 ,
\par \cf1     \cf0\i \{ Text will be drawn with end ellipsis if it does not fit within given width. \}
\par \i0\cf1     taEndEllipsis\cf2 ,
\par \cf1     \cf0\i \{ Given rectangle will be filled. \}
\par \i0\cf1     taFillRect\cf2 ,
\par \cf1     \cf0\i \{ Only the text within given rectangle will be filled. \}
\par \i0\cf1     taFillText\cf2 ,
\par \cf1     \cf0\i \{ Include padding created by aligns in the @link(TKTextBox.PointToIndex) calculation. \}
\par \i0\cf1     taIncludePadding\cf2 ,
\par \cf1     \cf0\i \{ Text will be drawn as multi-line text if it contains carriage returns and line feeds. \}
\par \i0\cf1     taLineBreak\cf2 ,
\par \cf1     \cf0\i \{ Text will be drawn with path ellipsis if it does not fit within given width. \}
\par \i0\cf1     taPathEllipsis\cf2 ,
\par \cf1     \cf0\i \{ Text line(s) will be broken between words if they don't fit within given width. \}
\par \i0\cf1     taWordBreak\cf2 ,
\par \cf1     \cf0\i \{ Text line(s) will be broken if they don't fit within col width. \}
\par \i0\cf1     taWrapText\cf2 ,\cf1  \cf0\i //JR:20091229
\par \i0\cf1     \cf0\i \{ White spaces will be trimmed at the beginning or end of text lines. \}
\par \i0\cf1     taTrimWhiteSpaces\cf2 ,
\par \cf1     \cf0\i \{ Text will be drawn with start ellipsis if it does not fit within given width. \}
\par \i0\cf1     taStartEllipsis
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ Set type for @link(TKTextAttribute) enumeration. \}
\par \i0\cf1   TKTextAttributes \cf2 =\cf1  \b set\b0  \b of\b0  TKTextAttribute\cf2 ;
\par 
\par \cf1   \cf0\i \{ Declares possible values for the HAlign parameter in the @link(DrawAlignedText) function. \}
\par \i0\cf1   TKHAlign \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Text is aligned to the left border of a cell rectangle. \}
\par \i0\cf1     halLeft\cf2 ,
\par \cf1     \cf0\i \{ Text is horizontally centered within the cell rectangle. \}
\par \i0\cf1     halCenter\cf2 ,
\par \cf1     \cf0\i \{ Text is aligned to the right border of a cell rectangle. \}
\par \i0\cf1     halRight\cf2 ,
\par \cf1     \cf0\i \{ Text is aligned to the left and right border of a cell rectangle. \}
\par \i0\cf1     halJustify
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ Declares possible values for the StretchMode parameter in the @link(ExcludeShapeFromBaseRect) function. \}
\par \i0\cf1   TKStretchMode \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Shape is not stretched. \}
\par \i0\cf1     stmNone\cf2 ,
\par \cf1     \cf0\i \{ Shape is zoomed out. \}
\par \i0\cf1     stmZoomOutOnly\cf2 ,
\par \cf1     \cf0\i \{ Shape is zoomed in. \}
\par \i0\cf1     stmZoomInOnly\cf2 ,
\par \cf1     \cf0\i \{ Shape is zoomed arbitrary. \}
\par \i0\cf1     stmZoom
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ For backward compatibility. \}
\par \i0\cf1   TKTextHAlign \cf2 =\cf1  TKHAlign\cf2 ;
\par 
\par \cf1   \cf0\i \{ Declares possible values for the VAlign parameter in the @link(DrawAlignedText) function. \}
\par \i0\cf1   TKVAlign \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Text is aligned to the upper border of a cell rectangle. \}
\par \i0\cf1     valTop\cf2 ,
\par \cf1     \cf0\i \{ Text is vertically centered within the cell rectangle. \}
\par \i0\cf1     valCenter\cf2 ,
\par \cf1     \cf0\i \{ Text is aligned to the lower border of a cell rectangle. \}
\par \i0\cf1     valBottom
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ For backward compatibility. \}
\par \i0\cf1   TKTextVAlign \cf2 =\cf1  TKVAlign\cf2 ;
\par 
\par \cf1   \cf0\i \{ Declares possible values for the AStates parameter in the @link(DrawButtonFrame) function. \}
\par \i0\cf1   TKButtonDrawState \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Use OS themes/styles to draw button. \}
\par \i0\cf1     bsUseThemes\cf2 ,
\par \cf1     \cf0\i \{ Draw disabled button. \}
\par \i0\cf1     bsDisabled\cf2 ,
\par \cf1     \cf0\i \{ Draw pressed button. \}
\par \i0\cf1     bsPressed\cf2 ,
\par \cf1     \cf0\i \{ Draw normal focused button. \}
\par \i0\cf1     bsFocused\cf2 ,
\par \cf1     \cf0\i \{ Draw normal hot button. \}
\par \i0\cf1     bsHot
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ Set of TKButtonState values. \}
\par \i0\cf1   TKButtonDrawStates \cf2 =\cf1  \b set\b0  \b of\b0  TKButtonDrawState\cf2 ;
\par 
\par \cf1   \cf0\i \{ Contains common properties for all KCOntrols TGraphic descendants. \}
\par \i0\cf1   TKGraphic \cf2 =\cf1  \b class\b0\cf2 (\cf1 TGraphic\cf2 )
\par \cf1   \b protected
\par \b0     FDescription\cf2 :\cf1  \b string\b0\cf2 ;
\par \cf1     FFileFilter\cf2 :\cf1  \b string\b0\cf2 ;
\par \cf1   \b public
\par \b0     \cf0\i \{ Creates the instance. \}
\par \i0\cf1     \b constructor\b0  Create\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Gives description for design time loader. \}
\par \i0\cf1     \b property\b0  Description\cf2 :\cf1  \b string\b0  \b read\b0  FDescription\cf2 ;
\par \cf1     \cf0\i \{ Gives file filter for design time loader. \}
\par \i0\cf1     \b property\b0  FileFilter\cf2 :\cf1  \b string\b0  \b read\b0  FFileFilter\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \cf0\i \{ A simple platform independent encapsulation for a 32bpp bitmap with
\par     alpha channel with the ability to modify it's pixels directly. \}
\par \i0\cf1   TKAlphaBitmap \cf2 =\cf1  \b class\b0\cf2 (\cf1 TKGraphic\cf2 )
\par \cf1   \b private
\par \b0     FAutoMirror\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FCanvas\cf2 :\cf1  TCanvas\cf2 ;
\par \cf1     FDirectCopy\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FHandle\cf2 :\cf1  HBITMAP\cf2 ;
\par \cf1     FHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \i \{$IFNDEF USE_WINAPI\}
\par \i0     FImage\cf2 :\cf1  TLazIntfImage\cf2 ;\cf1  \cf0\i // Lazarus only
\par \i0\cf1     FMaskHandle\cf2 :\cf1  HBITMAP\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0     FOldBitmap\cf2 :\cf1  HBITMAP\cf2 ;
\par \cf1     FPixels\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1     FPixelsChanged\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FUpdateLock\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1     \b function\b0  GetScanLine\cf2 (\cf1 Index\cf2 :\cf1  Integer\cf2 ):\cf1  PKColorRecs\cf2 ;
\par \cf1     \b function\b0  GetHandle\cf2 :\cf1  HBITMAP\cf2 ;
\par \cf1     \b function\b0  GetPixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1     \b procedure\b0  SetPixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  Value\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1   \b protected
\par \b0     \cf0\i \{ Calls OnChanged event. \}
\par \i0\cf1     \b procedure\b0  Changed\cf2 (\cf1 Sender\cf2 :\cf1  TObject\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Paints itself to ACanvas at location ARect. \}
\par \i0\cf1     \b procedure\b0  Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Returns True if bitmap is empty. \}
\par \i0\cf1     \b function\b0  GetEmpty\cf2 :\cf1  Boolean\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Returns the bitmap height. \}
\par \i0\cf1     \b function\b0  GetHeight\cf2 :\cf1  Integer\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Returns True. Treat alpha bitmap as transparent because of the
\par       possible alpha channel. \}
\par \i0\cf1     \b function\b0  GetTransparent\cf2 :\cf1  Boolean\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Returns the bitmap width. \}
\par \i0\cf1     \b function\b0  GetWidth\cf2 :\cf1  Integer\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Specifies new bitmap height. \}
\par \i0\cf1     \b procedure\b0  SetHeight\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Specifies new bitmap width. \}
\par \i0\cf1     \b procedure\b0  SetWidth\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Does nothing. Bitmap is never transparent. \}
\par \i0\cf1     \b procedure\b0  SetTransparent\cf2 (\cf1 Value\cf2 :\cf1  Boolean\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1   \b public
\par \b0     \cf0\i \{ Creates the instance. \}
\par \i0\cf1     \b constructor\b0  Create\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Creates the instance from application resources. For Lazarus 'BMP' type is
\par       taken, for Delphi RT_RCDATA is taken. \}
\par \i0\cf1     \b constructor\b0  CreateFromRes\cf2 (\cf1\b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 );
\par \cf1     \cf0\i \{ Destroys the instance. \}
\par \i0\cf1     \b destructor\b0  Destroy\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Paints alpha bitmap onto Canvas at position given by X, Y. The alpha bitmap
\par       is combined with the background already drawn on Canvas using alpha channel
\par       stored in the alpha bitmap. \}
\par \i0\cf1     \b procedure\b0  AlphaDrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 );
\par \cf1     \cf0\i \{ Paints alpha bitmap onto Canvas at position given by ARect. The alpha bitmap
\par       is combined with the background already drawn on Canvas using alpha channel
\par       stored in the alpha bitmap. \}
\par \i0\cf1     \b procedure\b0  AlphaStretchDrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1     \cf0\i \{ Fills the alpha channel with Alpha. If the optional IfEmpty parameter is True,
\par       the alpha channel won't be modified unless it has zero value for all pixels. \}
\par \i0\cf1     \b procedure\b0  AlphaFill\cf2 (\cf1 Alpha\cf2 :\cf1  Byte\cf2 ;\cf1  IfEmpty\cf2 :\cf1  Boolean \cf2 =\cf1  False\cf2 );\cf1  \b overload\b0\cf2 ;
\par \cf1     \cf0\i \{ Fills the alpha channel according to given parameters. Currently it is used
\par       internally by @link(TKDragWindow). \}
\par \i0\cf1     \b procedure\b0  AlphaFill\cf2 (\cf1 Alpha\cf2 :\cf1  Byte\cf2 ;\cf1  BlendColor\cf2 :\cf1  TColor\cf2 ;\cf1  Gradient\cf2 ,\cf1  Translucent\cf2 :\cf1  Boolean\cf2 );\cf1  \b overload\b0\cf2 ;
\par \cf1     \cf0\i \{ Fills the alpha channel with AAlpha for pixels with AColor. \}
\par \i0\cf1     \b procedure\b0  AlphaFillOnColorMatch\cf2 (\cf1 AColor\cf2 :\cf1  TColor\cf2 ;\cf1  AAlpha\cf2 :\cf1  Byte\cf2 );
\par \cf1     \cf0\i \{ Modifies the alpha channel with Percent of its current value. If the optional IfEmpty parameter is True,
\par       the alpha channel will be set to percent of full scale if it has zero value. \}
\par \i0\cf1     \b procedure\b0  AlphaFillPercent\cf2 (\cf1 Percent\cf2 :\cf1  Integer\cf2 ;\cf1  IfEmpty\cf2 :\cf1  Boolean\cf2 );
\par \cf1     \cf0\i \{ Copies shareable properties of another instance into this instance of TKAlphaBitmap. \}
\par \i0\cf1     \b procedure\b0  Assign\cf2 (\cf1 Source\cf2 :\cf1  TPersistent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Copies shareable properties of this instance into another instance of TKAlphaBitmap. \}
\par \i0\cf1     \b procedure\b0  AssignTo\cf2 (\cf1 Dest\cf2 :\cf1  TPersistent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Clears the image. \}
\par \i0\cf1     \b procedure\b0  Clear\cf2 ;\cf1  \i \{$IFDEF FPC\}\i0\b override\b0\cf2 ;\cf1\i \{$ENDIF\}
\par \i0     \cf0\i \{ Combines the pixel at given location with the given color. \}
\par \i0\cf1     \b procedure\b0  CombinePixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  Color\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1     \cf0\i \{ Takes dimensions and pixels from ABitmap. \}
\par \i0\cf1     \b procedure\b0  CopyFrom\cf2 (\cf1 ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1     \cf0\i \{ Takes 90°-rotated dimensions and pixels from ABitmap. \}
\par \i0\cf1     \b procedure\b0  CopyFromRotated\cf2 (\cf1 ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1     \cf0\i \{ Takes portion from ABitmap at position X and Y. \}
\par \i0\cf1     \b procedure\b0  CopyFromXY\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1     \cf0\i \{ Copies a location specified by ARect from ACanvas to bitmap. \}
\par \i0\cf1     \b procedure\b0  DrawFrom\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );\cf1  \b overload\b0\cf2 ;
\par \cf1     \cf0\i \{ Copies a portion of AGraphic to bitmap at position X and Y. \}
\par \i0\cf1     \b procedure\b0  DrawFrom\cf2 (\cf1 AGraphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 );\cf1  \b overload\b0\cf2 ;
\par \cf1     \cf0\i \{ Calls @link(TKAlphaBitmap.Draw). \}
\par \i0\cf1     \b procedure\b0  DrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1     \cf0\i \{ Fill with Color. \}
\par \i0\cf1     \b procedure\b0  Fill\cf2 (\cf1 Color\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1     \cf0\i \{ Convert to grayscale. \}
\par \i0\cf1     \b procedure\b0  GrayScale\cf2 ;
\par \cf1   \i \{$IFNDEF FPC\}
\par \i0     \cf0\i \{ Does nothing. \}
\par \i0\cf1     \b procedure\b0  LoadFromClipboardFormat\cf2 (\cf1 AFormat\cf2 :\cf1  Word\cf2 ;\cf1  AData\cf2 :\cf1  THandle\cf2 ;
\par \cf1       APalette\cf2 :\cf1  HPALETTE\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0     \cf0\i \{ Loads the bitmap from a file. Overriden to support PNG as well. \}
\par \i0\cf1     \b procedure\b0  LoadFromFile\cf2 (\cf1\b const\b0  Filename\cf2 :\cf1  \b string\b0\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Loads the bitmap from another TGraphic instance. \}
\par \i0\cf1     \b procedure\b0  LoadFromGraphic\cf2 (\cf1 Image\cf2 :\cf1  TGraphic\cf2 );\cf1  \b virtual\b0\cf2 ;
\par \cf1     \cf0\i \{ Loads the bitmap from a stream. \}
\par \i0\cf1     \b procedure\b0  LoadFromStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Locks calls to @link(TKAlphaBitmap.Changed). \}
\par \i0\cf1     \b procedure\b0  LockUpdate\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \cf0\i \{ Mirrors the bitmap pixels horizontally. \}
\par \i0\cf1     \b procedure\b0  MirrorHorz\cf2 ;
\par \cf1     \cf0\i \{ Mirrors the bitmap pixels vertically. \}
\par \i0\cf1     \b procedure\b0  MirrorVert\cf2 ;
\par \cf1   \i \{$IFNDEF FPC\}
\par \i0     \cf0\i \{ Does nothing. \}
\par \i0\cf1     \b procedure\b0  SaveToClipboardFormat\cf2 (\cf1\b var\b0  AFormat\cf2 :\cf1  Word\cf2 ;\cf1  \b var\b0  AData\cf2 :\cf1  THandle\cf2 ;
\par \cf1       \b var\b0  APalette\cf2 :\cf1  HPALETTE\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0     \cf0\i \{ Saves the bitmap to a stream. \}
\par \i0\cf1     \b procedure\b0  SaveToStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Specifies the bitmap size. \}
\par \i0\cf1     \b procedure\b0  SetSize\cf2 (\cf1 AWidth\cf2 ,\cf1  AHeight\cf2 :\cf1  Integer\cf2 );\cf1  \i \{$IFNDEF FPC\}\i0  \b reintroduce\b0\cf2 ;\cf1\i \{$ENDIF\}
\par \i0     \cf0\i \{ Unlocks calls to @link(TKAlphaBitmap.Changed). \}
\par \i0\cf1     \b procedure\b0  UnlockUpdate\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \cf0\i \{ Updates the bitmap handle from bitmap pixels. \}
\par \i0\cf1     \b procedure\b0  UpdateHandle\cf2 ;\cf1  \b dynamic\b0\cf2 ;
\par \cf1     \cf0\i \{ Updates the pixels from bitmap handle. \}
\par \i0\cf1     \b procedure\b0  UpdatePixels\cf2 ;\cf1  \b dynamic\b0\cf2 ;
\par \cf1     \cf0\i \{ Automatically mirrors the bitmap vertically for Linux hosts, when reading/writing from/to a stream. \}
\par \i0\cf1     \b property\b0  AutoMirror\cf2 :\cf1  Boolean \b read\b0  FAutoMirror \b write\b0  FAutoMirror \b default\b0  True\cf2 ;
\par \cf1     \cf0\i \{ Returns the bitmap memory canvas. \}
\par \i0\cf1     \b property\b0  Canvas\cf2 :\cf1  TCanvas \b read\b0  FCanvas\cf2 ;
\par \cf1     \cf0\i \{ Temporary flag. Use when copying data directly from another TGraphic to TKAlphaBitmap. \}
\par \i0\cf1     \b property\b0  DirectCopy\cf2 :\cf1  Boolean \b read\b0  FDirectCopy \b write\b0  FDirectCopy\cf2 ;
\par \cf1     \cf0\i \{ Returns the bitmap handle. \}
\par \i0\cf1     \b property\b0  Handle\cf2 :\cf1  HBITMAP \b read\b0  GetHandle\cf2 ;
\par \cf1     \cf0\i \{ Specifies the pixel color. Does range checking. \}
\par \i0\cf1     \b property\b0  Pixel\cf2 [\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ]:\cf1  TKColorRec \b read\b0  GetPixel \b write\b0  SetPixel\cf2 ;
\par \cf1     \cf0\i \{ Returns the pointer to bitmap pixels. \}
\par \i0\cf1     \b property\b0  Pixels\cf2 :\cf1  PKColorRecs \b read\b0  FPixels\cf2 ;
\par \cf1     \cf0\i \{ Set this property to True if you have modified the bitmap pixels. \}
\par \i0\cf1     \b property\b0  PixelsChanged\cf2 :\cf1  Boolean \b read\b0  FPixelsChanged \b write\b0  FPixelsChanged\cf2 ;
\par \cf1     \cf0\i \{ Returns the pointer to a bitmap scan line. \}
\par \i0\cf1     \b property\b0  ScanLine\cf2 [\cf1\b Index\b0\cf2 :\cf1  Integer\cf2 ]:\cf1  PKColorRecs \b read\b0  GetScanLine\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0   \cf0\i \{ A simple encapsulation for a Windows or Enhanced metafile. It runs only under Windows and does not use shared images.
\par     However, it is possible to release metafile handles on assigning to another TKMetafile. \}
\par \i0\cf1   TKMetafile \cf2 =\cf1  \b class\b0\cf2 (\cf1 TGraphic\cf2 )
\par \cf1   \b private
\par \b0     FCopyOnAssign\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FEmfHandle\cf2 :\cf1  HENHMETAFILE\cf2 ;
\par \cf1     FEnhanced\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FWmfHandle\cf2 :\cf1  HMETAFILE\cf2 ;
\par \cf1     \b procedure\b0  SetEMFHandle\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  HENHMETAFILE\cf2 );
\par \cf1     \b procedure\b0  SetEnhanced\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  Boolean\cf2 );
\par \cf1     \b procedure\b0  SetWMFHandle\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  HMETAFILE\cf2 );
\par \cf1   \b protected
\par \b0     FRequiredHeight\cf2 ,
\par \cf1     FRequiredWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1     \b procedure\b0  Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  Rect\cf2 :\cf1  TRect\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b function\b0  GetEmpty\cf2 :\cf1  Boolean\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b function\b0  GetHeight\cf2 :\cf1  Integer\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b function\b0  GetTransparent\cf2 :\cf1  Boolean\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b function\b0  GetWidth\cf2 :\cf1  Integer\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b procedure\b0  SetHeight\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b procedure\b0  SetWidth\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1   \b public
\par \b0     \b constructor\b0  Create\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b destructor\b0  Destroy\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \b procedure\b0  Assign\cf2 (\cf1 Source\cf2 :\cf1  TPersistent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b procedure\b0  Clear\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b procedure\b0  LoadFromStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b procedure\b0  Release\cf2 (\cf1\b out\b0  AWmfHandle\cf2 :\cf1  HMETAFILE\cf2 ;\cf1  \b out\b0  AEmfHandle\cf2 :\cf1  HENHMETAFILE\cf2 );
\par \cf1     \b procedure\b0  SaveToStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b property\b0  CopyOnAssign\cf2 :\cf1  Boolean \b read\b0  FCopyOnAssign \b write\b0  FCopyOnAssign\cf2 ;
\par \cf1     \b property\b0  EMFHandle\cf2 :\cf1  HENHMETAFILE \b read\b0  FEMFHandle \b write\b0  SetEMFHandle\cf2 ;
\par \cf1     \b property\b0  Enhanced\cf2 :\cf1  Boolean \b read\b0  FEnhanced \b write\b0  SetEnhanced\cf2 ;
\par \cf1     \b property\b0  WMFHandle\cf2 :\cf1  HMETAFILE \b read\b0  FWMFHandle \b write\b0  SetWMFHandle\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par 
\par \i0   \cf0\i \{ Declares possible values for the AFunction parameter in the @link(TKTextBox.Process) function. \}
\par \i0\cf1   TKTextBoxFunction \cf2 =\cf1  \cf2 (
\par \cf1     \cf0\i \{ Measure text box contents. \}
\par \i0\cf1     tbfMeasure\cf2 ,
\par \cf1     \cf0\i \{ Get text index for coordinates stored in FPoint. \}
\par \i0\cf1     tbfGetIndex\cf2 ,
\par \cf1     \cf0\i \{ Get boundary rectangle for index stored in FIndex. \}
\par \i0\cf1     tbfGetRect\cf2 ,
\par \cf1     \cf0\i \{ Draw text box contents. \}
\par \i0\cf1     tbfDraw
\par   \cf2 );
\par 
\par \cf1   \cf0\i \{ Implements advanced text block rendering. Formerly implemented as @link(DrawAlignedText) function. \}
\par \i0\cf1   TKTextBox \cf2 =\cf1  \b class\b0\cf2 (\cf1 TObject\cf2 )
\par \cf1   \b private
\par \b0     FAttributes\cf2 :\cf1  TKTextAttributes\cf2 ;
\par \cf1     FBackColor\cf2 :\cf1  TColor\cf2 ;
\par \cf1     FHAlign\cf2 :\cf1  TKHAlign\cf2 ;
\par \cf1     FHPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FSelBkgnd\cf2 :\cf1  TColor\cf2 ;
\par \cf1     FSelColor\cf2 :\cf1  TColor\cf2 ;
\par \cf1     FSelEnd\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FSelStart\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FSpacesForTab\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FText\cf2 :\cf1  TKString\cf2 ;
\par \cf1     FVAlign\cf2 :\cf1  TKVAlign\cf2 ;
\par \cf1     FVPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1     \b procedure\b0  SetText\cf2 (\cf1\b const\b0  AText\cf2 :\cf1  TKString\cf2 );
\par \cf1   \b protected
\par \b0     FCanvas\cf2 :\cf1  TCanvas\cf2 ;
\par \cf1     FClipRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1     FFontHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FHasTabs\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FIndex\cf2 :\cf1  Integer\cf2 ;
\par \cf1     FCalcRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1     \b function\b0  GetHorzPos\cf2 (\cf1 ATextWidth\cf2 :\cf1  Integer\cf2 ):\cf1  Integer\cf2 ;
\par \cf1     \b function\b0  GetVertPos\cf2 :\cf1  Integer\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b procedure\b0  Initialize\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b procedure\b0  Process\cf2 (\cf1 Y\cf2 :\cf1  Integer\cf2 ;\cf1  AFunction\cf2 :\cf1  TKTextBoxFunction\cf2 );
\par \cf1     \b procedure\b0  TextTrim\cf2 (\cf1\b const\b0  AText\cf2 :\cf1  TKString\cf2 ;\cf1  \b var\b0  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );\cf1  \b virtual\b0\cf2 ;
\par \cf1   \b public
\par \b0     \b constructor\b0  Create\cf2 ;
\par \cf1     \b procedure\b0  Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b function\b0  IndexToRect\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AIndex\cf2 :\cf1  Integer\cf2 ):\cf1  TRect\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b procedure\b0  Measure\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  \b var\b0  AWidth\cf2 ,\cf1  AHeight\cf2 :\cf1  Integer\cf2 );\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b function\b0  PointToIndex\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  APoint\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;\cf1  \b virtual\b0\cf2 ;
\par \cf1     \b class\b0  \b function\b0  TextExtent\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;
\par \cf1        AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 ;\cf1  AExpandTabs\cf2 :\cf1  Boolean \cf2 =\cf1  False\cf2 ;\cf1  ASpacesForTab\cf2 :\cf1  Integer \cf2 =\cf1  \cf5 2\cf2 ):\cf1  TSize\cf2 ;
\par \cf1     \b class\b0  \b procedure\b0  TextOutput\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;
\par \cf1       \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;\cf1  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 ;
\par \cf1       AExpandTabs\cf2 :\cf1  Boolean \cf2 =\cf1  False\cf2 ;\cf1  ASpacesForTab\cf2 :\cf1  Integer \cf2 =\cf1  \cf5 2\cf2 );
\par \cf1     \b property\b0  Attributes\cf2 :\cf1  TKTextAttributes \b read\b0  FAttributes \b write\b0  FAttributes\cf2 ;
\par \cf1     \b property\b0  BackColor\cf2 :\cf1  TColor \b read\b0  FBackColor \b write\b0  FBackColor\cf2 ;
\par \cf1     \b property\b0  HAlign\cf2 :\cf1  TKHAlign \b read\b0  FHAlign \b write\b0  FHAlign\cf2 ;
\par \cf1     \b property\b0  HPadding\cf2 :\cf1  Integer \b read\b0  FHPadding \b write\b0  FHPadding\cf2 ;
\par \cf1     \b property\b0  SelBkgnd\cf2 :\cf1  TColor \b read\b0  FSelBkgnd \b write\b0  FSelBkgnd\cf2 ;
\par \cf1     \b property\b0  SelColor\cf2 :\cf1  TColor \b read\b0  FSelColor \b write\b0  FSelColor\cf2 ;
\par \cf1     \b property\b0  SelEnd\cf2 :\cf1  Integer \b read\b0  FSelEnd \b write\b0  FSelEnd\cf2 ;
\par \cf1     \b property\b0  SelStart\cf2 :\cf1  Integer \b read\b0  FSelStart \b write\b0  FSelStart\cf2 ;
\par \cf1     \b property\b0  SpacesForTab\cf2 :\cf1  Integer \b read\b0  FSpacesForTab \b write\b0  FSpacesForTab\cf2 ;
\par \cf1     \b property\b0  Text\cf2 :\cf1  TKString \b read\b0  FText \b write\b0  SetText\cf2 ;
\par \cf1     \b property\b0  VAlign\cf2 :\cf1  TKVAlign \b read\b0  FVAlign \b write\b0  FVAlign\cf2 ;
\par \cf1     \b property\b0  VPadding\cf2 :\cf1  Integer \b read\b0  FVPadding \b write\b0  FVPadding\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0   TUpdateLayeredWindowProc \cf2 =\cf1  \b function\b0\cf2 (\cf1 Handle\cf2 :\cf1  THandle\cf2 ;\cf1  hdcDest\cf2 :\cf1  HDC\cf2 ;\cf1  pptDst\cf2 :\cf1  PPoint\cf2 ;
\par \cf1     _psize\cf2 :\cf1  PSize\cf2 ;\cf1  hdcSrc\cf2 :\cf1  HDC\cf2 ;\cf1  pptSrc\cf2 :\cf1  PPoint\cf2 ;\cf1  crKey\cf2 :\cf1  COLORREF\cf2 ;\cf1  pblend\cf2 :\cf1  PBLENDFUNCTION\cf2 ;
\par \cf1     dwFlags\cf2 :\cf1  DWORD\cf2 ):\cf1  Boolean\cf2 ;\cf1  \b stdcall\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par 
\par \i0   \cf0\i \{ @abstract(Encapsulates the drag window)
\par     Drag window is top level window used for dragging with mouse. It displays
\par     some portion of associated control. It can be translucent under Windows. \}
\par \i0\cf1   TKDragWindow \cf2 =\cf1  \b class\b0\cf2 (\cf1 TObject\cf2 )
\par \cf1   \b private
\par \b0     FActive\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FAlphaEffects\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FBitmap\cf2 :\cf1  TKAlphaBitmap\cf2 ;
\par \cf1     FBitmapFilled\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FControl\cf2 :\cf1  TCustomControl\cf2 ;
\par \cf1     FGradient\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FInitialPos\cf2 :\cf1  TPoint\cf2 ;
\par \cf1     FLayered\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     FMasterAlpha\cf2 :\cf1  Byte\cf2 ;
\par \cf1     FRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   \i \{$IFDEF USE_WINAPI\}
\par \i0     FBlend\cf2 :\cf1  TBlendFunction\cf2 ;
\par \cf1     FUpdateLayeredWindow\cf2 :\cf1  TUpdateLayeredWindowProc\cf2 ;
\par \cf1     FWindow\cf2 :\cf1  HWND\cf2 ;
\par \cf1   \i \{$ELSE\}
\par \i0     FDragForm\cf2 :\cf1  TCustomForm\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0   \b public
\par \b0     \cf0\i \{ Creates the instance. \}
\par \i0\cf1     \b constructor\b0  Create\cf2 ;
\par \cf1     \cf0\i \{ Destroys the instance. \}
\par \i0\cf1     \b destructor\b0  Destroy\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Shows the drag window on screen. Takes a rectangular part as set by ARect from
\par       IniCtrl's Canvas and displays it at position InitialPos. MasterAlpha and
\par       Gradient are used to premaster the copied image with a specific fading effect. \}
\par \i0\cf1     \b procedure\b0  Init\cf2 (\cf1 IniCtrl\cf2 :\cf1  TCustomControl\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1       \b const\b0  AInitialPos\cf2 :\cf1  TPoint\cf2 ;\cf1  AMasterAlpha\cf2 :\cf1  Byte\cf2 ;\cf1  AGradient\cf2 :\cf1  Boolean\cf2 );
\par \cf1     \cf0\i \{ Moves the drag window to a new location. \}
\par \i0\cf1     \b procedure\b0  Move\cf2 (\cf1 ARect\cf2 :\cf1  PRect\cf2 ;\cf1  \b const\b0  ACurrentPos\cf2 :\cf1  TPoint\cf2 ;\cf1  AShowAlways\cf2 :\cf1  Boolean\cf2 );
\par \cf1     \cf0\i \{ Hides the drag window. \}
\par \i0\cf1     \b procedure\b0  Hide\cf2 ;
\par \cf1     \cf0\i \{ Returns True if the drag window is shown. \}
\par \i0\cf1     \b property\b0  Active\cf2 :\cf1  Boolean \b read\b0  FActive\cf2 ;
\par \cf1     \cf0\i \{ Returns the pointer to the bitmap that holds the copied control image. \}
\par \i0\cf1     \b property\b0  Bitmap\cf2 :\cf1  TKAlphaBitmap \b read\b0  FBitmap\cf2 ;
\par \cf1     \cf0\i \{ Returns True if the control already copied itself to the bitmap. \}
\par \i0\cf1     \b property\b0  BitmapFilled\cf2 :\cf1  Boolean \b read\b0  FBitmapFilled\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \cf0\i \{ @abstract(Base class for KControls hints)
\par     This class extends the standard THintWindow class. It adds functionality
\par     common to all hints used in KControls. \}
\par 
\par \i0\cf1   \cf0\i \{ TKHintWindow \}
\par 
\par \i0\cf1   TKHintWindow \cf2 =\cf1  \b class\b0\cf2 (\cf1 THintWindow\cf2 )
\par \cf1   \b private
\par \b0     FExtent\cf2 :\cf1  TPoint\cf2 ;
\par \cf1     \b procedure\b0  WMEraseBkGnd\cf2 (\cf1\b var\b0  Msg\cf2 :\cf1  TLMessage\cf2 );\cf1  \b message\b0  LM_ERASEBKGND\cf2 ;
\par \cf1   \b public
\par \b0     \cf0\i \{ Creates the instance. \}
\par \i0\cf1     \b constructor\b0  Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ Shows the hint at given position. This is an IDE independent implementation. \}
\par \i0\cf1     \b procedure\b0  ShowAt\cf2 (\cf1\b const\b0  Origin\cf2 :\cf1  TPoint\cf2 );
\par \cf1     \cf0\i \{ Hides the hint. \}
\par \i0\cf1     \b procedure\b0  Hide\cf2 ;
\par \cf1     \cf0\i \{ Returns the extent of the hint. \}
\par \i0\cf1     \b property\b0  Extent\cf2 :\cf1  TPoint \b read\b0  FExtent\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \cf0\i \{ @abstract(Hint window to display formatted text)
\par     This class implements the textual hint window. The text is displayed . \}
\par \i0\cf1   TKTextHint \cf2 =\cf1  \b class\b0\cf2 (\cf1 TKHintWindow\cf2 )
\par \cf1   \b private
\par \b0     FText\cf2 :\cf1  TKString\cf2 ;
\par \cf1     \b procedure\b0  SetText\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  TKString\cf2 );
\par \cf1   \b protected
\par \b0     \cf0\i \{ Overriden method. Paints the hint. \}
\par \i0\cf1     \b procedure\b0  Paint\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1   \b public
\par \b0     \cf0\i \{ Creates the instance. \}
\par \i0\cf1     \b constructor\b0  Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \cf0\i \{ \}
\par \i0\cf1     \b property\b0  Text\cf2 :\cf1  TKString \b read\b0  FText \b write\b0  SetText\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   TKGraphicHint \cf2 =\cf1  \b class\b0\cf2 (\cf1 TKHintWindow\cf2 )
\par \cf1   \b private
\par \b0     FGraphic\cf2 :\cf1  TGraphic\cf2 ;
\par \cf1     \b procedure\b0  SetGraphic\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  TGraphic\cf2 );
\par \cf1   \b protected
\par \b0     \cf0\i \{ Overriden method. Paints the hint. \}
\par \i0\cf1     \b procedure\b0  Paint\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1   \b public
\par \b0     \b constructor\b0  Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );\cf1  \b override\b0\cf2 ;
\par \cf1     \b property\b0  Graphic\cf2 :\cf1  TGraphic \b read\b0  FGraphic \b write\b0  SetGraphic\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf0\i \{ Draws Src to Dest with per pixel weighting by alpha channel saved in Src. \}
\par \i0\cf1\b procedure\b0  BlendLine\cf2 (\cf1 Src\cf2 ,\cf1  Dest\cf2 :\cf1  PKColorRecs\cf2 ;\cf1  Count\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Calculates a brighter color of given color based on the HSL color space.
\par   <UL>
\par   <LH>Parameters:</LH>
\par   <LI><I>Color</I> - input color.</LI>
\par   <LI><I>Percent</I> - percentage of luminosity to bright the color (0 to 1).</LI>
\par   <LI><I>Mode</I> - identifies how the Percent parameter should be interpreted.</LI>
\par   </UL> \}
\par \i0\cf1\b function\b0  BrightColor\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ;\cf1  Percent\cf2 :\cf1  Single\cf2 ;\cf1  Mode\cf2 :\cf1  TKBrightMode \cf2 =\cf1  bsAbsolute\cf2 ):\cf1  TColor\cf2 ;
\par 
\par \cf0\i \{ Returns current canvas window/wiewport scaling. \}
\par \i0\cf1\b procedure\b0  CanvasGetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b out\b0  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Selects the default window/wiewport scaling to given canvas for both axes. \}
\par \i0\cf1\b procedure\b0  CanvasResetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 );
\par 
\par \cf0\i \{ Returns True if the ACanvas's device context has been mapped to anything else
\par   than MM_TEXT. \}
\par \i0\cf1\b function\b0  CanvasScaled\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Selects the window/wiewport scaling to given canvas for both axes. \}
\par \i0\cf1\b procedure\b0  CanvasSetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Selects the wiewport offset to given canvas for both axes. \}
\par \i0\cf1\b procedure\b0  CanvasSetOffset\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  OfsX\cf2 ,\cf1  OfsY\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Converts TKColorRec to TColor. \}
\par \i0\cf1\b function\b0  ColorRecToColor\cf2 (\cf1 Color\cf2 :\cf1  TKColorRec\cf2 ):\cf1  TColor\cf2 ;
\par 
\par \cf0\i \{ Converts TColor to TKColorRec. \}
\par \i0\cf1\b function\b0  ColorToColorRec\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  TKColorRec\cf2 ;
\par 
\par \cf0\i \{ Makes a grayscale representation of the given color. \}
\par \i0\cf1\b function\b0  ColorToGrayScale\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  TColor\cf2 ;
\par 
\par \cf0\i \{ Returns True if properties of the two brushes are equal. \}
\par \i0\cf1\b function\b0  CompareBrushes\cf2 (\cf1 ABrush1\cf2 ,\cf1  ABrush2\cf2 :\cf1  TBrush\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Returns True if properties of the two fonts are equal. \}
\par \i0\cf1\b function\b0  CompareFonts\cf2 (\cf1 AFont1\cf2 ,\cf1  AFont2\cf2 :\cf1  TFont\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Calls BitBlt. \}
\par \i0\cf1\b procedure\b0  CopyBitmap\cf2 (\cf1 DestDC\cf2 :\cf1  HDC\cf2 ;\cf1  DestRect\cf2 :\cf1  TRect\cf2 ;\cf1  SrcDC\cf2 :\cf1  HDC\cf2 ;\cf1  SrcX\cf2 ,\cf1  SrcY\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Creates an empty point. \}
\par \i0\cf1\b function\b0  CreateEmptyPoint\cf2 :\cf1  TPoint\cf2 ;
\par 
\par \cf0\i \{ Creates an empty rectangle. \}
\par \i0\cf1\b function\b0  CreateEmptyRect\cf2 :\cf1  TRect\cf2 ;
\par 
\par \cf0\i \{ Creates an empty rectangular region. \}
\par \i0\cf1\b function\b0  CreateEmptyRgn\cf2 :\cf1  HRGN\cf2 ;
\par 
\par \cf0\i \{ Draws Text to the Canvas at location given by ARect.
\par   This function is here for backward compatibility.
\par   HAlign and VAlign specify horizontal resp. vertical alignment of the text
\par   within ARect. HPadding and VPadding specify horizontal (both on left and right side)
\par   and vertical (both on top and bottom side) padding of the Text from ARect.
\par   BackColor specifies the fill color for brush gaps if a non solid Brush
\par   is defined in Canvas. Attributes specift various text output attributes. \}
\par \i0\cf1\b procedure\b0  DrawAlignedText\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b var\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   HAlign\cf2 :\cf1  TKHAlign\cf2 ;\cf1  VAlign\cf2 :\cf1  TKVAlign\cf2 ;\cf1  HPadding\cf2 ,\cf1  VPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;
\par \cf1   BackColor\cf2 :\cf1  TColor \cf2 =\cf1  clWhite\cf2 ;\cf1  Attributes\cf2 :\cf1  TKTextAttributes \cf2 =\cf1  \cf2 []);
\par 
\par \cf0\i \{ Draws standard button frame \}
\par \i0\cf1\b procedure\b0  DrawButtonFrame\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   AStates\cf2 :\cf1  TKButtonDrawStates\cf2 );
\par 
\par \cf0\i \{ Simulates WinAPI DrawEdge with customizable colors. \}
\par \i0\cf1\b procedure\b0  DrawEdges\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  R\cf2 :\cf1  TRect\cf2 ;\cf1  HighlightColor\cf2 ,
\par \cf1   ShadowColor\cf2 :\cf1  TColor\cf2 ;\cf1  Flags\cf2 :\cf1  Cardinal\cf2 );
\par 
\par \cf0\i \{ Draws a rectangle to Canvas. The rectangle coordinates are given by Rect.
\par   The rectangle is filled by Brush. If Brush is not solid, its gaps are filled
\par   with BackColor. If BackColor is clNone these gaps are not filled and the Brush
\par   appears transparent. \}
\par \i0\cf1\b procedure\b0  DrawFilledRectangle\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   BackColor\cf2 :\cf1  TColor\cf2 );
\par 
\par \cf0\i \{ Fills rectangle with linear gradient. Parameters should be self explaining. \}
\par \i0\cf1\b procedure\b0  DrawGradientRect\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   AStartColor\cf2 ,\cf1  AEndColor\cf2 :\cf1  TColor\cf2 ;\cf1  AColorStep\cf2 :\cf1  Integer\cf2 ;\cf1  AHorizontal\cf2 :\cf1  Boolean\cf2 );
\par 
\par \cf0\i \{ This helper function excludes a rectangular area occupied by a shape from
\par   BaseRect and calculates the shape area rectangles Bounds and Interior.
\par   The shape area is specified by the shape extent (ShapeWidth and ShapeHeight),
\par   padding (HPadding and VPadding) and stretching mode (StretchMode).
\par   The returned Bounds includes (possibly stretched) shape + padding,
\par   and Interior includes only the (possibly stretched) shape.
\par   HAlign specifies the horizontal alignment of shape area within BaseRect.
\par   VAlign specifies the vertical alignment of shape area within BaseRect.
\par   The shape area is always excluded horizontally from BaseRect, as needed by cell
\par   data calculations in KGrid. \}
\par \i0\cf1\b procedure\b0  ExcludeShapeFromBaseRect\cf2 (\cf1\b var\b0  BaseRect\cf2 :\cf1  TRect\cf2 ;\cf1  ShapeWidth\cf2 ,\cf1  ShapeHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1   HAlign\cf2 :\cf1  TKHAlign\cf2 ;\cf1  VAlign\cf2 :\cf1  TKVAlign\cf2 ;\cf1  HPadding\cf2 ,\cf1  VPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1   StretchMode\cf2 :\cf1  TKStretchMode\cf2 ;\cf1  \b out\b0  Bounds\cf2 ,\cf1  Interior\cf2 :\cf1  TRect\cf2 );
\par 
\par \cf0\i \{ Selects ARect into device context. Returns previous clipping region. \}
\par \i0\cf1\b function\b0  ExtSelectClipRect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  Mode\cf2 :\cf1  Integer\cf2 ;\cf1  \b var\b0  PrevRgn\cf2 :\cf1  HRGN\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Selects ARect into device context. Combines with CurRgn and
\par   returns previous clipping region. Both regions have to be created first. \}
\par \i0\cf1\b function\b0  ExtSelectClipRectEx\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  Mode\cf2 :\cf1  Integer\cf2 ;\cf1  CurRgn\cf2 ,\cf1  PrevRgn\cf2 :\cf1  HRGN\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Fills the area specified by the difference Boundary - Interior on ACanvas with current Brush.
\par   If Brush is not solid, its gaps are filled with BackColor. If BackColor is
\par   clNone these gaps are not filled and the Brush appears transparent. \}
\par \i0\cf1\b procedure\b0  FillAroundRect\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  Boundary\cf2 ,\cf1  Interior\cf2 :\cf1  TRect\cf2 ;\cf1  BackColor\cf2 :\cf1  TColor\cf2 );
\par 
\par \cf0\i \{ Determine the height (ascent + descent) of the font currently selected into given DC. \}
\par \i0\cf1\b function\b0  GetFontHeight\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf0\i \{ Determine the ascent of the font currently selected into given DC. \}
\par \i0\cf1\b function\b0  GetFontAscent\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf0\i \{ Determine the descent of the font currently selected into given DC. \}
\par \i0\cf1\b function\b0  GetFontDescent\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf0\i \{ Raises an exception if GDI resource has not been created. \}
\par \i0\cf1\b function\b0  GDICheck\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf0\i \{ Returns horizontal position of shape within ABoundary according to AAlignment. Shape has size defined by AShapeSize. \}
\par \i0\cf1\b function\b0  HorizontalShapePosition\cf2 (\cf1 AAlignment\cf2 :\cf1  TKHAlign\cf2 ;\cf1  \b const\b0  ABoundary\cf2 :\cf1  TRect\cf2 ;\cf1  \b const\b0  AShapeSize\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf0\i \{ Creates a TGraphic instance according to the image file header.
\par   Currently supported images are BMP, PNG, MNG, JPG, ICO. \}
\par \i0\cf1\b function\b0  ImageByType\cf2 (\cf1\b const\b0  Header\cf2 :\cf1  TKImageHeaderString\cf2 ):\cf1  TGraphic\cf2 ;
\par 
\par \cf0\i \{ Calls the IntersectClipRect function. \}
\par \i0\cf1\b function\b0  IntersectClipRectIndirect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Determines if given color has lightness > 0.5. \}
\par \i0\cf1\b function\b0  IsBrightColor\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Loads a custom mouse cursor. \}
\par \i0\cf1\b procedure\b0  LoadCustomCursor\cf2 (\cf1 Cursor\cf2 :\cf1  TCursor\cf2 ;\cf1  \b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 );
\par 
\par \cf0\i \{ Loads graphic from resource. \}
\par \i0\cf1\b procedure\b0  LoadGraphicFromResource\cf2 (\cf1 Graphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  \b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 ;\cf1  ResType\cf2 :\cf1  PChar\cf2 );
\par 
\par \cf0\i \{ Builds a TKColorRec structure. \}
\par \i0\cf1\b function\b0  MakeColorRec\cf2 (\cf1 R\cf2 ,\cf1  G\cf2 ,\cf1  B\cf2 ,\cf1  A\cf2 :\cf1  Byte\cf2 ):\cf1  TKColorRec\cf2 ;\cf1  \b overload\b0\cf2 ;
\par 
\par \cf0\i \{ Builds a TKColorRec structure. \}
\par \i0\cf1\b function\b0  MakeColorRec\cf2 (\cf1 Value\cf2 :\cf1  LongWord\cf2 ):\cf1  TKColorRec\cf2 ;\cf1  \b overload\b0\cf2 ;
\par 
\par \cf0\i \{ Returns a pixel format that matches Bpp. \}
\par \i0\cf1\b function\b0  PixelFormatFromBpp\cf2 (\cf1 Bpp\cf2 :\cf1  Cardinal\cf2 ):\cf1  TPixelFormat\cf2 ;
\par 
\par \cf0\i \{ In Lazarus this WinAPI function is missing. \}
\par \i0\cf1\b function\b0  RectInRegion\cf2 (\cf1 Rgn\cf2 :\cf1  HRGN\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ):\cf1  Boolean\cf2 ;
\par 
\par \cf0\i \{ Creates the region and copies the device context's current region into it. \}
\par \i0\cf1\b function\b0  RgnCreateAndGet\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  HRGN\cf2 ;
\par 
\par \cf0\i \{ Selects the region into given device context and deletes the region. \}
\par \i0\cf1\b procedure\b0  RgnSelectAndDelete\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  Rgn\cf2 :\cf1  HRGN\cf2 );
\par 
\par \cf0\i \{ Paints rectangle with rounded corners. \}
\par \i0\cf1\b procedure\b0  RoundRectangle\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AXRadius\cf2 ,\cf1  AYRadius\cf2 :\cf1  Integer\cf2 );
\par 
\par \cf0\i \{ Paints an image so that it fits in ARect. Performs double buffering and fills
\par   the background with current brush for mapped device contexts. \}
\par \i0\cf1\b procedure\b0  SafeStretchDraw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AGraphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  ABackColor\cf2 :\cf1  TColor \cf2 =\cf1  clWhite\cf2 );
\par 
\par \cf0\i \{ Selects ARect as new clipping region into the device context. \}
\par \i0\cf1\b procedure\b0  SelectClipRect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par 
\par \cf0\i \{ Calls StretchBlt. \}
\par \i0\cf1\b procedure\b0  StretchBitmap\cf2 (\cf1 DestDC\cf2 :\cf1  HDC\cf2 ;\cf1  DestRect\cf2 :\cf1  TRect\cf2 ;\cf1  SrcDC\cf2 :\cf1  HDC\cf2 ;\cf1  SrcRect\cf2 :\cf1  TRect\cf2 );
\par 
\par \cf0\i \{ Swaps the color format from RGB to BGR and vice versa. \}
\par \i0\cf1\b function\b0  SwitchRGBToBGR\cf2 (\cf1 Value\cf2 :\cf1  TColor\cf2 ):\cf1  TColor\cf2 ;
\par 
\par \cf0\i \{ Subtracts the current device context offset from ARect. \}
\par \i0\cf1\b procedure\b0  TranslateRectToDevice\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  \b var\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par 
\par \cf0\i \{ Returns vertical position of shape within ABoundary according to AAlignment. Shape has size defined by AShapeSize. \}
\par \i0\cf1\b function\b0  VerticalShapePosition\cf2 (\cf1 AAlignment\cf2 :\cf1  TKVAlign\cf2 ;\cf1  \b const\b0  ABoundary\cf2 :\cf1  TRect\cf2 ;\cf1  \b const\b0  AShapeSize\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;
\par 
\par \cf1\b implementation
\par 
\par uses
\par \b0   Math\cf2 ,\cf1  SysUtils\cf2 ,\cf1  KControls\cf2 ,\cf1  KRes
\par \i \{$IFDEF FPC\}
\par \i0   \cf2 ,\cf1  FPImage
\par \i \{$ELSE\}
\par \i0   \cf2 ,\cf1  JPeg
\par \i \{$ENDIF\}
\par \i0   \cf2 ;
\par 
\par \cf1\b procedure\b0  BlendLine\cf2 (\cf1 Src\cf2 ,\cf1  Dest\cf2 :\cf1  PKColorRecs\cf2 ;\cf1  Count\cf2 :\cf1  Integer\cf2 );
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1   R\cf2 ,\cf1  G\cf2 ,\cf1  B\cf2 ,\cf1  A1\cf2 ,\cf1  A2\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \cf0\i // without assembler
\par \i0\cf1   \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  Count \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0   \b begin
\par \b0     A1 \cf2 :=\cf1  Src\cf2 [\cf1 I\cf2 ].\cf1 A\cf2 ;
\par \cf1     A2 \cf2 :=\cf1  \cf5 255\cf1  \cf2 -\cf1  A1\cf2 ;
\par \cf1     Inc\cf2 (\cf1 A1\cf2 );
\par \cf1     Inc\cf2 (\cf1 A2\cf2 );
\par \cf1     R \cf2 :=\cf1  Src\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 *\cf1  A1 \cf2 +\cf1  Dest\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 *\cf1  A2\cf2 ;
\par \cf1     G \cf2 :=\cf1  Src\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 *\cf1  A1 \cf2 +\cf1  Dest\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 *\cf1  A2\cf2 ;
\par \cf1     B \cf2 :=\cf1  Src\cf2 [\cf1 I\cf2 ].\cf1 B \cf2 *\cf1  A1 \cf2 +\cf1  Dest\cf2 [\cf1 I\cf2 ].\cf1 B \cf2 *\cf1  A2\cf2 ;
\par \cf1     Dest\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 :=\cf1  R \b shr\b0  \cf5 8\cf2 ;
\par \cf1     Dest\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 :=\cf1  G \b shr\b0  \cf5 8\cf2 ;
\par \cf1     Dest\cf2 [\cf1 I\cf2 ].\cf1 B \cf2 :=\cf1  B \b shr\b0  \cf5 8\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CalcLightness\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  Single\cf2 ;
\par \cf1\b var
\par \b0   X\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   X \cf2 :=\cf1  ColorToColorRec\cf2 (\cf1 Color\cf2 );
\par \cf1   Result \cf2 :=\cf1  \cf2 (\cf1 X\cf2 .\cf1 R \cf2 +\cf1  X\cf2 .\cf1 G \cf2 +\cf1  X\cf2 .\cf1 B\cf2 )\cf1  \cf2 /\cf1  \cf2 (\cf5 3\cf1  \cf2 *\cf1  \cf5 256\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  BrightColor\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ;\cf1  Percent\cf2 :\cf1  Single\cf2 ;\cf1  Mode\cf2 :\cf1  TKBrightMode\cf2 ):\cf1  TColor\cf2 ;
\par \cf1\b var
\par \b0   L\cf2 ,\cf1  Tmp\cf2 :\cf1  Single\cf2 ;
\par 
\par \cf1   \b function\b0  Func1\cf2 (\cf1 Value\cf2 :\cf1  Single\cf2 ):\cf1  Single\cf2 ;
\par \cf1   \b begin
\par \b0     Result \cf2 :=\cf1  Value \cf2 *\cf1  \cf2 (\cf1 L \cf2 +\cf1  Percent\cf2 )\cf1  \cf2 /\cf1  L\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \b function\b0  Func2\cf2 (\cf1 Value\cf2 :\cf1  Single\cf2 ):\cf1  Single\cf2 ;
\par \cf1   \b begin
\par \b0     Result \cf2 :=\cf1  \cf5 1\cf1  \cf2 -\cf1  \cf2 (\cf6 0.5\cf1  \cf2 -\cf1  Tmp\cf2 )\cf1  \cf2 *\cf1  \cf2 (\cf5 1\cf1  \cf2 -\cf1  Value\cf2 )\cf1  \cf2 /\cf1  \cf2 (\cf5 1\cf1  \cf2 -\cf1  L\cf2 );
\par \cf1     \cf0\i \{ this is the shorter form of
\par       Value := 1 - 0.5 * (1 - Value) / (1 - L) ; // get color with L = 0.5
\par       Result := 1 - (0.5 - Tmp) * (1 - Value) / 0.5; // get corresponding color
\par     \}
\par \i0\cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \b function\b0  Rd\cf2 (\cf1 Value\cf2 :\cf1  Single\cf2 ):\cf1  Byte\cf2 ;
\par \cf1   \b begin
\par \b0     Result \cf2 :=\cf1  Min\cf2 (\cf1 Integer\cf2 (\cf1 Round\cf2 (\cf1 Value \cf2 *\cf1  \cf5 255\cf2 )),\cf1  \cf5 512\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1\b var
\par \b0   R\cf2 ,\cf1  G\cf2 ,\cf1  B\cf2 ,\cf1  Cmax\cf2 ,\cf1  Cmin\cf2 :\cf1  Single\cf2 ;
\par \cf1   X\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   X \cf2 :=\cf1  ColorToColorRec\cf2 (\cf1 Color\cf2 );
\par \cf1   R \cf2 :=\cf1  X\cf2 .\cf1 R \cf2 /\cf1  \cf5 255\cf2 ;
\par \cf1   G \cf2 :=\cf1  X\cf2 .\cf1 G \cf2 /\cf1  \cf5 255\cf2 ;
\par \cf1   B \cf2 :=\cf1  X\cf2 .\cf1 B \cf2 /\cf1  \cf5 255\cf2 ;
\par \cf1   Cmax \cf2 :=\cf1  Max\cf2 (\cf1 R\cf2 ,\cf1  Max\cf2 (\cf1 G\cf2 ,\cf1  B\cf2 ));
\par \cf1   Cmin \cf2 :=\cf1  Min\cf2 (\cf1 R\cf2 ,\cf1  Min\cf2 (\cf1 G\cf2 ,\cf1  B\cf2 ));
\par \cf1   L \cf2 :=\cf1  \cf2 (\cf1 Cmax \cf2 +\cf1  Cmin\cf2 )\cf1  \cf2 /\cf1  \cf5 2\cf2 ;
\par \cf1   \b if\b0  L \cf2 <\cf1  \cf5 1\cf1  \b then
\par \b0   \b begin
\par \b0     \b case\b0  Mode \b of
\par \b0       bsOfBottom\cf2 :\cf1  Percent \cf2 :=\cf1  L \cf2 *\cf1  Percent\cf2 ;
\par \cf1       bsOfTop\cf2 :\cf1  Percent \cf2 :=\cf1  \cf2 (\cf5 1\cf1  \cf2 -\cf1  L\cf2 )\cf1  \cf2 *\cf1  Percent\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     Percent \cf2 :=\cf1  Min\cf2 (\cf1 Percent\cf2 ,\cf1  \cf5 1\cf1  \cf2 -\cf1  L\cf2 );
\par \cf1     \b if\b0  L \cf2 =\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       \cf0\i // zero length singularity
\par \i0\cf1       R \cf2 :=\cf1  R \cf2 +\cf1  Percent\cf2 ;\cf1  G \cf2 :=\cf1  G \cf2 +\cf1  Percent\cf2 ;\cf1  B \cf2 :=\cf1  B \cf2 +\cf1  Percent\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0     \b begin
\par \b0       Tmp \cf2 :=\cf1  L \cf2 +\cf1  Percent \cf2 -\cf1  \cf6 0.5\cf2 ;
\par \cf1       \cf0\i // lumination below 0.5
\par \i0\cf1       \b if\b0  L \cf2 <\cf1  \cf6 0.5\cf1  \b then
\par \b0       \b begin
\par \b0         \cf0\i // if L + Percent is >= 0.5, get color with L = 0.5
\par \i0\cf1         Percent \cf2 :=\cf1  Min\cf2 (\cf1 Percent\cf2 ,\cf1  \cf6 0.5\cf1  \cf2 -\cf1  L\cf2 );
\par \cf1         R \cf2 :=\cf1  Func1\cf2 (\cf1 R\cf2 );\cf1  G \cf2 :=\cf1  Func1\cf2 (\cf1 G\cf2 );\cf1  B \cf2 :=\cf1  Func1\cf2 (\cf1 B\cf2 );
\par \cf1         L \cf2 :=\cf1  \cf6 0.5\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       \cf0\i // lumination above 0.5
\par \i0\cf1       \b if\b0  Tmp \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0       \b begin
\par \b0         R \cf2 :=\cf1  Func2\cf2 (\cf1 R\cf2 );\cf1  G \cf2 :=\cf1  Func2\cf2 (\cf1 G\cf2 );\cf1  B \cf2 :=\cf1  Func2\cf2 (\cf1 B\cf2 );
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     X\cf2 .\cf1 R \cf2 :=\cf1  Rd\cf2 (\cf1 R\cf2 );
\par \cf1     X\cf2 .\cf1 G \cf2 :=\cf1  Rd\cf2 (\cf1 G\cf2 );
\par \cf1     X\cf2 .\cf1 B \cf2 :=\cf1  Rd\cf2 (\cf1 B\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1   Result \cf2 :=\cf1  X\cf2 .\cf1 Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  CanvasGetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b out\b0  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 :\cf1  Integer\cf2 );
\par \cf1\i \{$IFDEF USE_DC_MAPPING\}
\par \i0\b var
\par \b0   WindowExt\cf2 ,\cf1  ViewPortExt\cf2 :\cf1  TSize\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   \b if\b0  Boolean\cf2 (\cf1 GetWindowExtEx\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 WindowExt\cf2 ))\cf1  \b and
\par \b0     Boolean\cf2 (\cf1 GetViewPortExtEx\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 ViewPortExt\cf2 ))\cf1  \b then
\par \b0   \b begin
\par \b0     DivX \cf2 :=\cf1  WindowExt\cf2 .\cf1 cx\cf2 ;\cf1  DivY \cf2 :=\cf1  WindowExt\cf2 .\cf1 cy\cf2 ;
\par \cf1     MulX \cf2 :=\cf1  ViewPortExt\cf2 .\cf1 cx\cf2 ;\cf1  MulY \cf2 :=\cf1  ViewPortExt\cf2 .\cf1 cy\cf2 ;
\par \cf1   \b end\b0  \b else
\par \b0\i \{$ENDIF\}
\par \i0   \b begin
\par \b0     MulX \cf2 :=\cf1  \cf5 1\cf2 ;\cf1  DivX \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1     MulY \cf2 :=\cf1  \cf5 1\cf2 ;\cf1  DivY \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  CanvasResetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 );
\par \cf1\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   SetMapMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  MM_TEXT\cf2 );
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CanvasScaled\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   Result \cf2 :=\cf1  \b not\b0  \cf2 (\cf1 GetMapMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 )\cf1  \b in\b0  \cf2 [\cf5 0\cf2 ,\cf1  MM_TEXT\cf2 ]);
\par \cf1\i \{$ELSE\}
\par \i0   Result \cf2 :=\cf1  False\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  CanvasSetScale\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   SetMapMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  MM_ANISOTROPIC\cf2 );
\par \cf1   SetWindowExtEx\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1   SetViewPortExtEx\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1\i \{$ELSE\}
\par \i0   \i \{$WARNING 'Device context window/viewport transformations not working!'\}
\par \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  CanvasSetOffset\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  OfsX\cf2 ,\cf1  OfsY\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   SetMapMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  MM_ANISOTROPIC\cf2 );
\par \cf1   SetViewPortOrgEx\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  OfsX\cf2 ,\cf1  OfsY\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1\i \{$ENDIF\}\i0   
\par \b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ColorToGrayScale\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  TColor\cf2 ;
\par \cf1\b var
\par \b0   GreyValue\cf2 :\cf1  Integer\cf2 ;
\par \cf1   X\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   X \cf2 :=\cf1  ColorToColorRec\cf2 (\cf1 Color\cf2 );
\par \cf1   GreyValue \cf2 :=\cf1  \cf2 (\cf1 Integer\cf2 (\cf5 21\cf2 )\cf1  \cf2 *\cf1  X\cf2 .\cf1 R \cf2 +\cf1  Integer\cf2 (\cf5 72\cf2 )\cf1  \cf2 *\cf1  X\cf2 .\cf1 G \cf2 +\cf1  Integer\cf2 (\cf5 7\cf2 )\cf1  \cf2 *\cf1  X\cf2 .\cf1 B\cf2 )\cf1  \b div\b0  \cf5 100\cf2 ;
\par \cf1   X\cf2 .\cf1 R \cf2 :=\cf1  GreyValue\cf2 ;
\par \cf1   X\cf2 .\cf1 G \cf2 :=\cf1  GreyValue\cf2 ;
\par \cf1   X\cf2 .\cf1 B \cf2 :=\cf1  GreyValue\cf2 ;
\par \cf1   Result \cf2 :=\cf1  X\cf2 .\cf1 Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ColorRecToColor\cf2 (\cf1 Color\cf2 :\cf1  TKColorRec\cf2 ):\cf1  TColor\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  Color\cf2 .\cf1 Value \b and\b0  \cf7 $FFFFFF\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ColorToColorRec\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   Result\cf2 .\cf1 Value \cf2 :=\cf1  ColorToRGB\cf2 (\cf1 Color\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CompareBrushes\cf2 (\cf1 ABrush1\cf2 ,\cf1  ABrush2\cf2 :\cf1  TBrush\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=
\par \cf1     \cf2 (\cf1 ABrush1\cf2 .\cf1 Color \cf2 =\cf1  ABrush2\cf2 .\cf1 Color\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 ABrush1\cf2 .\cf1 Style \cf2 =\cf1  ABrush2\cf2 .\cf1 Style\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CompareFonts\cf2 (\cf1 AFont1\cf2 ,\cf1  AFont2\cf2 :\cf1  TFont\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=
\par \cf1     \cf2 (\cf1 AFont1\cf2 .\cf1 Charset \cf2 =\cf1  AFont2\cf2 .\cf1 Charset\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 AFont1\cf2 .\cf1 Color \cf2 =\cf1  AFont2\cf2 .\cf1 Color\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 AFont1\cf2 .\cf1 Name \cf2 =\cf1  AFont2\cf2 .\cf1 Name\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 AFont1\cf2 .\cf1 Pitch \cf2 =\cf1  AFont2\cf2 .\cf1 Pitch\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 AFont1\cf2 .\cf1 Size \cf2 =\cf1  AFont2\cf2 .\cf1 Size\cf2 )\cf1  \b and
\par \b0     \cf2 (\cf1 AFont1\cf2 .\cf1 Style \cf2 =\cf1  AFont2\cf2 .\cf1 Style\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  CopyBitmap\cf2 (\cf1 DestDC\cf2 :\cf1  HDC\cf2 ;\cf1  DestRect\cf2 :\cf1  TRect\cf2 ;\cf1  SrcDC\cf2 :\cf1  HDC\cf2 ;\cf1  SrcX\cf2 ,\cf1  SrcY\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   \i \{$IFDEF USE_WINAPI\}\i0 Windows\cf2 .\cf1\i \{$ENDIF\}\i0 BitBlt\cf2 (\cf1 DestDC\cf2 ,
\par \cf1     DestRect\cf2 .\cf1 Left\cf2 ,\cf1  DestRect\cf2 .\cf1 Top\cf2 ,\cf1  DestRect\cf2 .\cf1 Right \cf2 -\cf1  DestRect\cf2 .\cf1 Left\cf2 ,\cf1  DestRect\cf2 .\cf1 Bottom \cf2 -\cf1  DestRect\cf2 .\cf1 Top\cf2 ,
\par \cf1     SrcDC\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  SRCCOPY\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CreateEmptyPoint\cf2 :\cf1  TPoint\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  Point\cf2 (\cf5 0\cf2 ,\cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CreateEmptyRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  CreateEmptyRgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  CreateRectRgn\cf2 (\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  DrawAlignedText\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b var\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   HAlign\cf2 :\cf1  TKHAlign\cf2 ;\cf1  VAlign\cf2 :\cf1  TKVAlign\cf2 ;\cf1  HPadding\cf2 ,\cf1  VPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;
\par \cf1   BackColor\cf2 :\cf1  TColor\cf2 ;\cf1  Attributes\cf2 :\cf1  TKTextAttributes\cf2 );
\par \cf1\b var
\par \b0   TextBox\cf2 :\cf1  TKTextBox\cf2 ;
\par \cf1   Width\cf2 ,\cf1  Height\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   TextBox \cf2 :=\cf1  TKTextBox\cf2 .\cf1 Create\cf2 ;
\par \cf1   \b try
\par \b0     TextBox\cf2 .\cf1 Attributes \cf2 :=\cf1  Attributes\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 BackColor \cf2 :=\cf1  BackColor\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 HAlign \cf2 :=\cf1  HAlign\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 HPadding \cf2 :=\cf1  HPadding\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 Text \cf2 :=\cf1  AText\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 VAlign \cf2 :=\cf1  VAlign\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 VPadding \cf2 :=\cf1  VPadding\cf2 ;
\par \cf1     \b if\b0  taCalcRect \b in\b0  Attributes \b then
\par \b0     \b begin
\par \b0       TextBox\cf2 .\cf1 Measure\cf2 (\cf1 Canvas\cf2 ,\cf1  ARect\cf2 ,\cf1  Width\cf2 ,\cf1  Height\cf2 );
\par \cf1       ARect\cf2 .\cf1 Right \cf2 :=\cf1  ARect\cf2 .\cf1 Left \cf2 +\cf1  Width\cf2 ;
\par \cf1       ARect\cf2 .\cf1 Bottom \cf2 :=\cf1  ARect\cf2 .\cf1 Top \cf2 +\cf1  Height\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0       TextBox\cf2 .\cf1 Draw\cf2 (\cf1 Canvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1   \b finally
\par \b0     TextBox\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  DrawButtonFrame\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   AStates\cf2 :\cf1  TKButtonDrawStates\cf2 );
\par \cf1\b var
\par \b0   BM\cf2 :\cf1  TBitmap\cf2 ;
\par \cf1   TmpCanvas\cf2 :\cf1  TCanvas\cf2 ;
\par \cf1   TmpRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   ButtonState\cf2 :\cf1  Integer\cf2 ;
\par \cf1\i \{$IFDEF USE_THEMES\}
\par \i0   ButtonTheme\cf2 :\cf1  TThemedButton\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0   \cf0\i // a LOT of tweaking here...
\par \cf1 \{$IF DEFINED(USE_WINAPI) OR DEFINED(LCLQT) \}\i0  \cf0\i // GTK2 cannot strech and paint on bitmap canvas, grrr..
\par \i0\cf1   \b if\b0  CanvasScaled\cf2 (\cf1 ACanvas\cf2 )\cf1  \i \{$IFDEF USE_WINAPI\}\i0\b and\b0  \cf2 (\cf1 bsUseThemes \b in\b0  AStates\cf2 )\cf1\i \{$ENDIF\}\i0  \b then
\par \b0   \b begin
\par \b0     BM \cf2 :=\cf1  TBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1     BM\cf2 .\cf1 Width \cf2 :=\cf1  ARect\cf2 .\cf1 Right \cf2 -\cf1  ARect\cf2 .\cf1 Left\cf2 ;
\par \cf1     BM\cf2 .\cf1 Height \cf2 :=\cf1  ARect\cf2 .\cf1 Bottom \cf2 -\cf1  ARect\cf2 .\cf1 Top\cf2 ;
\par \cf1     BM\cf2 .\cf1 Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Assign\cf2 (\cf1 ACanvas\cf2 .\cf1 Brush\cf2 );
\par \cf1     TmpRect \cf2 :=\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  BM\cf2 .\cf1 Width\cf2 ,\cf1  BM\cf2 .\cf1 Height\cf2 );
\par \cf1     BM\cf2 .\cf1 Canvas\cf2 .\cf1 FillRect\cf2 (\cf1 TmpRect\cf2 );
\par \cf1     TmpCanvas \cf2 :=\cf1  BM\cf2 .\cf1 Canvas\cf2 ;
\par \cf1   \b end\b0  \b else
\par \b0\i \{$IFEND\}
\par \i0   \b begin
\par \b0     BM \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1     TmpRect \cf2 :=\cf1  ARect\cf2 ;
\par \cf1     TmpCanvas \cf2 :=\cf1  ACanvas\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   \b try
\par \b0   \i \{$IFDEF USE_THEMES\}
\par \i0     \b if\b0  bsUseThemes \b in\b0  AStates \b then
\par \b0     \b begin
\par \b0       \b if\b0  bsDisabled \b in\b0  AStates \b then
\par \b0         ButtonTheme \cf2 :=\cf1  tbPushButtonDisabled
\par       \b else\b0  \b if\b0  bsPressed \b in\b0  AStates \b then
\par \b0         ButtonTheme \cf2 :=\cf1  tbPushButtonPressed
\par       \b else\b0  \b if\b0  bsHot \b in\b0  AStates \b then
\par \b0         ButtonTheme \cf2 :=\cf1  tbPushButtonHot
\par       \b else\b0  \b if\b0  bsFocused \b in\b0  AStates \b then
\par \b0         ButtonTheme \cf2 :=\cf1  tbPushButtonDefaulted
\par       \b else
\par \b0         ButtonTheme \cf2 :=\cf1  tbPushButtonNormal\cf2 ;
\par \cf1       ThemeServices\cf2 .\cf1 DrawElement\cf2 (\cf1 TmpCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  ThemeServices\cf2 .\cf1 GetElementDetails\cf2 (\cf1 ButtonTheme\cf2 ),\cf1  TmpRect\cf2 );
\par \cf1     \b end\b0  \b else
\par \b0   \i \{$ENDIF\}
\par \i0     \b begin
\par \b0       ButtonState \cf2 :=\cf1  DFCS_BUTTONPUSH\cf2 ;
\par \cf1       \b if\b0  bsDisabled \b in\b0  AStates \b then
\par \b0         ButtonState \cf2 :=\cf1  ButtonState \b or\b0  DFCS_INACTIVE
\par       \b else\b0  \b if\b0  bsPressed \b in\b0  AStates \b then
\par \b0         ButtonState \cf2 :=\cf1  ButtonState \b or\b0  DFCS_PUSHED
\par       \b else\b0  \b if\b0  bsHot \b in\b0  AStates \b then
\par \b0         ButtonState \cf2 :=\cf1  ButtonState \b or\b0  DFCS_HOT\cf2 ;
\par \cf1       DrawFrameControl\cf2 (\cf1 TmpCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TmpRect\cf2 ,\cf1  DFC_BUTTON\cf2 ,\cf1  ButtonState\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  BM \cf2 <>\cf1  \b nil\b0  \b then
\par \b0       ACanvas\cf2 .\cf1 Draw\cf2 (\cf1 ARect\cf2 .\cf1 Left\cf2 ,\cf1  ARect\cf2 .\cf1 Top\cf2 ,\cf1  BM\cf2 );
\par \cf1   \b finally
\par \b0     BM\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  DrawEdges\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  R\cf2 :\cf1  TRect\cf2 ;\cf1  HighlightColor\cf2 ,
\par \cf1   ShadowColor\cf2 :\cf1  TColor\cf2 ;\cf1  Flags\cf2 :\cf1  Cardinal\cf2 );
\par \cf1\b begin
\par \b0   \b with\b0  Canvas \b do
\par \b0   \b begin
\par \b0     Brush\cf2 .\cf1 Style \cf2 :=\cf1  bsSolid\cf2 ;
\par \cf1     Brush\cf2 .\cf1 Color \cf2 :=\cf1  HighlightColor\cf2 ;
\par \cf1     \b if\b0  Flags \b and\b0  BF_LEFT \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       FillRect\cf2 (\cf1 Rect\cf2 (\cf1 R\cf2 .\cf1 Left\cf2 ,\cf1  R\cf2 .\cf1 Top \cf2 +\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Left \cf2 +\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Bottom\cf2 ));
\par \cf1     \b if\b0  Flags \b and\b0  BF_TOP \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       FillRect\cf2 (\cf1 Rect\cf2 (\cf1 R\cf2 .\cf1 Left\cf2 ,\cf1  R\cf2 .\cf1 Top\cf2 ,\cf1  R\cf2 .\cf1 Right\cf2 ,\cf1  R\cf2 .\cf1 Top \cf2 +\cf1  \cf5 1\cf2 ));
\par \cf1     Brush\cf2 .\cf1 Color \cf2 :=\cf1  ShadowColor\cf2 ;
\par \cf1     \b if\b0  Flags \b and\b0  BF_RIGHT \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       FillRect\cf2 (\cf1 Rect\cf2 (\cf1 R\cf2 .\cf1 Right \cf2 -\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Top \cf2 +\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Right\cf2 ,\cf1  R\cf2 .\cf1 Bottom\cf2 ));
\par \cf1     \b if\b0  Flags \b and\b0  BF_BOTTOM \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       FillRect\cf2 (\cf1 Rect\cf2 (\cf1 R\cf2 .\cf1 Left \cf2 +\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Bottom \cf2 -\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Right \cf2 -\cf1  \cf5 1\cf2 ,\cf1  R\cf2 .\cf1 Bottom\cf2 ));
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  DrawFilledRectangle\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  BackColor\cf2 :\cf1  TColor\cf2 );
\par \cf1\b var
\par \b0   DC\cf2 :\cf1  HDC\cf2 ;
\par \cf1\b begin
\par \b0   DC \cf2 :=\cf1  Canvas\cf2 .\cf1 Handle\cf2 ;
\par \cf1   \b if\b0  BackColor \cf2 <>\cf1  clNone \b then
\par \b0   \b begin
\par \b0     SetBkMode\cf2 (\cf1 DC\cf2 ,\cf1  OPAQUE\cf2 );
\par \cf1     SetBkColor\cf2 (\cf1 DC\cf2 ,\cf1  ColorToRGB\cf2 (\cf1 BackColor\cf2 ));
\par \cf1   \b end\b0\cf2 ;
\par \cf1   FillRect\cf2 (\cf1 DC\cf2 ,\cf1  ARect\cf2 ,\cf1  Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Handle\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  DrawGradientRect\cf2 (\cf1 Canvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   AStartColor\cf2 ,\cf1  AEndColor\cf2 :\cf1  TColor\cf2 ;\cf1  AColorStep\cf2 :\cf1  Integer\cf2 ;\cf1  AHorizontal\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   J\cf2 ,\cf1  OldJ\cf2 ,\cf1  Extent\cf2 ,\cf1  Num\cf2 :\cf1  Integer\cf2 ;
\par \cf1   L\cf2 :\cf1  Byte\cf2 ;
\par \cf1   CS\cf2 ,\cf1  CE\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1   RCnt\cf2 ,\cf1  GCnt\cf2 ,\cf1  BCnt\cf2 :\cf1  Longint\cf2 ;
\par \cf1   RInc\cf2 ,\cf1  GInc\cf2 ,\cf1  BInc\cf2 :\cf1  Longint\cf2 ;
\par \cf1   B\cf2 :\cf1  Boolean\cf2 ;
\par \cf1   R\cf2 :\cf1  TRect\cf2 ;
\par 
\par \cf1   \b function\b0  NumToRGB\cf2 (\cf1 Num\cf2 :\cf1  Cardinal\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1   \b begin
\par \b0     Result\cf2 .\cf1 R \cf2 :=\cf1  Byte\cf2 (\cf1 Num \b shr\b0  \cf5 16\cf2 );
\par \cf1     Result\cf2 .\cf1 G \cf2 :=\cf1  Byte\cf2 (\cf1 Num \b shr\b0  \cf5 8\cf2 );
\par \cf1     Result\cf2 .\cf1 B \cf2 :=\cf1  Byte\cf2 (\cf1 Num\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \b function\b0  RGBToNum\cf2 (\cf1 Col\cf2 :\cf1  TKColorRec\cf2 ):\cf1  Cardinal\cf2 ;
\par \cf1   \b begin
\par \b0     Result \cf2 :=\cf1  Cardinal\cf2 (\cf1 Col\cf2 .\cf1 R\cf2 )\cf1  \b shl\b0  \cf5 16\cf1  \cf2 +\cf1  Cardinal\cf2 (\cf1 Col\cf2 .\cf1 G\cf2 )\cf1  \b shl\b0  \cf5 8\cf1  \cf2 +\cf1  Col\cf2 .\cf1 B\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1\b begin
\par \b0   \b with\b0  Canvas \b do
\par \b0   \b begin
\par \b0     \b if\b0  AHorizontal \b then
\par \b0       Extent \cf2 :=\cf1  ARect\cf2 .\cf1 Right \cf2 -\cf1  ARect\cf2 .\cf1 Left \cf2 -\cf1  \cf5 1
\par \cf1     \b else
\par \b0       Extent \cf2 :=\cf1  ARect\cf2 .\cf1 Bottom \cf2 -\cf1  ARect\cf2 .\cf1 Top \cf2 -\cf1  \cf5 1\cf2 ;
\par \cf1     Num \cf2 :=\cf1  Max\cf2 (\cf1 Extent \b div\b0  AColorStep\cf2 ,\cf1  \cf5 1\cf2 );
\par \cf1     CS \cf2 :=\cf1  NumToRGB\cf2 (\cf1 AStartColor\cf2 );
\par \cf1     CE \cf2 :=\cf1  NumToRGB\cf2 (\cf1 AEndColor\cf2 );
\par \cf1     \cf0\i // colors per pixel
\par \i0\cf1     RInc \cf2 :=\cf1  \cf2 (\cf1 Integer\cf2 (\cf1 CE\cf2 .\cf1 R \cf2 -\cf1  CS\cf2 .\cf1 R\cf2 )\cf1  \b shl\b0  \cf5 16\cf2 )\cf1  \b div\b0  Extent\cf2 ;
\par \cf1     GInc \cf2 :=\cf1  \cf2 (\cf1 Integer\cf2 (\cf1 CE\cf2 .\cf1 G \cf2 -\cf1  CS\cf2 .\cf1 G\cf2 )\cf1  \b shl\b0  \cf5 16\cf2 )\cf1  \b div\b0  Extent\cf2 ;
\par \cf1     Binc \cf2 :=\cf1  \cf2 (\cf1 Integer\cf2 (\cf1 CE\cf2 .\cf1 B \cf2 -\cf1  CS\cf2 .\cf1 B\cf2 )\cf1  \b shl\b0  \cf5 16\cf2 )\cf1  \b div\b0  Extent\cf2 ;
\par \cf1     \cf0\i // start colors
\par \i0\cf1     RCnt \cf2 :=\cf1  CS\cf2 .\cf1 R \b shl\b0  \cf5 16\cf2 ;
\par \cf1     GCnt \cf2 :=\cf1  CS\cf2 .\cf1 G \b shl\b0  \cf5 16\cf2 ;
\par \cf1     BCnt \cf2 :=\cf1  CS\cf2 .\cf1 B \b shl\b0  \cf5 16\cf2 ;
\par \cf1     \cf0\i // drawing bar
\par \i0\cf1     Brush\cf2 .\cf1 Color \cf2 :=\cf1  RGBToNum\cf2 (\cf1 CS\cf2 );
\par \cf1     OldJ \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1     B \cf2 :=\cf1  False\cf2 ;
\par \cf1     \b for\b0  J \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  Extent \b do
\par \b0     \b begin
\par \b0       Inc\cf2 (\cf1 RCnt\cf2 ,\cf1  RInc\cf2 );
\par \cf1       L \cf2 :=\cf1  Byte\cf2 (\cf1 RCnt \b shr\b0  \cf5 16\cf2 );
\par \cf1       \b if\b0  L \cf2 <>\cf1  CS\cf2 .\cf1 R \b then
\par \b0       \b begin
\par \b0         CS\cf2 .\cf1 R \cf2 :=\cf1  L\cf2 ;
\par \cf1         B \cf2 :=\cf1  True\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       Inc\cf2 (\cf1 GCnt\cf2 ,\cf1  GInc\cf2 );
\par \cf1       L \cf2 :=\cf1  Byte\cf2 (\cf1 GCnt \b shr\b0  \cf5 16\cf2 );
\par \cf1       \b if\b0  L \cf2 <>\cf1  CS\cf2 .\cf1 G \b then
\par \b0       \b begin
\par \b0         CS\cf2 .\cf1 G \cf2 :=\cf1  L\cf2 ;
\par \cf1         B \cf2 :=\cf1  True\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       Inc\cf2 (\cf1 BCnt\cf2 ,\cf1  BInc\cf2 );
\par \cf1       L \cf2 :=\cf1  Byte\cf2 (\cf1 BCnt \b shr\b0  \cf5 16\cf2 );
\par \cf1       \b if\b0  L \cf2 <>\cf1  CS\cf2 .\cf1 B \b then
\par \b0       \b begin
\par \b0         CS\cf2 .\cf1 B \cf2 :=\cf1  L\cf2 ;
\par \cf1         B \cf2 :=\cf1  True\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       \b if\b0  B \b and\b0  \cf2 (\cf1 J \b mod\b0  Num \cf2 =\cf1  \cf5 0\cf2 )\cf1  \b then
\par \b0       \b begin
\par \b0         \b if\b0  AHorizontal \b then
\par \b0           R \cf2 :=\cf1  Rect\cf2 (\cf1 ARect\cf2 .\cf1 Left \cf2 +\cf1  OldJ\cf2 ,\cf1  ARect\cf2 .\cf1 Top\cf2 ,\cf1  ARect\cf2 .\cf1 Left \cf2 +\cf1  J\cf2 ,\cf1  ARect\cf2 .\cf1 Bottom\cf2 )
\par \cf1         \b else
\par \b0           R \cf2 :=\cf1  Rect\cf2 (\cf1 ARect\cf2 .\cf1 Left\cf2 ,\cf1  ARect\cf2 .\cf1 Top \cf2 +\cf1  OldJ\cf2 ,\cf1  ARect\cf2 .\cf1 Right\cf2 ,\cf1  ARect\cf2 .\cf1 Top \cf2 +\cf1  J\cf2 );
\par \cf1         FillRect\cf2 (\cf1 R\cf2 );
\par \cf1         Brush\cf2 .\cf1 Color \cf2 :=\cf1  RGBToNum\cf2 (\cf1 CS\cf2 );
\par \cf1         OldJ \cf2 :=\cf1  J\cf2 ;
\par \cf1         B \cf2 :=\cf1  False\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  ExcludeShapeFromBaseRect\cf2 (\cf1\b var\b0  BaseRect\cf2 :\cf1  TRect\cf2 ;\cf1  ShapeWidth\cf2 ,\cf1  ShapeHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1   HAlign\cf2 :\cf1  TKHAlign\cf2 ;\cf1  VAlign\cf2 :\cf1  TKVAlign\cf2 ;\cf1  HPadding\cf2 ,\cf1  VPadding\cf2 :\cf1  Integer\cf2 ;
\par \cf1   StretchMode\cf2 :\cf1  TKStretchMode\cf2 ;\cf1  \b out\b0  Bounds\cf2 ,\cf1  Interior\cf2 :\cf1  TRect\cf2 );
\par \cf1\b var
\par \b0   MaxHeight\cf2 ,\cf1  MaxWidth\cf2 ,\cf1  StretchHeight\cf2 ,\cf1  StretchWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1   RatioX\cf2 ,\cf1  RatioY\cf2 :\cf1  Single\cf2 ;
\par \cf1\b begin
\par \b0   MaxHeight \cf2 :=\cf1  BaseRect\cf2 .\cf1 Bottom \cf2 -\cf1  BaseRect\cf2 .\cf1 Top \cf2 -\cf1  \cf5 2\cf1  \cf2 *\cf1  VPadding\cf2 ;
\par \cf1   MaxWidth \cf2 :=\cf1  BaseRect\cf2 .\cf1 Right \cf2 -\cf1  BaseRect\cf2 .\cf1 Left \cf2 -\cf1  HPadding\cf2 ;
\par \cf1   \b if\b0  \cf2 ((\cf1 MaxWidth \cf2 <>\cf1  ShapeWidth\cf2 )\cf1  \b or\b0  \cf2 (\cf1 MaxHeight \cf2 <>\cf1  ShapeHeight\cf2 ))\cf1  \b and\b0  \cf2 (
\par \cf1     \cf2 (\cf1 StretchMode \cf2 =\cf1  stmZoom\cf2 )\cf1  \b or
\par \b0     \cf2 (\cf1 StretchMode \cf2 =\cf1  stmZoomInOnly\cf2 )\cf1  \b and\b0  \cf2 (\cf1 MaxWidth \cf2 >=\cf1  ShapeWidth\cf2 )\cf1  \b and\b0  \cf2 (\cf1 MaxHeight \cf2 >=\cf1  ShapeHeight\cf2 )\cf1  \b or
\par \b0     \cf2 (\cf1 StretchMode \cf2 =\cf1  stmZoomOutOnly\cf2 )\cf1  \b and\b0  \cf2 ((\cf1 MaxWidth \cf2 <\cf1  ShapeWidth\cf2 )\cf1  \b or\b0  \cf2 (\cf1 MaxHeight \cf2 <\cf1  ShapeHeight\cf2 ))
\par \cf1     \cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0     RatioX \cf2 :=\cf1  MaxWidth \cf2 /\cf1  ShapeWidth\cf2 ;
\par \cf1     RatioY \cf2 :=\cf1  MaxHeight \cf2 /\cf1  ShapeHeight\cf2 ;
\par \cf1     \b if\b0  RatioY \cf2 >=\cf1  RatioX \b then
\par \b0     \b begin
\par \b0       StretchWidth \cf2 :=\cf1  MaxWidth\cf2 ;
\par \cf1       StretchHeight \cf2 :=\cf1  ShapeHeight \cf2 *\cf1  StretchWidth \b div\b0  ShapeWidth\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0     \b begin
\par \b0       StretchHeight \cf2 :=\cf1  MaxHeight\cf2 ;
\par \cf1       StretchWidth \cf2 :=\cf1  ShapeWidth \cf2 *\cf1  StretchHeight \b div\b0  ShapeHeight\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0  \b else
\par \b0   \b begin
\par \b0     StretchHeight \cf2 :=\cf1  ShapeHeight\cf2 ;
\par \cf1     StretchWidth \cf2 :=\cf1  ShapeWidth\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   Bounds \cf2 :=\cf1  BaseRect\cf2 ;
\par \cf1   Interior \cf2 :=\cf1  BaseRect\cf2 ;
\par \cf1   \b case\b0  HAlign \b of
\par \b0     halCenter\cf2 :
\par \cf1     \b begin
\par \b0       BaseRect\cf2 .\cf1 Right \cf2 :=\cf1  BaseRect\cf2 .\cf1 Left\cf2 ;\cf1  \cf0\i // BaseRect empty, no space for next item!
\par \i0\cf1       \cf0\i // Bounds remains unchanged
\par \i0\cf1       Inc\cf2 (\cf1 Interior\cf2 .\cf1 Left\cf2 ,\cf1  HPadding \cf2 +\cf1  \cf2 (\cf1 MaxWidth \cf2 -\cf1  StretchWidth\cf2 )\cf1  \b div\b0  \cf5 2\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     halRight\cf2 :
\par \cf1     \b begin
\par \b0       Dec\cf2 (\cf1 BaseRect\cf2 .\cf1 Right\cf2 ,\cf1  StretchWidth \cf2 +\cf1  HPadding\cf2 );
\par \cf1       Bounds\cf2 .\cf1 Left \cf2 :=\cf1  BaseRect\cf2 .\cf1 Right\cf2 ;
\par \cf1       \cf0\i // Bounds.Right remains unchanged
\par \i0\cf1       Interior\cf2 .\cf1 Left \cf2 :=\cf1  BaseRect\cf2 .\cf1 Right\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b else
\par \b0     Inc\cf2 (\cf1 BaseRect\cf2 .\cf1 Left\cf2 ,\cf1  StretchWidth \cf2 +\cf1  HPadding\cf2 );
\par \cf1     \cf0\i // Bounds.Left remains unchanged
\par \i0\cf1     Bounds\cf2 .\cf1 Right \cf2 :=\cf1  BaseRect\cf2 .\cf1 Left\cf2 ;
\par \cf1     Inc\cf2 (\cf1 Interior\cf2 .\cf1 Left\cf2 ,\cf1  HPadding\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1   Interior\cf2 .\cf1 Right \cf2 :=\cf1  Interior\cf2 .\cf1 Left \cf2 +\cf1  StretchWidth\cf2 ;
\par \cf1   \b case\b0  VAlign \b of
\par \b0     valCenter\cf2 :\cf1  Inc\cf2 (\cf1 Interior\cf2 .\cf1 Top\cf2 ,\cf1  VPadding \cf2 +\cf1  \cf2 (\cf1 MaxHeight \cf2 -\cf1  StretchHeight\cf2 )\cf1  \b div\b0  \cf5 2\cf2 );
\par \cf1     valBottom\cf2 :\cf1  Interior\cf2 .\cf1 Top \cf2 :=\cf1  BaseRect\cf2 .\cf1 Bottom \cf2 -\cf1  VPadding \cf2 -\cf1  StretchHeight\cf2 ;
\par \cf1   \b else
\par \b0     Inc\cf2 (\cf1 Interior\cf2 .\cf1 Top\cf2 ,\cf1  VPadding\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1   Interior\cf2 .\cf1 Bottom \cf2 :=\cf1  Interior\cf2 .\cf1 Top \cf2 +\cf1  StretchHeight\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ExtSelectClipRect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  Mode\cf2 :\cf1  Integer\cf2 ;\cf1  \b var\b0  PrevRgn\cf2 :\cf1  HRGN\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b var
\par \b0   TmpRgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   TmpRgn \cf2 :=\cf1  CreateEmptyRgn\cf2 ;
\par \cf1   \b try
\par \b0     Result \cf2 :=\cf1  ExtSelectClipRectEx\cf2 (\cf1 DC\cf2 ,\cf1  ARect\cf2 ,\cf1  Mode\cf2 ,\cf1  TmpRgn\cf2 ,\cf1  PrevRgn\cf2 )
\par \cf1   \b finally
\par \b0     DeleteObject\cf2 (\cf1 TmpRgn\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ExtSelectClipRectEx\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  Mode\cf2 :\cf1  Integer\cf2 ;\cf1  CurRgn\cf2 ,\cf1  PrevRgn\cf2 :\cf1  HRGN\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b var
\par \b0   RectRgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   RectRgn \cf2 :=\cf1  CreateRectRgnIndirect\cf2 (\cf1 ARect\cf2 );
\par \cf1   \b try
\par \b0     Result \cf2 :=\cf1  CombineRgn\cf2 (\cf1 CurRgn\cf2 ,\cf1  PrevRgn\cf2 ,\cf1  RectRgn\cf2 ,\cf1  Mode\cf2 )\cf1  \cf2 <>\cf1  NULLREGION\cf2 ;
\par \cf1     \b if\b0  Result \b then
\par \b0       SelectClipRgn\cf2 (\cf1 DC\cf2 ,\cf1  CurRgn\cf2 );
\par \cf1   \b finally
\par \b0     DeleteObject\cf2 (\cf1 RectRgn\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  FillAroundRect\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  Boundary\cf2 ,\cf1  Interior\cf2 :\cf1  TRect\cf2 ;\cf1  BackColor\cf2 :\cf1  TColor\cf2 );
\par \cf1\b var
\par \b0   R\cf2 :\cf1  TRect\cf2 ;
\par \cf1\b begin
\par \b0   R \cf2 :=\cf1  Rect\cf2 (\cf1 Boundary\cf2 .\cf1 Left\cf2 ,\cf1  Boundary\cf2 .\cf1 Top\cf2 ,\cf1  Boundary\cf2 .\cf1 Right\cf2 ,\cf1  Interior\cf2 .\cf1 Top\cf2 );
\par \cf1   \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 R\cf2 )\cf1  \b then\b0  DrawFilledRectangle\cf2 (\cf1 ACanvas\cf2 ,\cf1  R\cf2 ,\cf1  BackColor\cf2 );
\par \cf1   R \cf2 :=\cf1  Rect\cf2 (\cf1 Boundary\cf2 .\cf1 Left\cf2 ,\cf1  Interior\cf2 .\cf1 Top\cf2 ,\cf1  Interior\cf2 .\cf1 Left\cf2 ,\cf1  Interior\cf2 .\cf1 Bottom\cf2 );
\par \cf1   \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 R\cf2 )\cf1  \b then\b0  DrawFilledRectangle\cf2 (\cf1 ACanvas\cf2 ,\cf1  R\cf2 ,\cf1  BackColor\cf2 );
\par \cf1   R \cf2 :=\cf1  Rect\cf2 (\cf1 Interior\cf2 .\cf1 Right\cf2 ,\cf1  Interior\cf2 .\cf1 Top\cf2 ,\cf1  Boundary\cf2 .\cf1 Right\cf2 ,\cf1  Interior\cf2 .\cf1 Bottom\cf2 );
\par \cf1   \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 R\cf2 )\cf1  \b then\b0  DrawFilledRectangle\cf2 (\cf1 ACanvas\cf2 ,\cf1  R\cf2 ,\cf1  BackColor\cf2 );
\par \cf1   R \cf2 :=\cf1  Rect\cf2 (\cf1 Boundary\cf2 .\cf1 Left\cf2 ,\cf1  Interior\cf2 .\cf1 Bottom\cf2 ,\cf1  Boundary\cf2 .\cf1 Right\cf2 ,\cf1  Boundary\cf2 .\cf1 Bottom\cf2 );
\par \cf1   \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 R\cf2 )\cf1  \b then\b0  DrawFilledRectangle\cf2 (\cf1 ACanvas\cf2 ,\cf1  R\cf2 ,\cf1  BackColor\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  GetFontHeight\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b var
\par \b0   TM\cf2 :\cf1  TTextMetric\cf2 ;
\par \cf1\b begin
\par \b0   FillChar\cf2 (\cf1 TM\cf2 ,\cf1  SizeOf\cf2 (\cf1 TTextMetric\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1   GetTextMetrics\cf2 (\cf1 DC\cf2 ,\cf1  TM\cf2 );
\par \cf1   Result \cf2 :=\cf1  TM\cf2 .\cf1 tmHeight\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  GetFontAscent\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b var
\par \b0   TM\cf2 :\cf1  TTextMetric\cf2 ;
\par \cf1\b begin
\par \b0   FillChar\cf2 (\cf1 TM\cf2 ,\cf1  SizeOf\cf2 (\cf1 TTextMetric\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1   GetTextMetrics\cf2 (\cf1 DC\cf2 ,\cf1  TM\cf2 );
\par \cf1   Result \cf2 :=\cf1  TM\cf2 .\cf1 tmAscent\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  GetFontDescent\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b var
\par \b0   TM\cf2 :\cf1  TTextMetric\cf2 ;
\par \cf1\b begin
\par \b0   FillChar\cf2 (\cf1 TM\cf2 ,\cf1  SizeOf\cf2 (\cf1 TTextMetric\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1   GetTextMetrics\cf2 (\cf1 DC\cf2 ,\cf1  TM\cf2 );
\par \cf1   Result \cf2 :=\cf1  TM\cf2 .\cf1 tmDescent\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  GDICheck\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  Value \cf2 =\cf1  \cf5 0\cf1  \b then
\par \b0     \b raise\b0  EOutOfResources\cf2 .\cf1 Create\cf2 (\cf1 sGDIError\cf2 );
\par \cf1   Result \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  HorizontalShapePosition\cf2 (\cf1 AAlignment\cf2 :\cf1  TKHAlign\cf2 ;\cf1  \b const\b0  ABoundary\cf2 :\cf1  TRect\cf2 ;\cf1  \b const\b0  AShapeSize\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  AAlignment \b of
\par \b0     halCenter\cf2 :\cf1  Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Left \cf2 +\cf1  \cf2 (\cf1 ABoundary\cf2 .\cf1 Right \cf2 -\cf1  ABoundary\cf2 .\cf1 Left \cf2 -\cf1  AShapeSize\cf2 .\cf1 X\cf2 )\cf1  \b div\b0  \cf5 2\cf2 ;
\par \cf1     halRight\cf2 :\cf1  Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Right \cf2 -\cf1  AShapeSize\cf2 .\cf1 X\cf2 ;
\par \cf1   \b else
\par \b0     Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Left\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  ImageByType\cf2 (\cf1\b const\b0  Header\cf2 :\cf1  TKImageHeaderString\cf2 ):\cf1  TGraphic\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  Pos\cf2 (\cf4 'BM'\cf2 ,\cf1  \i \{$IFDEF COMPILER12_UP\}\i0\b string\b0\i \{$ENDIF\}\i0\cf2 (\cf1 Header\cf2 ))\cf1  \cf2 =\cf1  \cf5 1\cf1  \b then
\par \b0     Result \cf2 :=\cf1  TBitmap\cf2 .\cf1 Create
\par \i \{$IFDEF USE_PNG_SUPPORT \}
\par \i0   \b else\b0  \b if\b0  \cf2 (\cf1 Pos\cf2 (\cf3\ul #$89\ul0\cf4 'PNG'\cf2 ,\cf1  \i \{$IFDEF COMPILER12_UP\}\i0\b string\b0\i \{$ENDIF\}\i0\cf2 (\cf1 Header\cf2 ))\cf1  \cf2 =\cf1  \cf5 1\cf2 )\cf1  \b or
\par \b0     \cf2 (\cf1 Pos\cf2 (\cf3\ul #$8A\ul0\cf4 'MNG'\cf2 ,\cf1  \i \{$IFDEF COMPILER12_UP\}\i0\b string\b0\i \{$ENDIF\}\i0\cf2 (\cf1 Header\cf2 ))\cf1  \cf2 =\cf1  \cf5 1\cf2 )\cf1  \b then
\par \b0     Result \cf2 :=\cf1  TKPngImage\cf2 .\cf1 Create
\par \i \{$ENDIF \}
\par \i0   \b else\b0  \b if\b0  \cf2 (\cf1 Pos\cf2 (\cf3\ul #$FF#$D8\ul0\cf2 ,\cf1  \i \{$IFDEF COMPILER12_UP\}\i0\b string\b0\i \{$ENDIF\}\i0\cf2 (\cf1 Header\cf2 ))\cf1  \cf2 =\cf1  \cf5 1\cf2 )\cf1  \b then
\par \b0     Result \cf2 :=\cf1  TJPegImage\cf2 .\cf1 Create
\par   \b else\b0  \b if\b0  \cf2 (\cf1 Pos\cf2 (\cf3\ul #$00#$00\ul0\cf2 ,\cf1  \i \{$IFDEF COMPILER12_UP\}\i0\b string\b0\i \{$ENDIF\}\i0\cf2 (\cf1 Header\cf2 ))\cf1  \cf2 =\cf1  \cf5 1\cf2 )\cf1  \b then
\par \b0     Result \cf2 :=\cf1  TIcon\cf2 .\cf1 Create
\par   \b else
\par \b0     Result \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  IntersectClipRectIndirect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   \b with\b0  ARect \b do
\par \b0     Result \cf2 :=\cf1  IntersectClipRect\cf2 (\cf1 DC\cf2 ,\cf1  Left\cf2 ,\cf1  Top\cf2 ,\cf1  Right\cf2 ,\cf1  Bottom\cf2 )\cf1  \cf2 <>\cf1  NULLREGION\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  IsBrightColor\cf2 (\cf1 Color\cf2 :\cf1  TColor\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  CalcLightness\cf2 (\cf1 Color\cf2 )\cf1  \cf2 >\cf1  \cf6 0.5\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  MakeColorRec\cf2 (\cf1 R\cf2 ,\cf1  G\cf2 ,\cf1  B\cf2 ,\cf1  A\cf2 :\cf1  Byte\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   Result\cf2 .\cf1 R \cf2 :=\cf1  R\cf2 ;
\par \cf1   Result\cf2 .\cf1 G \cf2 :=\cf1  G\cf2 ;
\par \cf1   Result\cf2 .\cf1 B \cf2 :=\cf1  B\cf2 ;
\par \cf1   Result\cf2 .\cf1 A \cf2 :=\cf1  A\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  MakeColorRec\cf2 (\cf1 Value\cf2 :\cf1  LongWord\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   Result\cf2 .\cf1 Value \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  LoadCustomCursor\cf2 (\cf1 Cursor\cf2 :\cf1  TCursor\cf2 ;\cf1  \b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 );
\par \cf1\b begin
\par \b0   Screen\cf2 .\cf1 Cursors\cf2 [\cf1 Cursor\cf2 ]\cf1  \cf2 :=
\par \cf1   \i \{$IFDEF FPC\}
\par \i0     LoadCursorFromLazarusResource\cf2 (\cf1 ResName\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     LoadCursor\cf2 (\cf1 HInstance\cf2 ,\cf1  PChar\cf2 (\cf1 ResName\cf2 ));
\par \cf1   \i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  LoadGraphicFromResource\cf2 (\cf1 Graphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  \b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 ;\cf1  ResType\cf2 :\cf1  PChar\cf2 );
\par \cf1\i \{$IFNDEF FPC\}
\par \i0\b var
\par \b0   Stream\cf2 :\cf1  TResourceStream\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0   \b if\b0  Graphic \cf2 <>\cf1  \b nil\b0  \b then
\par \b0   \b try
\par \b0   \i \{$IFDEF FPC\}
\par \i0     Graphic\cf2 .\cf1 LoadFromLazarusResource\cf2 (\cf1 ResName\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     Stream \cf2 :=\cf1  TResourceStream\cf2 .\cf1 Create\cf2 (\cf1 HInstance\cf2 ,\cf1  ResName\cf2 ,\cf1  ResType\cf2 );
\par \cf1     \b try
\par \b0       Graphic\cf2 .\cf1 LoadFromStream\cf2 (\cf1 Stream\cf2 );
\par \cf1     \b finally
\par \b0       Stream\cf2 .\cf1 Free\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0   \b except
\par \b0     Error\cf2 (\cf1 sErrGraphicsLoadFromResource\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  PixelFormatFromBpp\cf2 (\cf1 Bpp\cf2 :\cf1  Cardinal\cf2 ):\cf1  TPixelFormat\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  Bpp \b of
\par \b0     \cf5 1\cf2 :\cf1  Result \cf2 :=\cf1  pf1bit\cf2 ;
\par \cf1     \cf5 2\cf2 ..\cf5 4\cf2 :\cf1  Result \cf2 :=\cf1  pf4bit\cf2 ;
\par \cf1     \cf5 5\cf2 ..\cf5 8\cf2 :\cf1  Result \cf2 :=\cf1  pf8bit\cf2 ;
\par \cf1     \cf5 9\cf2 ..\cf5 16\cf2 :\cf1  Result \cf2 :=\cf1  pf16bit\cf2 ;
\par \cf1   \b else
\par \b0     Result \cf2 :=\cf1  pf32bit\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  RectInRegion\cf2 (\cf1 Rgn\cf2 :\cf1  HRGN\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ):\cf1  Boolean\cf2 ;
\par \cf1\i \{$IFDEF FPC\}
\par \i0\b var
\par \b0   RectRgn\cf2 ,\cf1  TmpRgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0\i \{$IFDEF FPC\}
\par \i0   RectRgn \cf2 :=\cf1  CreateRectRgnIndirect\cf2 (\cf1 ARect\cf2 );
\par \cf1   \b try
\par \b0     TmpRgn \cf2 :=\cf1  CreateEmptyRgn\cf2 ;
\par \cf1     \b try
\par \b0       Result \cf2 :=\cf1  CombineRgn\cf2 (\cf1 TmpRgn\cf2 ,\cf1  RectRgn\cf2 ,\cf1  Rgn\cf2 ,\cf1  RGN_AND\cf2 )\cf1  \cf2 <>\cf1  NULLREGION\cf2 ;
\par \cf1     \b finally
\par \b0       DeleteObject\cf2 (\cf1 TmpRgn\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     DeleteObject\cf2 (\cf1 RectRgn\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\i \{$ELSE\}
\par \i0   Result \cf2 :=\cf1  Windows\cf2 .\cf1 RectInRegion\cf2 (\cf1 Rgn\cf2 ,\cf1  ARect\cf2 );
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  RgnCreateAndGet\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ):\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  CreateEmptyRgn\cf2 ;
\par \cf1   GetClipRgn\cf2 (\cf1 DC\cf2 ,\cf1  Result\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  RgnSelectAndDelete\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  Rgn\cf2 :\cf1  HRGN\cf2 );
\par \cf1\b begin
\par \b0   SelectClipRgn\cf2 (\cf1 DC\cf2 ,\cf1  Rgn\cf2 );
\par \cf1   DeleteObject\cf2 (\cf1 Rgn\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  RoundRectangle\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AXRadius\cf2 ,\cf1  AYRadius\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0\i \{$IF DEFINED(COMPILER12_UP) OR DEFINED(FPC)\}
\par \i0   ACanvas\cf2 .\cf1 RoundRect\cf2 (\cf1 ARect\cf2 ,\cf1  AXRadius\cf2 ,\cf1  AYRadius\cf2 )
\par \cf1\i \{$ELSE\}
\par \i0   ACanvas\cf2 .\cf1 RoundRect\cf2 (\cf1 ARect\cf2 .\cf1 Left\cf2 ,\cf1  ARect\cf2 .\cf1 Top\cf2 ,\cf1  ARect\cf2 .\cf1 Right\cf2 ,\cf1  ARect\cf2 .\cf1 Bottom\cf2 ,\cf1  AXRadius\cf2 ,\cf1  AYRadius\cf2 )
\par \cf1\i \{$IFEND\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  SafeStretchDraw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AGraphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  ABackColor\cf2 :\cf1  TColor\cf2 );
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0\b var
\par \b0   BM\cf2 :\cf1  TBitmap\cf2 ;
\par \cf1   W\cf2 ,\cf1  H\cf2 ,\cf1  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 :\cf1  Integer\cf2 ;
\par \cf1   R\cf2 :\cf1  TRect\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0\i \{$IFDEF USE_WINAPI\}
\par \i0   \b if\b0  AGraphic\cf2 .\cf1 Transparent \b then
\par \b0   \b begin
\par \b0     \cf0\i // WinAPI StretchBlt function does not read properly from screen buffer
\par \i0\cf1     \cf0\i // so we have to append double buffering
\par \i0\cf1     CanvasGetScale\cf2 (\cf1 ACanvas\cf2 ,\cf1  MulX\cf2 ,\cf1  MulY\cf2 ,\cf1  DivX\cf2 ,\cf1  DivY\cf2 );
\par \cf1     W \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Right \cf2 -\cf1  ARect\cf2 .\cf1 Left\cf2 ,\cf1  MulX\cf2 ,\cf1  DivX\cf2 );
\par \cf1     H \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Bottom \cf2 -\cf1  ARect\cf2 .\cf1 Top\cf2 ,\cf1  MulY\cf2 ,\cf1  DivY\cf2 );
\par \cf1     BM \cf2 :=\cf1  TBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1     \b try
\par \b0       BM\cf2 .\cf1 Width \cf2 :=\cf1  W\cf2 ;
\par \cf1       BM\cf2 .\cf1 Height \cf2 :=\cf1  H\cf2 ;
\par \cf1       BM\cf2 .\cf1 Canvas\cf2 .\cf1 Brush \cf2 :=\cf1  ACanvas\cf2 .\cf1 Brush\cf2 ;
\par \cf1       R \cf2 :=\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  W\cf2 ,\cf1  H\cf2 );
\par \cf1       DrawFilledRectangle\cf2 (\cf1 BM\cf2 .\cf1 Canvas\cf2 ,\cf1  R\cf2 ,\cf1  ABackColor\cf2 );
\par \cf1       BM\cf2 .\cf1 Canvas\cf2 .\cf1 StretchDraw\cf2 (\cf1 R\cf2 ,\cf1  AGraphic\cf2 );
\par \cf1       ACanvas\cf2 .\cf1 StretchDraw\cf2 (\cf1 ARect\cf2 ,\cf1  BM\cf2 );
\par \cf1     \b finally
\par \b0       BM\cf2 .\cf1 Free\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0  \b else
\par \b0\i \{$ENDIF\}
\par \i0     ACanvas\cf2 .\cf1 StretchDraw\cf2 (\cf1 ARect\cf2 ,\cf1  AGraphic\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  SelectClipRect\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b var
\par \b0   Rgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   Rgn \cf2 :=\cf1  CreateRectRgnIndirect\cf2 (\cf1 ARect\cf2 );
\par \cf1   \b try
\par \b0     SelectClipRgn\cf2 (\cf1 DC\cf2 ,\cf1  Rgn\cf2 );
\par \cf1   \b finally
\par \b0     DeleteObject\cf2 (\cf1 Rgn\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  StretchBitmap\cf2 (\cf1 DestDC\cf2 :\cf1  HDC\cf2 ;\cf1  DestRect\cf2 :\cf1  TRect\cf2 ;\cf1  SrcDC\cf2 :\cf1  HDC\cf2 ;\cf1  SrcRect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b begin
\par \b0   \i \{$IFDEF USE_WINAPI\}\i0 Windows\cf2 .\cf1\i \{$ENDIF\}\i0 StretchBlt\cf2 (\cf1 DestDC\cf2 ,
\par \cf1     DestRect\cf2 .\cf1 Left\cf2 ,\cf1  DestRect\cf2 .\cf1 Top\cf2 ,\cf1  DestRect\cf2 .\cf1 Right \cf2 -\cf1  DestRect\cf2 .\cf1 Left\cf2 ,\cf1  DestRect\cf2 .\cf1 Bottom \cf2 -\cf1  DestRect\cf2 .\cf1 Top\cf2 ,
\par \cf1     SrcDC\cf2 ,\cf1  SrcRect\cf2 .\cf1 Left\cf2 ,\cf1  SrcRect\cf2 .\cf1 Top\cf2 ,\cf1  SrcRect\cf2 .\cf1 Right \cf2 -\cf1  SrcRect\cf2 .\cf1 Left\cf2 ,\cf1  SrcRect\cf2 .\cf1 Bottom \cf2 -\cf1  SrcRect\cf2 .\cf1 Top\cf2 ,
\par \cf1     SRCCOPY\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  SwapBR\cf2 (\cf1\b var\b0  ColorRec\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1\b var
\par \b0   Tmp\cf2 :\cf1  Byte\cf2 ;
\par \cf1\b begin
\par \b0   Tmp \cf2 :=\cf1  ColorRec\cf2 .\cf1 R\cf2 ;
\par \cf1   ColorRec\cf2 .\cf1 R \cf2 :=\cf1  ColorRec\cf2 .\cf1 B\cf2 ;
\par \cf1   ColorRec\cf2 .\cf1 B \cf2 :=\cf1  Tmp\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  SwitchRGBToBGR\cf2 (\cf1 Value\cf2 :\cf1  TColor\cf2 ):\cf1  TColor\cf2 ;
\par \cf1\b var
\par \b0   B\cf2 :\cf1  Byte\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  Value\cf2 ;
\par \cf1   B \cf2 :=\cf1  PKColorRec\cf2 (@\cf1 Value\cf2 ).\cf1 B\cf2 ;
\par \cf1   PKColorRec\cf2 (@\cf1 Result\cf2 ).\cf1 B \cf2 :=\cf1  PKColorRec\cf2 (@\cf1 Result\cf2 ).\cf1 R\cf2 ;
\par \cf1   PKColorRec\cf2 (@\cf1 Result\cf2 ).\cf1 R \cf2 :=\cf1  B\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TranslateRectToDevice\cf2 (\cf1 DC\cf2 :\cf1  HDC\cf2 ;\cf1  \b var\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b var
\par \b0   P\cf2 :\cf1  TPoint\cf2 ;
\par \cf1\i \{$IFDEF USE_DC_MAPPING\}
\par \i0  \i \{$IFNDEF LCLQT\}
\par \i0   WindowExt\cf2 ,\cf1  ViewportExt\cf2 :\cf1  TSize\cf2 ;
\par \cf1  \i \{$ENDIF\}
\par \{$ENDIF\}
\par \i0\b begin
\par \b0\i \{$IFDEF USE_DC_MAPPING\}
\par \i0   \i \{$IFNDEF LCLQT\}
\par \i0   \b if\b0  \b not\b0  \cf2 (\cf1 GetMapMode\cf2 (\cf1 DC\cf2 )\cf1  \b in\b0  \cf2 [\cf5 0\cf2 ,\cf1  MM_TEXT\cf2 ])\cf1  \b and
\par \b0     Boolean\cf2 (\cf1 GetWindowExtEx\cf2 (\cf1 DC\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 WindowExt\cf2 ))\cf1  \b and
\par \b0     Boolean\cf2 (\cf1 GetViewportExtEx\cf2 (\cf1 DC\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 ViewportExt\cf2 ))\cf1  \b then
\par \b0   \b begin
\par \b0     ARect\cf2 .\cf1 Left \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Left\cf2 ,\cf1  ViewportExt\cf2 .\cf1 cx\cf2 ,\cf1  WindowExt\cf2 .\cf1 cx\cf2 );
\par \cf1     ARect\cf2 .\cf1 Right \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Right\cf2 ,\cf1  ViewportExt\cf2 .\cf1 cx\cf2 ,\cf1  WindowExt\cf2 .\cf1 cx\cf2 );
\par \cf1     ARect\cf2 .\cf1 Top \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Top\cf2 ,\cf1  ViewportExt\cf2 .\cf1 cy\cf2 ,\cf1  WindowExt\cf2 .\cf1 cy\cf2 );
\par \cf1     ARect\cf2 .\cf1 Bottom \cf2 :=\cf1  MulDiv\cf2 (\cf1 ARect\cf2 .\cf1 Bottom\cf2 ,\cf1  ViewportExt\cf2 .\cf1 cy\cf2 ,\cf1  WindowExt\cf2 .\cf1 cy\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1   \b if\b0  Boolean\cf2 (\cf1 GetViewPortOrgEx\cf2 (\cf1 DC\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 P\cf2 ))\cf1  \b then
\par \b0     KFunctions\cf2 .\cf1 OffsetRect\cf2 (\cf1 ARect\cf2 ,\cf1  P\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \{$ENDIF\}
\par \i0   \b if\b0  Boolean\cf2 (\cf1 GetWindowOrgEx\cf2 (\cf1 DC\cf2 ,\cf1  \i \{$IFDEF FPC\}\i0\cf2 @\cf1\i \{$ENDIF\}\i0 P\cf2 ))\cf1  \b then
\par \b0     KFunctions\cf2 .\cf1 OffsetRect\cf2 (\cf1 ARect\cf2 ,\cf1  \cf2 -\cf1 P\cf2 .\cf1 X\cf2 ,\cf1  \cf2 -\cf1 P\cf2 .\cf1 Y\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  VerticalShapePosition\cf2 (\cf1 AAlignment\cf2 :\cf1  TKVAlign\cf2 ;\cf1  \b const\b0  ABoundary\cf2 :\cf1  TRect\cf2 ;\cf1  \b const\b0  AShapeSize\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  AAlignment \b of
\par \b0     valCenter\cf2 :\cf1  Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Top \cf2 +\cf1  \cf2 (\cf1 ABoundary\cf2 .\cf1 Bottom \cf2 -\cf1  ABoundary\cf2 .\cf1 Top \cf2 -\cf1  AShapeSize\cf2 .\cf1 Y\cf2 )\cf1  \b div\b0  \cf5 2\cf2 ;
\par \cf1     valBottom\cf2 :\cf1  Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Bottom \cf2 -\cf1  AShapeSize\cf2 .\cf1 Y\cf2 ;
\par \cf1   \b else
\par \b0     Result \cf2 :=\cf1  ABoundary\cf2 .\cf1 Top\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKGraphic \}
\par 
\par \i0\cf1\b constructor\b0  TKGraphic\cf2 .\cf1 Create\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FDescription \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1   FFileFilter \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKAlphaBitmap \}
\par 
\par \i0\cf1\b constructor\b0  TKAlphaBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FCanvas \cf2 :=\cf1  TCanvas\cf2 .\cf1 Create\cf2 ;
\par \cf1   FCanvas\cf2 .\cf1 Handle \cf2 :=\cf1  CreateCompatibleDC\cf2 (\cf5 0\cf2 );
\par \cf1   FUpdateLock \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FAutoMirror \cf2 :=\cf1  True\cf2 ;
\par \cf1   FDescription \cf2 :=\cf1  \cf4 'KControls alpha bitmap'\cf2 ;
\par \cf1   FDirectCopy \cf2 :=\cf1  False\cf2 ;
\par \cf1   FFileFilter \cf2 :=\cf1  \cf4 '*.bma;*.bmp;*.png;*.jpg'\cf2 ;
\par \cf1   FHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1\i \{$IFNDEF USE_WINAPI\}
\par \i0   FImage \cf2 :=\cf1  TLazIntfImage\cf2 .\cf1 Create\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1\i \{$ENDIF\}
\par \i0   FHeight \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FOldBitmap \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FPixels \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1   FPixelsChanged \cf2 :=\cf1  False\cf2 ;
\par \cf1   FWidth \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b constructor\b0  TKAlphaBitmap\cf2 .\cf1 CreateFromRes\cf2 (\cf1\b const\b0  ResName\cf2 :\cf1  \b string\b0\cf2 );
\par \cf1\b var
\par \b0   Stream\cf2 :\cf1  \i \{$IFDEF FPC\}\i0 TLazarusResourceStream\i \{$ELSE\}\i0 TResourceStream\i \{$ENDIF\}\i0\cf2 ;
\par \cf1\b begin
\par \b0   Create\cf2 ;
\par \cf1   \b try
\par \b0   \i \{$IFDEF FPC\}
\par \i0     Stream \cf2 :=\cf1  TLazarusResourceStream\cf2 .\cf1 Create\cf2 (\cf1 LowerCase\cf2 (\cf1 ResName\cf2 ),\cf1  \cf4 'BMP'\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     Stream \cf2 :=\cf1  TResourceStream\cf2 .\cf1 Create\cf2 (\cf1 HInstance\cf2 ,\cf1  ResName\cf2 ,\cf1  RT_RCDATA\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \i0     \b try
\par \b0       LoadFromStream\cf2 (\cf1 Stream\cf2 );
\par \cf1     \b finally
\par \b0       Stream\cf2 .\cf1 Free\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b except
\par \b0     Error\cf2 (\cf1 sErrGraphicsLoadFromResource\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b destructor\b0  TKAlphaBitmap\cf2 .\cf1 Destroy\cf2 ;
\par \cf1\b var
\par \b0   DC\cf2 :\cf1  HDC\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   SetSize\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1\i \{$IFNDEF USE_WINAPI\}
\par \i0   FImage\cf2 .\cf1 Free\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0   DC \cf2 :=\cf1  FCanvas\cf2 .\cf1 Handle\cf2 ;
\par \cf1   FCanvas\cf2 .\cf1 Handle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   DeleteDC\cf2 (\cf1 DC\cf2 );
\par \cf1   FCanvas\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b inherited\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaDrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   AlphaStretchDrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  Rect\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 ,\cf1  X \cf2 +\cf1  FWidth\cf2 ,\cf1  Y \cf2 +\cf1  FHeight\cf2 ));
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaFill\cf2 (\cf1 Alpha\cf2 :\cf1  Byte\cf2 ;\cf1  IfEmpty\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1   HasAlpha\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   HasAlpha \cf2 :=\cf1  False\cf2 ;
\par \cf1   \b if\b0  IfEmpty \b then
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b if\b0  FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       \b begin
\par \b0         HasAlpha \cf2 :=\cf1  True\cf2 ;
\par \cf1         Break\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1   \b if\b0  \b not\b0  HasAlpha \b then
\par \b0   \b begin
\par \b0     LockUpdate\cf2 ;
\par \cf1     \b try
\par \b0       \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0         FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 :=\cf1  Alpha\cf2 ;
\par \cf1     \b finally
\par \b0       UnlockUpdate\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaFillOnColorMatch\cf2 (\cf1 AColor\cf2 :\cf1  TColor\cf2 ;\cf1  AAlpha\cf2 :\cf1  Byte\cf2 );
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1   CS\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     CS \cf2 :=\cf1  ColorToColorRec\cf2 (\cf1 AColor\cf2 );
\par \cf1     SwapBR\cf2 (\cf1 CS\cf2 );
\par \cf1     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b if\b0  \cf2 (\cf1 FPixels\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 =\cf1  CS\cf2 .\cf1 R\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FPixels\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 =\cf1  CS\cf2 .\cf1 G\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FPixels\cf2 [\cf1 I\cf2 ].\cf1 B \cf2 =\cf1  CS\cf2 .\cf1 B\cf2 )\cf1  \b then
\par \b0         FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 :=\cf1  AAlpha\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaFillPercent\cf2 (\cf1 Percent\cf2 :\cf1  Integer\cf2 ;\cf1  IfEmpty\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b if\b0  FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0         FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 :=\cf1  Percent \cf2 *\cf1  FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \b div\b0  \cf5 100
\par \cf1       \b else\b0  \b if\b0  IfEmpty \b then
\par \b0         FPixels\cf2 [\cf1 I\cf2 ].\cf1 A \cf2 :=\cf1  Percent \cf2 *\cf1  \cf5 255\cf1  \b div\b0  \cf5 100\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaFill\cf2 (\cf1 Alpha\cf2 :\cf1  Byte\cf2 ;\cf1  BlendColor\cf2 :\cf1  TColor\cf2 ;\cf1  Gradient\cf2 ,\cf1  Translucent\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  J\cf2 ,\cf1  A1\cf2 ,\cf1  A2\cf2 ,\cf1  AR\cf2 ,\cf1  AG\cf2 ,\cf1  AB\cf2 ,\cf1  HAlpha\cf2 :\cf1  Integer\cf2 ;
\par \cf1   HStep\cf2 ,\cf1  HSum\cf2 ,\cf1  VStep\cf2 ,\cf1  VSum\cf2 :\cf1  Single\cf2 ;
\par \cf1   Scan\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1   CS\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     VSum \cf2 :=\cf1  \cf5 0\cf2 ;\cf1  VStep \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1     HSum \cf2 :=\cf1  \cf5 0\cf2 ;\cf1  HStep \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1     \b if\b0  Gradient \b then
\par \b0     \b begin
\par \b0       VStep \cf2 :=\cf1  Alpha \cf2 /\cf1  FHeight\cf2 ;
\par \cf1       VSum \cf2 :=\cf1  Alpha\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     CS \cf2 :=\cf1  ColorToColorRec\cf2 (\cf1 BlendColor\cf2 );
\par \cf1   \i \{$IFNDEF USE_WINAPI\}
\par \i0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0   \i \{$ELSE\}
\par \i0     \b for\b0  I \cf2 :=\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b downto\b0  \cf5 0\cf1  \b do
\par \b0   \i \{$ENDIF\}
\par \i0     \b begin
\par \b0       Scan \cf2 :=\cf1  ScanLine\cf2 [\cf1 I\cf2 ];
\par \cf1       HAlpha \cf2 :=\cf1  Alpha\cf2 ;
\par \cf1       \b if\b0  Gradient \b then
\par \b0       \b begin
\par \b0         HStep \cf2 :=\cf1  HAlpha \cf2 /\cf1  FWidth\cf2 ;
\par \cf1         HSum \cf2 :=\cf1  HAlpha\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       \b for\b0  J \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 -\cf1  \cf5 1\cf1  \b do\b0  \b with\b0  Scan\cf2 [\cf1 J\cf2 ]\cf1  \b do
\par \b0       \b begin
\par \b0         A1 \cf2 :=\cf1  HAlpha\cf2 ;
\par \cf1         A2 \cf2 :=\cf1  \cf5 255\cf1  \cf2 -\cf1  HAlpha\cf2 ;
\par \cf1         AR \cf2 :=\cf1  R \cf2 *\cf1  A1 \cf2 +\cf1  CS\cf2 .\cf1 R \cf2 *\cf1  A2\cf2 ;
\par \cf1         AG \cf2 :=\cf1  G \cf2 *\cf1  A1 \cf2 +\cf1  CS\cf2 .\cf1 G \cf2 *\cf1  A2\cf2 ;
\par \cf1         AB \cf2 :=\cf1  B \cf2 *\cf1  A1 \cf2 +\cf1  CS\cf2 .\cf1 B \cf2 *\cf1  A2\cf2 ;
\par \cf1         R \cf2 :=\cf1  AR \b shr\b0  \cf5 8\cf2 ;
\par \cf1         G \cf2 :=\cf1  AG \b shr\b0  \cf5 8\cf2 ;
\par \cf1         B \cf2 :=\cf1  AB \b shr\b0  \cf5 8\cf2 ;
\par \cf1         \b if\b0  Translucent \b then
\par \b0           A \cf2 :=\cf1  HAlpha
\par         \b else
\par \b0           A \cf2 :=\cf1  \cf5 255\cf2 ;
\par \cf1         \b if\b0  Gradient \b then
\par \b0         \b begin
\par \b0           HAlpha \cf2 :=\cf1  Round\cf2 (\cf1 HSum\cf2 );
\par \cf1           HSum \cf2 :=\cf1  HSum \cf2 -\cf1  HStep\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       \b if\b0  Gradient \b then
\par \b0       \b begin
\par \b0         Alpha \cf2 :=\cf1  Round\cf2 (\cf1 VSum\cf2 );
\par \cf1         VSum \cf2 :=\cf1  VSum \cf2 -\cf1  VStep\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AlphaStretchDrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;
\par \cf1   \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\i \{$IFnDEF LCLQT\}
\par \i0\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1   Tmp\cf2 :\cf1  TKAlphaBitmap\cf2 ;
\par \cf1   Ps\cf2 ,\cf1  Pd\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0\i \{$IFDEF LCLQT\}
\par \i0   DrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1\i \{$ELSE\}
\par \i0   Tmp \cf2 :=\cf1  TKAlphaBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1   \b try
\par \b0     Tmp\cf2 .\cf1 SetSize\cf2 (\cf1 FWidth\cf2 ,\cf1  FHeight\cf2 );
\par \cf1     Tmp\cf2 .\cf1 DrawFrom\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );\cf1  \cf0\i // QT does not support
\par \i0\cf1     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0     \b begin
\par \b0       Ps \cf2 :=\cf1  ScanLine\cf2 [\cf1 I\cf2 ];
\par \cf1       Pd \cf2 :=\cf1  Tmp\cf2 .\cf1 ScanLine\cf2 [\cf1 I\cf2 ];
\par \cf1       BlendLine\cf2 (\cf1 Ps\cf2 ,\cf1  Pd\cf2 ,\cf1  FWidth\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     Tmp\cf2 .\cf1 PixelsChanged \cf2 :=\cf1  True\cf2 ;
\par \cf1     Tmp\cf2 .\cf1 DrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1   \b finally
\par \b0     Tmp\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 Assign\cf2 (\cf1 Source\cf2 :\cf1  TPersistent\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  Source \cf2 =\cf1  \b nil\b0  \b then
\par \b0     SetSize\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 )
\par \cf1   \b else\b0  \b if\b0  Source \b is\b0  TKAlphaBitmap \b then
\par \b0     TKAlphaBitmap\cf2 (\cf1 Source\cf2 ).\cf1 AssignTo\cf2 (\cf1 Self\cf2 )
\par \cf1   \b else\b0  \b if\b0  Source \b is\b0  TGraphic \b then
\par \b0     LoadFromGraphic\cf2 (\cf1 TGraphic\cf2 (\cf1 Source\cf2 ))
\par \cf1   \b else
\par \b0     \b inherited\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 AssignTo\cf2 (\cf1 Dest\cf2 :\cf1  TPersistent\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  Dest \b is\b0  TKAlphaBitmap \b then\b0  \b with\b0  TKAlphaBitmap\cf2 (\cf1 Dest\cf2 )\cf1  \b do
\par \b0   \b begin
\par \b0     AutoMirror \cf2 :=\cf1  Self\cf2 .\cf1 AutoMirror\cf2 ;
\par \cf1     DirectCopy \cf2 :=\cf1  Self\cf2 .\cf1 DirectCopy\cf2 ;
\par \cf1     CopyFrom\cf2 (\cf1 Self\cf2 );
\par \cf1   \b end
\par end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 Clear\cf2 ;
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       FPixels\cf2 [\cf1 I\cf2 ].\cf1 Value \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 Changed\cf2 (\cf1 Sender\cf2 :\cf1  TObject\cf2 );
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FPixelsChanged \cf2 :=\cf1  True\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 CombinePixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  Color\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1\b var
\par \b0   Index\cf2 ,\cf1  A1\cf2 ,\cf1  A2\cf2 ,\cf1  AR\cf2 ,\cf1  AG\cf2 ,\cf1  AB\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  \cf2 (\cf1 X \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 X \cf2 <\cf1  FWidth\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <\cf1  FHeight\cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0     LockUpdate\cf2 ;
\par \cf1     \b try
\par \b0       SwapBR\cf2 (\cf1 Color\cf2 );
\par \cf1     \i \{$IFDEF USE_WINAPI\}
\par \i0       Index \cf2 :=\cf1  \cf2 (\cf1 FHeight \cf2 -\cf1  Y \cf2 -\cf1  \cf5 1\cf2 )\cf1  \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ;
\par \cf1     \i \{$ELSE\}
\par \i0       Index \cf2 :=\cf1  Y \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ;
\par \cf1     \i \{$ENDIF\}
\par \i0       A2 \cf2 :=\cf1  Color\cf2 .\cf1 A\cf2 ;
\par \cf1       \b if\b0  A2 \cf2 =\cf1  \cf5 255\cf1  \b then
\par \b0         FPixels\cf2 [\cf1 Index\cf2 ]\cf1  \cf2 :=\cf1  Color
\par       \b else\b0  \b if\b0  A2 \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       \b begin
\par \b0         A1 \cf2 :=\cf1  \cf5 255\cf1  \cf2 -\cf1  Color\cf2 .\cf1 A\cf2 ;
\par \cf1         AR \cf2 :=\cf1  FPixels\cf2 [\cf1 Index\cf2 ].\cf1 R \cf2 *\cf1  A1 \cf2 +\cf1  Color\cf2 .\cf1 R \cf2 *\cf1  A2\cf2 ;
\par \cf1         AG \cf2 :=\cf1  FPixels\cf2 [\cf1 Index\cf2 ].\cf1 G \cf2 *\cf1  A1 \cf2 +\cf1  Color\cf2 .\cf1 G \cf2 *\cf1  A2\cf2 ;
\par \cf1         AB \cf2 :=\cf1  FPixels\cf2 [\cf1 Index\cf2 ].\cf1 B \cf2 *\cf1  A1 \cf2 +\cf1  Color\cf2 .\cf1 B \cf2 *\cf1  A2\cf2 ;
\par \cf1         FPixels\cf2 [\cf1 Index\cf2 ].\cf1 R \cf2 :=\cf1  AR \b shr\b0  \cf5 8\cf2 ;
\par \cf1         FPixels\cf2 [\cf1 Index\cf2 ].\cf1 G \cf2 :=\cf1  AG \b shr\b0  \cf5 8\cf2 ;
\par \cf1         FPixels\cf2 [\cf1 Index\cf2 ].\cf1 B \cf2 :=\cf1  AB \b shr\b0  \cf5 8\cf2 ;
\par \cf1         FPixels\cf2 [\cf1 Index\cf2 ].\cf1 A \cf2 :=\cf1  \cf5 255\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b finally
\par \b0       UnlockUpdate\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 CopyFrom\cf2 (\cf1 ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  Size\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     SetSize\cf2 (\cf1 ABitmap\cf2 .\cf1 Width\cf2 ,\cf1  ABitmap\cf2 .\cf1 Height\cf2 );
\par \cf1     Size \cf2 :=\cf1  FWidth \cf2 *\cf1  SizeOf\cf2 (\cf1 TKColorRec\cf2 );
\par \cf1     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       Move\cf2 (\cf1 ABitmap\cf2 .\cf1 ScanLine\cf2 [\cf1 I\cf2 ]^,\cf1  ScanLine\cf2 [\cf1 I\cf2 ]^,\cf1  Size\cf2 );
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 CopyFromRotated\cf2 (\cf1 ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  J\cf2 :\cf1  Integer\cf2 ;
\par \cf1   SrcScan\cf2 ,\cf1  DstScan\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     SetSize\cf2 (\cf1 ABitmap\cf2 .\cf1 Height\cf2 ,\cf1  ABitmap\cf2 .\cf1 Width\cf2 );
\par \cf1     \b for\b0  J \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  ABitmap\cf2 .\cf1 Height \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0     \b begin
\par \b0       SrcScan \cf2 :=\cf1  ABitmap\cf2 .\cf1 ScanLine\cf2 [\cf1 J\cf2 ];
\par \cf1       \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  ABitmap\cf2 .\cf1 Width \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b begin
\par \b0         DstScan \cf2 :=\cf1  ScanLine\cf2 [\cf1 ABitmap\cf2 .\cf1 Width \cf2 -\cf1  I \cf2 -\cf1  \cf5 1\cf2 ];
\par \cf1         DstScan\cf2 [\cf1 J\cf2 ]\cf1  \cf2 :=\cf1  SrcScan\cf2 [\cf1 I\cf2 ];
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 CopyFromXY\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  ABitmap\cf2 :\cf1  TKAlphaBitmap\cf2 );
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  J\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  X \b to\b0  X \cf2 +\cf1  ABitmap\cf2 .\cf1 Width \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b for\b0  J \cf2 :=\cf1  Y \b to\b0  Y \cf2 +\cf1  ABitmap\cf2 .\cf1 Height \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0         \b if\b0  \cf2 (\cf1 I \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 I \cf2 <\cf1  FWidth\cf2 )\cf1  \b and\b0  \cf2 (\cf1 J \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 J \cf2 <\cf1  FHeight\cf2 )\cf1  \b then
\par \b0           Pixels\cf2 [\cf1 J \cf2 *\cf1  FWidth \cf2 +\cf1  I\cf2 ]\cf1  \cf2 :=\cf1  ABitmap\cf2 .\cf1 Pixels\cf2 [(\cf1 J \cf2 -\cf1  Y\cf2 )\cf1  \cf2 *\cf1  ABitmap\cf2 .\cf1 Width \cf2 +\cf1  \cf2 (\cf1 I \cf2 -\cf1  X\cf2 )];
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  FDirectCopy \b then
\par \b0     DrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 )
\par \cf1   \b else
\par \b0     AlphaStretchDrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 DrawFrom\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  \b not\b0  Empty \b then
\par \b0   \b begin
\par \b0     \b if\b0  \b not\b0  CanvasScaled\cf2 (\cf1 ACanvas\cf2 )\cf1  \b then
\par \b0       StretchBitmap\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  FWidth\cf2 ,\cf1  FHeight\cf2 ),\cf1  ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  ARect\cf2 )
\par \cf1     \b else
\par \b0     \b begin
\par \b0       FCanvas\cf2 .\cf1 Brush \cf2 :=\cf1  ACanvas\cf2 .\cf1 Brush\cf2 ;
\par \cf1       DrawFilledRectangle\cf2 (\cf1 FCanvas\cf2 ,\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  FWidth\cf2 ,\cf1  FHeight\cf2 ),
\par \cf1         \i \{$IFDEF USE_WINAPI\}\i0 GetBkColor\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 )\cf1\i \{$ELSE\}\i0 clWindow\i \{$ENDIF\}\i0\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     UpdatePixels\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 DrawFrom\cf2 (\cf1 AGraphic\cf2 :\cf1  TGraphic\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  \b not\b0  Empty \b then
\par \b0   \b begin
\par \b0     UpdateHandle\cf2 ;
\par \cf1     FCanvas\cf2 .\cf1 Draw\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 ,\cf1  AGraphic\cf2 );
\par \cf1     UpdatePixels\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 DrawTo\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  \b not\b0  Empty \b then
\par \b0   \b begin
\par \b0     UpdateHandle\cf2 ;
\par \cf1     StretchBitmap\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  ARect\cf2 ,\cf1  FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  FWidth\cf2 ,\cf1  FHeight\cf2 ))
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 Fill\cf2 (\cf1 Color\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1\b var
\par \b0   I\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       FPixels\cf2 [\cf1 I\cf2 ].\cf1 Value \cf2 :=\cf1  Color\cf2 .\cf1 Value\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetEmpty\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  \cf2 (\cf1 FWidth \cf2 =\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FHeight \cf2 =\cf1  \cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  FHeight\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetPixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ):\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  \cf2 (\cf1 X \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 X \cf2 <\cf1  FWidth\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <\cf1  FHeight\cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0   \i \{$IFDEF USE_WINAPI\}
\par \i0     Result \cf2 :=\cf1  FPixels\cf2 [(\cf1 FHeight \cf2 -\cf1  Y \cf2 -\cf1  \cf5 1\cf2 )\cf1  \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ];
\par \cf1   \i \{$ELSE\}
\par \i0     Result \cf2 :=\cf1  FPixels\cf2 [\cf1 Y \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ];
\par \cf1   \i \{$ENDIF\}
\par \i0     SwapBR\cf2 (\cf1 Result\cf2 );
\par \cf1   \b end\b0  \b else
\par \b0     Result \cf2 :=\cf1  MakeColorRec\cf2 (\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 ,\cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetTransparent\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  True\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetScanLine\cf2 (\cf1 Index\cf2 :\cf1  Integer\cf2 ):\cf1  PKColorRecs\cf2 ;
\par \cf1\b begin
\par \b0   \cf0\i // no checks here
\par \i0\cf1   Result \cf2 :=\cf1  \cf2 @\cf1 FPixels\cf2 [\cf1 Index \cf2 *\cf1  FWidth\cf2 ];
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetHandle\cf2 :\cf1  HBITMAP\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  FHandle\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKAlphaBitmap\cf2 .\cf1 GetWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  FWidth\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 GrayScale\cf2 ;
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  Average\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FWidth \cf2 *\cf1  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0     \b begin
\par \b0       \cf0\i // R and B are swapped
\par \i0\cf1       Average \cf2 :=\cf1  \cf2 (\cf1 Integer\cf2 (\cf5 7\cf2 )\cf1  \cf2 *\cf1  FPixels\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 +\cf1  Integer\cf2 (\cf5 72\cf2 )\cf1  \cf2 *\cf1  FPixels\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 +\cf1  Integer\cf2 (\cf5 21\cf2 )\cf1  \cf2 *\cf1  FPixels\cf2 [\cf1 I\cf2 ].\cf1 B\cf2 )\cf1  \b div\b0  \cf5 100\cf2 ;
\par \cf1       FPixels\cf2 [\cf1 I\cf2 ].\cf1 R \cf2 :=\cf1  Average\cf2 ;
\par \cf1       FPixels\cf2 [\cf1 I\cf2 ].\cf1 G \cf2 :=\cf1  Average\cf2 ;
\par \cf1       FPixels\cf2 [\cf1 I\cf2 ].\cf1 B \cf2 :=\cf1  Average\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$IFNDEF FPC\}
\par \i0\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 LoadFromClipboardFormat\cf2 (\cf1 AFormat\cf2 :\cf1  Word\cf2 ;\cf1  AData\cf2 :\cf1  THandle\cf2 ;
\par \cf1   APalette\cf2 :\cf1  HPALETTE\cf2 );
\par \cf1\b begin
\par \b0   \cf0\i // does nothing
\par \i0\cf1\b end\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par 
\par \i0\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 LoadFromFile\cf2 (\cf1\b const\b0  Filename\cf2 :\cf1  \b string\b0\cf2 );
\par \cf1\b var
\par \b0   IM\cf2 :\cf1  TPicture\cf2 ;
\par \cf1\b begin
\par \b0   IM \cf2 :=\cf1  TPicture\cf2 .\cf1 Create\cf2 ;
\par \cf1   \b try
\par \b0     IM\cf2 .\cf1 LoadFromFile\cf2 (\cf1 FileName\cf2 );
\par \cf1     LoadFromGraphic\cf2 (\cf1 IM\cf2 .\cf1 Graphic\cf2 );
\par \cf1   \b finally
\par \b0     IM\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 LoadFromGraphic\cf2 (\cf1 Image\cf2 :\cf1  TGraphic\cf2 );
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     SetSize\cf2 (\cf1 Image\cf2 .\cf1 Width\cf2 ,\cf1  Image\cf2 .\cf1 Height\cf2 );
\par \cf1   \i \{$IFDEF USE_WINAPI\}
\par \i0     Canvas\cf2 .\cf1 Draw\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  Image\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     \b if\b0  Image \b is\b0  TRasterImage \b then
\par \b0       FImage\cf2 .\cf1 Assign\cf2 (\cf1 TRasterImage\cf2 (\cf1 Image\cf2 ).\cf1 CreateIntfImage\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \i0     \cf0\i // if bitmap has no alpha channel, create full opacity
\par \i0\cf1     AlphaFill\cf2 (\cf7 $FF\cf2 ,\cf1  True\cf2 );
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 LoadFromStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );
\par \cf1\b var
\par \b0   BF\cf2 :\cf1  TBitmapFileHeader\cf2 ;
\par \cf1   BI\cf2 :\cf1  TBitmapInfoHeader\cf2 ;
\par \cf1\b begin
\par \b0   Stream\cf2 .\cf1 Read\cf2 (\cf1 BF\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapFileHeader\cf2 ));
\par \cf1   \b if\b0  BF\cf2 .\cf1 bfType \cf2 =\cf1  \cf7 $4D42\cf1  \b then
\par \b0   \b begin
\par \b0     Stream\cf2 .\cf1 Read\cf2 (\cf1 BI\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 ));
\par \cf1     \b if\b0  BI\cf2 .\cf1 biBitCount \cf2 =\cf1  \cf5 32\cf1  \b then
\par \b0     \b begin
\par \b0       LockUpdate\cf2 ;
\par \cf1       \b try
\par \b0         SetSize\cf2 (\cf1 BI\cf2 .\cf1 biWidth\cf2 ,\cf1  BI\cf2 .\cf1 biHeight\cf2 );
\par \cf1         Stream\cf2 .\cf1 Read\cf2 (\cf1 FPixels\cf2 ^,\cf1  BI\cf2 .\cf1 biSizeImage\cf2 );
\par \cf1         \cf0\i // if bitmap has no alpha channel, create full opacity
\par \i0\cf1         AlphaFill\cf2 (\cf7 $FF\cf2 ,\cf1  True\cf2 );
\par \cf1       \i \{$IFnDEF USE_WINAPI\}
\par \i0         \b if\b0  FAutoMirror \b then
\par \b0           MirrorVert\cf2 ;
\par \cf1       \i \{$ENDIF\}
\par \i0       \b finally
\par \b0         UnlockUpdate\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 LockUpdate\cf2 ;
\par \cf1\b begin
\par \b0   Inc\cf2 (\cf1 FUpdateLock\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 MirrorHorz\cf2 ;
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  J\cf2 ,\cf1  Index\cf2 :\cf1  Integer\cf2 ;
\par \cf1   SrcScan\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1   Buf\cf2 :\cf1  TKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  FHeight \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0     \b begin
\par \b0       SrcScan \cf2 :=\cf1  ScanLine\cf2 [\cf1 I\cf2 ];
\par \cf1       Index \cf2 :=\cf1  FWidth \cf2 -\cf1  \cf5 1\cf2 ;
\par \cf1       \b for\b0  J \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  \cf2 (\cf1 FWidth \b shr\b0  \cf5 1\cf2 )\cf1  \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b begin
\par \b0         Buf \cf2 :=\cf1  SrcScan\cf2 [\cf1 Index\cf2 ];
\par \cf1         SrcScan\cf2 [\cf1 Index\cf2 ]\cf1  \cf2 :=\cf1  SrcScan\cf2 [\cf1 J\cf2 ];
\par \cf1         SrcScan\cf2 [\cf1 J\cf2 ]\cf1  \cf2 :=\cf1  Buf\cf2 ;
\par \cf1         Dec\cf2 (\cf1 Index\cf2 );
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 MirrorVert\cf2 ;
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  Size\cf2 ,\cf1  Index\cf2 :\cf1  Integer\cf2 ;
\par \cf1   SrcScan\cf2 ,\cf1  DstScan\cf2 :\cf1  PKColorRecs\cf2 ;
\par \cf1   Buf\cf2 :\cf1  PKColorRec\cf2 ;
\par \cf1\b begin
\par \b0   LockUpdate\cf2 ;
\par \cf1   \b try
\par \b0     Size\cf2 :=\cf1  FWidth \cf2 *\cf1  SizeOf\cf2 (\cf1 TKColorRec\cf2 );
\par \cf1     Index \cf2 :=\cf1  FHeight \cf2 -\cf1  \cf5 1\cf2 ;
\par \cf1     GetMem\cf2 (\cf1 Buf\cf2 ,\cf1  Size\cf2 );
\par \cf1     \b try
\par \b0       \b for\b0  I \cf2 :=\cf1  \cf5 0\cf1  \b to\b0  \cf2 (\cf1 FHeight \b shr\b0  \cf5 1\cf2 )\cf1  \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0       \b begin
\par \b0         SrcScan \cf2 :=\cf1  ScanLine\cf2 [\cf1 I\cf2 ];
\par \cf1         DstScan \cf2 :=\cf1  ScanLine\cf2 [\cf1 Index\cf2 ];
\par \cf1         Move\cf2 (\cf1 SrcScan\cf2 ^,\cf1  Buf\cf2 ^,\cf1  Size\cf2 );
\par \cf1         Move\cf2 (\cf1 DstScan\cf2 ^,\cf1  SrcScan\cf2 ^,\cf1  Size\cf2 );
\par \cf1         Move\cf2 (\cf1 Buf\cf2 ^,\cf1  DstScan\cf2 ^,\cf1  Size\cf2 );
\par \cf1         Dec\cf2 (\cf1 Index\cf2 );
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b finally
\par \b0       FreeMem\cf2 (\cf1 Buf\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b finally
\par \b0     UnlockUpdate\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$IFNDEF FPC\}
\par \i0\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SaveToClipboardFormat\cf2 (\cf1\b var\b0  AFormat\cf2 :\cf1  Word\cf2 ;
\par \cf1   \b var\b0  AData\cf2 :\cf1  THandle\cf2 ;\cf1  \b var\b0  APalette\cf2 :\cf1  HPALETTE\cf2 );
\par \cf1\b begin
\par \b0   \cf0\i // does nothing
\par \i0\cf1\b end\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par 
\par \i0\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SaveToStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );
\par \cf1\b var
\par \b0   Size\cf2 :\cf1  Integer\cf2 ;
\par \cf1   BF\cf2 :\cf1  TBitmapFileHeader\cf2 ;
\par \cf1   BI\cf2 :\cf1  TBitmapInfoHeader\cf2 ;
\par \cf1\b begin
\par \b0\i \{$IFnDEF USE_WINAPI\}
\par \i0   \b if\b0  FAutoMirror \b then
\par \b0     MirrorVert\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0   Size \cf2 :=\cf1  FWidth \cf2 *\cf1  FHeight \cf2 *\cf1  \cf5 4\cf2 ;
\par \cf1   FillChar\cf2 (\cf1 BF\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapFileHeader\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1   BF\cf2 .\cf1 bfType \cf2 :=\cf1  \cf7 $4D42\cf2 ;
\par \cf1   BF\cf2 .\cf1 bfSize \cf2 :=\cf1  SizeOf\cf2 (\cf1 TBitmapFileHeader\cf2 )\cf1  \cf2 +\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 )\cf1  \cf2 +\cf1  Size\cf2 ;
\par \cf1   BF\cf2 .\cf1 bfOffBits \cf2 :=\cf1  SizeOf\cf2 (\cf1 TBitmapFileHeader\cf2 )\cf1  \cf2 +\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 );
\par \cf1   Stream\cf2 .\cf1 Write\cf2 (\cf1 BF\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapFileHeader\cf2 ));
\par \cf1   FillChar\cf2 (\cf1 BI\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1   BI\cf2 .\cf1 biSize \cf2 :=\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 );
\par \cf1   BI\cf2 .\cf1 biWidth \cf2 :=\cf1  FWidth\cf2 ;
\par \cf1   BI\cf2 .\cf1 biHeight \cf2 :=\cf1  FHeight\cf2 ;
\par \cf1   BI\cf2 .\cf1 biPlanes \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1   BI\cf2 .\cf1 biBitCount \cf2 :=\cf1  \cf5 32\cf2 ;
\par \cf1   BI\cf2 .\cf1 biCompression \cf2 :=\cf1  BI_RGB\cf2 ;
\par \cf1   BI\cf2 .\cf1 biSizeImage \cf2 :=\cf1  Size\cf2 ;
\par \cf1   Stream\cf2 .\cf1 Write\cf2 (\cf1 BI\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 ));
\par \cf1   Stream\cf2 .\cf1 Write\cf2 (\cf1 FPixels\cf2 ^,\cf1  Size\cf2 );
\par \cf1\i \{$IFnDEF USE_WINAPI\}
\par \i0   \b if\b0  FAutoMirror \b then
\par \b0     MirrorVert\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SetHeight\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   SetSize\cf2 (\cf1 FWidth\cf2 ,\cf1  Value\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SetPixel\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;\cf1  Value\cf2 :\cf1  TKColorRec\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  \cf2 (\cf1 X \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 X \cf2 <\cf1  FWidth\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 >=\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <\cf1  FHeight\cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0     LockUpdate\cf2 ;
\par \cf1     \b try
\par \b0       SwapBR\cf2 (\cf1 Value\cf2 );
\par \cf1     \i \{$IFDEF USE_WINAPI\}
\par \i0       FPixels\cf2 [(\cf1 FHeight \cf2 -\cf1  Y \cf2 -\cf1  \cf5 1\cf2 )\cf1  \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ]\cf1  \cf2 :=\cf1  Value\cf2 ;
\par \cf1     \i \{$ELSE\}
\par \i0       FPixels\cf2 [\cf1 Y \cf2 *\cf1  FWidth \cf2 +\cf1  X\cf2 ]\cf1  \cf2 :=\cf1  Value\cf2 ;
\par \cf1     \i \{$ENDIF\}
\par \i0     \b finally
\par \b0       UnlockUpdate\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SetSize\cf2 (\cf1 AWidth\cf2 ,\cf1  AHeight\cf2 :\cf1  Integer\cf2 );
\par \cf1\b var
\par \b0\i \{$IFNDEF USE_WINAPI\}
\par \i0   ImgFormatDescription\cf2 :\cf1  TRawImageDescription\cf2 ;
\par \cf1\i \{$ELSE\}
\par \i0   BI\cf2 :\cf1  TBitmapInfoHeader\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0   AWidth \cf2 :=\cf1  Max\cf2 (\cf1 AWidth\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1   AHeight \cf2 :=\cf1  Max\cf2 (\cf1 AHeight\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1   \b if\b0  \cf2 (\cf1 AWidth \cf2 <>\cf1  FWidth\cf2 )\cf1  \b or\b0  \cf2 (\cf1 AHeight \cf2 <>\cf1  FHeight\cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0     LockUpdate\cf2 ;
\par \cf1     \b try
\par \b0       FWidth \cf2 :=\cf1  AWidth\cf2 ;
\par \cf1       FHeight \cf2 :=\cf1  AHeight\cf2 ;
\par \cf1       \b if\b0  FHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       \b begin
\par \b0         SelectObject\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  FOldBitmap\cf2 );
\par \cf1         DeleteObject\cf2 (\cf1 FHandle\cf2 );
\par \cf1         FHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1       \i \{$IFNDEF USE_WINAPI\}
\par \i0         DeleteObject\cf2 (\cf1 FMaskHandle\cf2 );
\par \cf1         FMaskHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1       \i \{$ENDIF\}
\par \i0       \b end\b0\cf2 ;
\par \cf1     \i \{$IFNDEF USE_WINAPI\}
\par \i0       FImage\cf2 .\cf1 SetSize\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1     \i \{$ENDIF\}
\par \i0       FPixels \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1       \b if\b0  \cf2 (\cf1 FWidth \cf2 <>\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FHeight \cf2 <>\cf1  \cf5 0\cf2 )\cf1  \b then
\par \b0       \b begin
\par \b0       \i \{$IFNDEF USE_WINAPI\}
\par \i0         ImgFormatDescription\cf2 .\cf1 Init_BPP32_B8G8R8A8_BIO_TTB\cf2 (\cf1 FWidth\cf2 ,\cf1 FHeight\cf2 );
\par \cf1         FImage\cf2 .\cf1 DataDescription \cf2 :=\cf1  ImgFormatDescription\cf2 ;
\par \cf1         FPixelsChanged \cf2 :=\cf1  True\cf2 ;
\par \cf1         UpdateHandle\cf2 ;
\par \cf1       \i \{$ELSE\}
\par \i0         FillChar\cf2 (\cf1 BI\cf2 ,\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 ),\cf1  \cf5 0\cf2 );
\par \cf1         BI\cf2 .\cf1 biSize \cf2 :=\cf1  SizeOf\cf2 (\cf1 TBitmapInfoHeader\cf2 );
\par \cf1         BI\cf2 .\cf1 biWidth \cf2 :=\cf1  FWidth\cf2 ;
\par \cf1         BI\cf2 .\cf1 biHeight \cf2 :=\cf1  FHeight\cf2 ;
\par \cf1         BI\cf2 .\cf1 biPlanes \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1         BI\cf2 .\cf1 biBitCount \cf2 :=\cf1  \cf5 32\cf2 ;
\par \cf1         BI\cf2 .\cf1 biCompression \cf2 :=\cf1  BI_RGB\cf2 ;
\par \cf1         FHandle \cf2 :=\cf1  GDICheck\cf2 (\cf1 CreateDIBSection\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  PBitmapInfo\cf2 (@\cf1 BI\cf2 )^,\cf1  DIB_RGB_COLORS\cf2 ,\cf1  Pointer\cf2 (\cf1 FPixels\cf2 ),\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ));
\par \cf1         FOldBitmap \cf2 :=\cf1  SelectObject\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  FHandle\cf2 );
\par \cf1       \i \{$ENDIF\}
\par \i0       \b end\b0\cf2 ;
\par \cf1     \b finally
\par \b0       UnlockUpdate\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SetWidth\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   SetSize\cf2 (\cf1 Value\cf2 ,\cf1  FWidth\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 SetTransparent\cf2 (\cf1 Value\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b begin
\par \b0   \cf0\i // does nothing
\par \i0\cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 UnlockUpdate\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  FUpdateLock \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     Dec\cf2 (\cf1 FUpdateLock\cf2 );
\par \cf1     \b if\b0  FUpdateLock \cf2 =\cf1  \cf5 0\cf1  \b then
\par \b0       Changed\cf2 (\cf1 Self\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 UpdateHandle\cf2 ;
\par \cf1\b begin
\par \b0\i \{$IFNDEF USE_WINAPI\}
\par \i0   \b if\b0  FPixelsChanged \b then
\par \b0   \b begin
\par \b0     PixelsChanged \cf2 :=\cf1  False\cf2 ;
\par \cf1     \b if\b0  FHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       DeleteObject\cf2 (\cf1 FMaskHandle\cf2 );
\par \cf1       DeleteObject\cf2 (\cf1 SelectObject\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  FOldBitmap\cf2 ));
\par \cf1     \b end\b0\cf2 ;
\par \cf1     FImage\cf2 .\cf1 CreateBitmaps\cf2 (\cf1 FHandle\cf2 ,\cf1  FMaskHandle\cf2 ,\cf1  False\cf2 );
\par \cf1     FOldBitmap \cf2 :=\cf1  SelectObject\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  FHandle\cf2 );
\par \cf1     FPixels \cf2 :=\cf1  PKColorRecs\cf2 (\cf1 FImage\cf2 .\cf1 PixelData\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKAlphaBitmap\cf2 .\cf1 UpdatePixels\cf2 ;
\par \cf1\b begin
\par \b0\i \{$IFNDEF USE_WINAPI\}
\par \i0   FImage\cf2 .\cf1 LoadFromDevice\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 );
\par \cf1   FPixelsChanged \cf2 :=\cf1  True\cf2 ;
\par \cf1   UpdateHandle\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKMetafile \}
\par 
\par \cf1 \{$IFDEF USE_WINAPI\}
\par 
\par \i0\b constructor\b0  TKMetafile\cf2 .\cf1 Create\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FCopyOnAssign \cf2 :=\cf1  True\cf2 ;
\par \cf1   FEmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FRequiredHeight \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FRequiredWidth \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FWmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b destructor\b0  TKMetafile\cf2 .\cf1 Destroy\cf2 ;
\par \cf1\b begin
\par \b0   Clear\cf2 ;
\par \cf1   \b inherited\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 Assign\cf2 (\cf1 Source\cf2 :\cf1  TPersistent\cf2 );
\par \cf1\b var
\par \b0   Stream\cf2 :\cf1  TMemoryStream\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  Source \b is\b0  TKMetafile \b then
\par \b0   \b begin
\par \b0     Clear\cf2 ;
\par \cf1     FEnhanced \cf2 :=\cf1  TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 Enhanced\cf2 ;
\par \cf1     \b if\b0  TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 CopyOnAssign \b then
\par \b0     \b begin
\par \b0       Stream \cf2 :=\cf1  TMemoryStream\cf2 .\cf1 Create\cf2 ;
\par \cf1       \b try
\par \b0         TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 SaveToStream\cf2 (\cf1 Stream\cf2 );
\par \cf1         Stream\cf2 .\cf1 Seek\cf2 (\cf5 0\cf2 ,\cf1  soFromBeginning\cf2 );
\par \cf1         LoadFromStream\cf2 (\cf1 Stream\cf2 );
\par \cf1       \b finally
\par \b0         Stream\cf2 .\cf1 Free\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0     \b begin
\par \b0       \cf0\i // here, the source loses the images!
\par \i0\cf1       TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 Release\cf2 (\cf1 FWmfHandle\cf2 ,\cf1  FEmfHandle\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     FRequiredHeight \cf2 :=\cf1  TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 Height\cf2 ;
\par \cf1     FRequiredWidth \cf2 :=\cf1  TKMetafile\cf2 (\cf1 Source\cf2 ).\cf1 Width\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 Clear\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  FWmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     DeleteMetafile\cf2 (\cf1 FWmfHandle\cf2 );
\par \cf1     FWmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   \b if\b0  FEmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     DeleteEnhMetafile\cf2 (\cf1 FEmfHandle\cf2 );
\par \cf1     FEmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  Rect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b var
\par \b0   BM\cf2 :\cf1  TKAlphaBitmap\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   \b if\b0  FWMfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     \b if\b0  FRequiredWidth \cf2 *\cf1  FRequiredHeight \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       BM \cf2 :=\cf1  TKAlphaBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1       \b try
\par \b0         BM\cf2 .\cf1 DirectCopy \cf2 :=\cf1  True\cf2 ;
\par \cf1         BM\cf2 .\cf1 SetSize\cf2 (\cf1 FRequiredWidth\cf2 ,\cf1  FRequiredHeight\cf2 );
\par \cf1         BM\cf2 .\cf1 Fill\cf2 (\cf1 MakeColorRec\cf2 (\cf5 255\cf2 ,\cf5 255\cf2 ,\cf5 255\cf2 ,\cf5 255\cf2 ));
\par \cf1         PlayMetafile\cf2 (\cf1 BM\cf2 .\cf1 Canvas\cf2 .\cf1 Handle\cf2 ,\cf1  FWmfHandle\cf2 );
\par \cf1         BM\cf2 .\cf1 DirectCopy \cf2 :=\cf1  False\cf2 ;
\par \cf1         BM\cf2 .\cf1 DrawTo\cf2 (\cf1 ACanvas\cf2 ,\cf1  Rect\cf2 );
\par \cf1       \b finally
\par \b0         BM\cf2 .\cf1 Free\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end
\par \b0   \b else\b0  \b if\b0  FEMFHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     PlayEnhMetafile\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  FEmfHandle\cf2 ,\cf1  Rect\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKMetafile\cf2 .\cf1 GetEmpty\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  \cf2 (\cf1 FWmfHandle \cf2 =\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FEmfHandle \cf2 =\cf1  \cf5 0\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKMetafile\cf2 .\cf1 GetHeight\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  FRequiredHeight\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKMetafile\cf2 .\cf1 GetTransparent\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  False\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKMetafile\cf2 .\cf1 GetWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Result \cf2 :=\cf1  FRequiredWidth\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 LoadFromStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );
\par \cf1\b var
\par \b0   S\cf2 :\cf1  AnsiString\cf2 ;
\par \cf1   EHDR\cf2 :\cf1  TEnhMetaheader\cf2 ;
\par \cf1   MFP\cf2 :\cf1  TMetaFilePict\cf2 ;
\par \cf1\b begin
\par \b0   SetLength\cf2 (\cf1 S\cf2 ,\cf1  Stream\cf2 .\cf1 Size \cf2 -\cf1  Stream\cf2 .\cf1 Position\cf2 );
\par \cf1   \b if\b0  S \cf2 <>\cf1  \cf4 ''\cf1  \b then
\par \b0   \b begin
\par \b0     Stream\cf2 .\cf1 Read\cf2 (\cf1 EHDR\cf2 ,\cf1  SizeOf\cf2 (\cf1 TEnhMetaHeader\cf2 ));
\par \cf1     Stream\cf2 .\cf1 Seek\cf2 (-\cf1 SizeOf\cf2 (\cf1 TEnhMetaHeader\cf2 ),\cf1  soFromCurrent\cf2 );
\par \cf1     Stream\cf2 .\cf1 Read\cf2 (\cf1 S\cf2 [\cf5 1\cf2 ],\cf1  Length\cf2 (\cf1 S\cf2 ));
\par \cf1     \b if\b0  FEnhanced \b and\b0  \cf2 (\cf1 EHDR\cf2 .\cf1 iType \cf2 =\cf1  EMR_HEADER\cf2 )\cf1  \b then
\par \b0     \b begin
\par \b0       FEmfHandle \cf2 :=\cf1  SetEnhMetafileBits\cf2 (\cf1 Length\cf2 (\cf1 S\cf2 ),\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ]);
\par \cf1       FRequiredWidth \cf2 :=\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Right \cf2 -\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Left\cf2 ;
\par \cf1       FRequiredHeight \cf2 :=\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Bottom \cf2 -\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Top\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0     \b begin
\par \b0       FWmfHandle \cf2 :=\cf1  SetMetafileBitsEx\cf2 (\cf1 Length\cf2 (\cf1 S\cf2 ),\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ]);
\par \cf1       \b if\b0  FWmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0       \b begin
\par \b0         \cf0\i // obtain width and height
\par \i0\cf1         \b with\b0  MFP \b do
\par \b0         \b begin
\par \b0           MM \cf2 :=\cf1  MM_ANISOTROPIC\cf2 ;
\par \cf1           xExt \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1           yExt \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1           hmf \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1         FEmfHandle \cf2 :=\cf1  SetWinMetaFileBits\cf2 (\cf1 Length\cf2 (\cf1 S\cf2 ),\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ],\cf1  \cf5 0\cf2 ,\cf1  MFP\cf2 );
\par \cf1         \b if\b0  FEmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0         \b begin
\par \b0           \b if\b0  GetEnhMetaFileHeader\cf2 (\cf1 FEmfHandle\cf2 ,\cf1  SizeOf\cf2 (\cf1 TEnhMetaHeader\cf2 ),\cf1  \cf2 @\cf1 EHDR\cf2 )\cf1  \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0           \b begin
\par \b0             FRequiredWidth \cf2 :=\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Right \cf2 -\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Left\cf2 ;
\par \cf1             FRequiredHeight \cf2 :=\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Bottom \cf2 -\cf1  EHDR\cf2 .\cf1 rclBounds\cf2 .\cf1 Top\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1           DeleteEnhMetafile\cf2 (\cf1 FEmfHandle\cf2 );
\par \cf1           FEmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 Release\cf2 (\cf1\b out\b0  AWmfHandle\cf2 :\cf1  HMETAFILE\cf2 ;\cf1  \b out\b0  AEmfHandle\cf2 :\cf1  HENHMETAFILE\cf2 );
\par \cf1\b begin
\par \b0   AWmfHandle \cf2 :=\cf1  FWmfHandle\cf2 ;
\par \cf1   FWmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   AEmfHandle \cf2 :=\cf1  FEmfHandle\cf2 ;
\par \cf1   FEmfHandle \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SaveToStream\cf2 (\cf1 Stream\cf2 :\cf1  TStream\cf2 );
\par \cf1\b var
\par \b0   S\cf2 :\cf1  AnsiString\cf2 ;
\par \cf1   Size\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   S \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1   \b if\b0  FWmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     Size \cf2 :=\cf1  GetMetaFileBitsEx\cf2 (\cf1 FWmfHandle\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1     \b if\b0  Size \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       SetLength\cf2 (\cf1 S\cf2 ,\cf1  Size\cf2 );
\par \cf1       GetMetafileBitsEx\cf2 (\cf1 FWmfHandle\cf2 ,\cf1  Size\cf2 ,\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ]);
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end
\par \b0   \b else\b0  \b if\b0  FEmfHandle \cf2 <>\cf1  \cf5 0\cf1  \b then
\par \b0   \b begin
\par \b0     Size \cf2 :=\cf1  GetEnhMetaFileBits\cf2 (\cf1 FEmfHandle\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1     \b if\b0  Size \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       SetLength\cf2 (\cf1 S\cf2 ,\cf1  Size\cf2 );
\par \cf1       GetEnhMetafileBits\cf2 (\cf1 FEmfHandle\cf2 ,\cf1  Size\cf2 ,\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ]);
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   \b if\b0  S \cf2 <>\cf1  \cf4 ''\cf1  \b then
\par \b0     Stream\cf2 .\cf1 Write\cf2 (\cf1 S\cf2 [\cf5 1\cf2 ],\cf1  Length\cf2 (\cf1 S\cf2 ));
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SetEMFHandle\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  HENHMETAFILE\cf2 );
\par \cf1\b begin
\par \b0   Clear\cf2 ;
\par \cf1   FEMFHandle \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SetEnhanced\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b begin
\par \b0   FEnhanced \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SetHeight\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   FRequiredHeight \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SetWidth\cf2 (\cf1 Value\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   FRequiredWidth \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKMetafile\cf2 .\cf1 SetWMFHandle\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  HMETAFILE\cf2 );
\par \cf1\b begin
\par \b0   Clear\cf2 ;
\par \cf1   FWMFHandle \cf2 :=\cf1  Value\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$ENDIF\}
\par 
\par \cf0 \{ TKTextBox \}
\par 
\par \i0\cf1\b constructor\b0  TKTextBox\cf2 .\cf1 Create\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FAttributes \cf2 :=\cf1  \cf2 [];
\par \cf1   FBackColor \cf2 :=\cf1  clWhite\cf2 ;
\par \cf1   FHAlign \cf2 :=\cf1  halLeft\cf2 ;
\par \cf1   FHasTabs \cf2 :=\cf1  False\cf2 ;
\par \cf1   FHPadding \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FSelBkgnd \cf2 :=\cf1  clHighlight\cf2 ;
\par \cf1   FSelColor \cf2 :=\cf1  clHighlightText\cf2 ;
\par \cf1   FSelEnd \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FSelStart \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   FSpacesForTab \cf2 :=\cf1  \cf5 8\cf2 ;
\par \cf1   FText \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1   FVAlign \cf2 :=\cf1  valCenter\cf2 ;
\par \cf1   FVPadding \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 Draw\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b var
\par \b0   Y\cf2 :\cf1  Integer\cf2 ;
\par \cf1   TmpRect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   PrevRgn\cf2 :\cf1  HRGN\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 ARect\cf2 )\cf1  \b then
\par \b0   \b begin
\par \b0     \b if\b0  taFillRect \b in\b0  Attributes \b then
\par \b0       DrawFilledRectangle\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 ,\cf1  BackColor\cf2 );
\par \cf1     \b if\b0  FText \cf2 <>\cf1  \cf4 ''\cf1  \b then
\par \b0     \b begin
\par \b0       Initialize\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1       \b if\b0  \b not\b0  IsRectEmpty\cf2 (\cf1 FClipRect\cf2 )\cf1  \b then
\par \b0       \b begin
\par \b0         Y \cf2 :=\cf1  GetVertPos\cf2 ;
\par \cf1         TmpRect \cf2 :=\cf1  FClipRect\cf2 ;
\par \cf1         \b if\b0  taClip \b in\b0  Attributes \b then
\par \b0         \b begin
\par \b0           TranslateRectToDevice\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TmpRect\cf2 );
\par \cf1           PrevRgn \cf2 :=\cf1  RgnCreateAndGet\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 );
\par \cf1           \b try
\par \b0             \b if\b0  ExtSelectClipRect\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TmpRect\cf2 ,\cf1  RGN_AND\cf2 ,\cf1  PrevRgn\cf2 )\cf1  \b then
\par \b0             \b begin
\par \b0               \b if\b0  \b not\b0  \cf2 (\cf1 taFillText \b in\b0  Attributes\cf2 )\cf1  \b then
\par \b0                 SetBkMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TRANSPARENT\cf2 );
\par \cf1               Process\cf2 (\cf1 Y\cf2 ,\cf1  tbfDraw\cf2 );
\par \cf1             \b end\b0\cf2 ;
\par \cf1           \b finally
\par \b0             RgnSelectAndDelete\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  PrevRgn\cf2 );
\par \cf1           \b end\b0\cf2 ;
\par \cf1         \b end\b0  \b else
\par \b0         \b begin
\par \b0           \b if\b0  \b not\b0  \cf2 (\cf1 taFillText \b in\b0  Attributes\cf2 )\cf1  \b then
\par \b0             SetBkMode\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TRANSPARENT\cf2 );
\par \cf1           Process\cf2 (\cf1 Y\cf2 ,\cf1  tbfDraw\cf2 );
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKTextBox\cf2 .\cf1 GetHorzPos\cf2 (\cf1 ATextWidth\cf2 :\cf1  Integer\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  HAlign \b of
\par \b0     halCenter\cf2 :
\par \cf1       Result \cf2 :=\cf1  Max\cf2 (\cf1 FClipRect\cf2 .\cf1 Left\cf2 ,\cf1  \cf2 (\cf1 FClipRect\cf2 .\cf1 Left \cf2 +\cf1  FClipRect\cf2 .\cf1 Right \cf2 -\cf1  ATextWidth\cf2 )\cf1  \b div\b0  \cf5 2\cf2 );
\par \cf1     halRight\cf2 :
\par \cf1       Result \cf2 :=\cf1  FClipRect\cf2 .\cf1 Right \cf2 -\cf1  ATextWidth\cf2 ;
\par \cf1   \b else
\par \b0     Result \cf2 :=\cf1  FClipRect\cf2 .\cf1 Left\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKTextBox\cf2 .\cf1 GetVertPos\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  VAlign \b of
\par \b0     valCenter\cf2 :
\par \cf1     \b begin
\par \b0       Process\cf2 (\cf5 0\cf2 ,\cf1  tbfMeasure\cf2 );
\par \cf1       Result \cf2 :=\cf1  Max\cf2 (\cf1 FClipRect\cf2 .\cf1 Top\cf2 ,\cf1  \cf2 (\cf1 FClipRect\cf2 .\cf1 Bottom \cf2 +\cf1  FClipRect\cf2 .\cf1 Top \cf2 -\cf1  FCalcRect\cf2 .\cf1 Top\cf2 )\cf1  \b div\b0  \cf5 2\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     valBottom\cf2 :
\par \cf1     \b begin
\par \b0       Process\cf2 (\cf5 0\cf2 ,\cf1  tbfMeasure\cf2 );
\par \cf1       Result \cf2 :=\cf1  FClipRect\cf2 .\cf1 Bottom \cf2 -\cf1  FCalcRect\cf2 .\cf1 Top\cf2 ;
\par \cf1     \b end
\par \b0   \b else
\par \b0     Result \cf2 :=\cf1  FClipRect\cf2 .\cf1 Top\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKTextBox\cf2 .\cf1 IndexToRect\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  AIndex\cf2 :\cf1  Integer\cf2 ):\cf1  TRect\cf2 ;
\par \cf1\b var
\par \b0   Y\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Initialize\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1   Y \cf2 :=\cf1  GetVertPos\cf2 ;
\par \cf1   FIndex \cf2 :=\cf1  AIndex\cf2 ;
\par \cf1   Process\cf2 (\cf1 Y\cf2 ,\cf1  tbfGetRect\cf2 );
\par \cf1   Result \cf2 :=\cf1  FCalcRect\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 Initialize\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 );
\par \cf1\b begin
\par \b0   FCanvas \cf2 :=\cf1  ACanvas\cf2 ;
\par \cf1   FClipRect \cf2 :=\cf1  ARect\cf2 ;
\par \cf1   InflateRect\cf2 (\cf1 FClipRect\cf2 ,\cf1  \cf2 -\cf1 HPadding\cf2 ,\cf1  \cf2 -\cf1 VPadding\cf2 );
\par \cf1   FFontHeight \cf2 :=\cf1  GetFontHeight\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 Measure\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  \b var\b0  AWidth\cf2 ,\cf1  AHeight\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   Initialize\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1   Process\cf2 (\cf5 0\cf2 ,\cf1  tbfMeasure\cf2 );
\par \cf1   AWidth \cf2 :=\cf1  FCalcRect\cf2 .\cf1 Left\cf2 ;
\par \cf1   AHeight \cf2 :=\cf1  FCalcRect\cf2 .\cf1 Top\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 Process\cf2 (\cf1 Y\cf2 :\cf1  Integer\cf2 ;\cf1  AFunction\cf2 :\cf1  TKTextBoxFunction\cf2 );
\par \cf1\b var
\par \b0   StartEllipsis\cf2 ,\cf1  EndEllipsis\cf2 ,\cf1  PathEllipsis\cf2 :\cf1  Boolean\cf2 ;
\par \cf1   Width\cf2 ,\cf1  EllipsisWidth\cf2 :\cf1  Integer\cf2 ;
\par \cf1   NormalColor\cf2 ,\cf1  NormalBkgnd\cf2 :\cf1  TColor\cf2 ;
\par 
\par \cf1   \b procedure\b0  Measure\cf2 (\cf1 AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );
\par \cf1   \b begin
\par \b0     FCalcRect\cf2 .\cf1 Left \cf2 :=\cf1  Max\cf2 (\cf1 FCalcRect\cf2 .\cf1 Left\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \b procedure\b0  GetIndex\cf2 (\cf1 Y\cf2 :\cf1  Integer\cf2 ;\cf1  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );
\par \cf1   \b var
\par \b0     Index\cf2 ,\cf1  NewIndex\cf2 ,\cf1  X\cf2 ,\cf1  Width\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \b begin
\par \b0     \b if\b0  FIndex \cf2 <\cf1  \cf5 0\cf1  \b then
\par \b0     \b begin
\par \b0       \b if\b0  \b not\b0  \cf2 (\cf1 taIncludePadding \b in\b0  Attributes\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <=\cf1  FCalcRect\cf2 .\cf1 Top\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Top \cf2 <\cf1  Y \cf2 +\cf1  FFontHeight\cf2 )\cf1  \b or
\par \b0         \cf2 (\cf1 taIncludePadding \b in\b0  Attributes\cf2 )\cf1  \b and\b0  \cf2 (
\par \cf1           \cf2 (\cf1 AStart \cf2 =\cf1  \cf5 1\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FClipRect\cf2 .\cf1 Top \cf2 <=\cf1  FCalcRect\cf2 .\cf1 Top\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Top \cf2 <\cf1  Y \cf2 +\cf1  FFontHeight\cf2 )\cf1  \b or
\par \b0           \cf2 (\cf1 AStart \cf2 +\cf1  ALen \cf2 =\cf1  Length\cf2 (\cf1 FText\cf2 )\cf1  \cf2 +\cf1  \cf5 1\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <=\cf1  FCalcRect\cf2 .\cf1 Top\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Top \cf2 <\cf1  FClipRect\cf2 .\cf1 Bottom\cf2 )
\par \cf1         \cf2 )\cf1  \b then
\par \b0       \b begin
\par \b0         Width \cf2 :=\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 ;
\par \cf1         X \cf2 :=\cf1  GetHorzPos\cf2 (\cf1 Width\cf2 );
\par \cf1         \b if\b0  \b not\b0  \cf2 (\cf1 taIncludePadding \b in\b0  Attributes\cf2 )\cf1  \b and\b0  \cf2 (\cf1 X \cf2 <=\cf1  FCalcRect\cf2 .\cf1 Left\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Left \cf2 <\cf1  X \cf2 +\cf1  Width\cf2 )\cf1  \b or
\par \b0           \cf2 (\cf1 taIncludePadding \b in\b0  Attributes\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FClipRect\cf2 .\cf1 Left \cf2 <=\cf1  FCalcRect\cf2 .\cf1 Left\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Left \cf2 <\cf1  FClipRect\cf2 .\cf1 Right\cf2 )\cf1  \b then
\par \b0         \b begin
\par \b0           Index \cf2 :=\cf1  AStart\cf2 ;
\par \cf1           \b while\b0  \cf2 (\cf1 FIndex \cf2 <\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Index \cf2 <=\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  \cf5 1\cf2 )\cf1  \b do
\par \b0           \b begin
\par \b0             NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1             Inc\cf2 (\cf1 X\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1             \b if\b0  FCalcRect\cf2 .\cf1 Left \cf2 <\cf1  X \b then
\par \b0               FIndex \cf2 :=\cf1  Index\cf2 ;
\par \cf1             Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1           \b if\b0  \cf2 (\cf1 taIncludePadding \b in\b0  Attributes\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FIndex \cf2 <\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FCalcRect\cf2 .\cf1 Left \cf2 <\cf1  FClipRect\cf2 .\cf1 Right\cf2 )\cf1  \b then
\par \b0             FIndex \cf2 :=\cf1  Index\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1   \b procedure\b0  GetRect\cf2 (\cf1 Y\cf2 :\cf1  Integer\cf2 ;\cf1  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );
\par \cf1   \b var
\par \b0     Index\cf2 ,\cf1  NewIndex\cf2 ,\cf1  X\cf2 ,\cf1  Width\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \b begin
\par \b0     \b if\b0  \cf2 (\cf1 FIndex \cf2 >=\cf1  AStart\cf2 )\cf1  \b and\b0  \cf2 (\cf1 FIndex \cf2 <=\cf1  ALen\cf2 )\cf1  \b then
\par \b0     \b begin
\par \b0       Index \cf2 :=\cf1  AStart\cf2 ;
\par \cf1       Width \cf2 :=\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 ;
\par \cf1       X \cf2 :=\cf1  GetHorzPos\cf2 (\cf1 Width\cf2 );
\par \cf1       \b while\b0  Index \cf2 <\cf1  FIndex \b do
\par \b0       \b begin
\par \b0         NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1         Inc\cf2 (\cf1 X\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1         Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1       FCalcRect \cf2 :=\cf1  Rect\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 ,\cf1  X \cf2 +\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 ,\cf1  Y \cf2 +\cf1  FFontHeight\cf2 );
\par \cf1     \b end
\par \b0   \b end\b0\cf2 ;
\par 
\par \cf1   \b procedure\b0  Draw\cf2 (\cf1 Y\cf2 :\cf1  Integer\cf2 ;\cf1  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );
\par \cf1   \b var
\par \b0     DrawEllipsis\cf2 ,\cf1  DrawFileName\cf2 ,\cf1  SetNormalColors\cf2 ,\cf1  SetSelectionColors\cf2 :\cf1  Boolean\cf2 ;
\par \cf1     AWidth\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex\cf2 ,\cf1  SlashPos\cf2 ,\cf1  FileNameLen\cf2 ,\cf1  EllipsisMaxX\cf2 ,\cf1  X\cf2 :\cf1  Integer\cf2 ;
\par \cf1     S\cf2 :\cf1  TKString\cf2 ;
\par \cf1   \b begin
\par \b0     \b if\b0  \cf2 (\cf1 Y \cf2 >=\cf1  FClipRect\cf2 .\cf1 Top \cf2 -\cf1  FFontHeight\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Y \cf2 <=\cf1  FClipRect\cf2 .\cf1 Bottom\cf2 )\cf1  \b then
\par \b0     \b begin
\par \b0       DrawEllipsis \cf2 :=\cf1  False\cf2 ;
\par \cf1       DrawFileName \cf2 :=\cf1  False\cf2 ;
\par \cf1       SlashPos \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1       FileNameLen \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1       \b if\b0  \cf2 (\cf1 StartEllipsis \b or\b0  EndEllipsis \b or\b0  PathEllipsis\cf2 )\cf1  \b and\b0  \cf2 (\cf1 ALen \cf2 >\cf1  \cf5 1\cf2 )\cf1  \b then
\par \b0       \b begin
\par \b0         AWidth \cf2 :=\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 ;
\par \cf1         \b if\b0  AWidth \cf2 >\cf1  Width \b then
\par \b0         \b begin
\par \b0           AWidth \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1           Index \cf2 :=\cf1  AStart\cf2 ;
\par \cf1           \b if\b0  EndEllipsis \b or\b0  StartEllipsis \b then
\par \b0           \b begin
\par \b0             EllipsisMaxX \cf2 :=\cf1  Width \cf2 -\cf1  EllipsisWidth\cf2 ;
\par \cf1             \b if\b0  EndEllipsis \b then
\par \b0             \b begin
\par \b0               \b while\b0  Index \cf2 <=\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  \cf5 1\cf1  \b do
\par \b0               \b begin
\par \b0                 NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1                 Inc\cf2 (\cf1 AWidth\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1                 \b if\b0  \cf2 (\cf1 AWidth \cf2 >=\cf1  EllipsisMaxX\cf2 )\cf1  \b and\b0  \cf2 (\cf1 Index \cf2 >\cf1  AStart\cf2 )\cf1  \b then
\par \b0                   Break
\par                 \b else
\par \b0                   Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1               \b end\b0\cf2 ;
\par \cf1               ALen \cf2 :=\cf1  Index \cf2 -\cf1  AStart\cf2 ;
\par \cf1             \b end\b0  \b else
\par \b0             \b begin
\par \b0               Index \cf2 :=\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  \cf5 1\cf2 ;
\par \cf1               \b while\b0  Index \cf2 >\cf1  AStart \b do
\par \b0               \b begin
\par \b0                 NewIndex \cf2 :=\cf1  StrPreviousCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1                 Inc\cf2 (\cf1 AWidth\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  Index \cf2 -\cf1  NewIndex\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1                 \b if\b0  AWidth \cf2 >=\cf1  EllipsisMaxX \b then
\par \b0                   Break
\par                 \b else
\par \b0                   Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1               \b end\b0\cf2 ;
\par \cf1               \b if\b0  Index \cf2 =\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  \cf5 1\cf1  \b then
\par \b0               \b begin
\par \b0                 AStart \cf2 :=\cf1  Index\cf2 ;
\par \cf1                 ALen \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1               \b end\b0  \b else
\par \b0               \b begin
\par \b0                 Dec\cf2 (\cf1 ALen\cf2 ,\cf1  Index \cf2 -\cf1  AStart\cf2 );
\par \cf1                 AStart \cf2 :=\cf1  Index \cf2 +\cf1  \cf5 1\cf2 ;
\par \cf1               \b end\b0\cf2 ;
\par \cf1             \b end\b0\cf2 ;
\par \cf1             DrawEllipsis \cf2 :=\cf1  True\cf2 ;
\par \cf1           \b end
\par \b0           \b else\b0  \b if\b0  PathEllipsis \b then
\par \b0           \b begin
\par \b0             SlashPos \cf2 :=\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  \cf5 1\cf2 ;
\par \cf1             \b while\b0  \cf2 (\cf1 SlashPos \cf2 >\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \b not\b0  CharInSetEx\cf2 (\cf1 FText\cf2 [\cf1 SlashPos\cf2 ],\cf1  \cf2 [\cf4 '/'\cf2 ,\cf1  \cf4 '\\'\cf2 ])\cf1  \b do
\par \b0               Dec\cf2 (\cf1 SlashPos\cf2 );
\par \cf1             Dec\cf2 (\cf1 SlashPos\cf2 );
\par \cf1             \b if\b0  SlashPos \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0             \b begin
\par \b0               DrawEllipsis \cf2 :=\cf1  True\cf2 ;
\par \cf1               DrawFileName \cf2 :=\cf1  True\cf2 ;
\par \cf1               FileNameLen \cf2 :=\cf1  AStart \cf2 +\cf1  ALen \cf2 -\cf1  SlashPos\cf2 ;
\par \cf1               EllipsisMaxX \cf2 :=\cf1  Width \cf2 -\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  SlashPos\cf2 ,\cf1  FileNameLen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx \cf2 -\cf1  EllipsisWidth\cf2 ;
\par \cf1               \b while\b0  \cf2 (\cf1 Index \cf2 <=\cf1  SlashPos\cf2 )\cf1  \b do
\par \b0               \b begin
\par \b0                 NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1                 Inc\cf2 (\cf1 AWidth\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1                 \b if\b0  AWidth \cf2 >=\cf1  EllipsisMaxX \b then
\par \b0                   Break
\par                 \b else
\par \b0                   Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1               \b end\b0\cf2 ;
\par \cf1               ALen \cf2 :=\cf1  Index \cf2 -\cf1  AStart\cf2 ;
\par \cf1             \b end\b0\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       \b if\b0  DrawEllipsis \b then
\par \b0       \b begin
\par \b0         \b if\b0  DrawFileName \b then
\par \b0           S \cf2 :=\cf1  Copy\cf2 (\cf1 FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 )\cf1  \cf2 +\cf1  cEllipsis \cf2 +\cf1  Copy\cf2 (\cf1 FText\cf2 ,\cf1  AStart \cf2 +\cf1  SlashPos\cf2 ,\cf1  FileNameLen\cf2 )
\par \cf1         \b else\b0  \b if\b0  EndEllipsis \b then
\par \b0           S \cf2 :=\cf1  Copy\cf2 (\cf1 FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 )\cf1  \cf2 +\cf1  cEllipsis
\par         \b else
\par \b0           S \cf2 :=\cf1  cEllipsis \cf2 +\cf1  Copy\cf2 (\cf1 FText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 );
\par \cf1         AStart \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1         ALen \cf2 :=\cf1  Length\cf2 (\cf1 S\cf2 );
\par \cf1       \b end\b0  \b else
\par \b0         S \cf2 :=\cf1  FText\cf2 ;
\par \cf1       X \cf2 :=\cf1  GetHorzPos\cf2 (\cf1 TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  S\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1       \b if\b0  DrawEllipsis \b or\b0  \cf2 (\cf1 SelStart \cf2 =\cf1  SelEnd\cf2 )\cf1  \b then
\par \b0         TextOutput\cf2 (\cf1 FCanvas\cf2 ,\cf1  X\cf2 ,\cf1  Y\cf2 ,\cf1  S\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 )
\par \cf1       \b else
\par \b0       \b begin
\par \b0         AWidth \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1         Index \cf2 :=\cf1  AStart\cf2 ;
\par \cf1         SlashPos \cf2 :=\cf1  Index\cf2 ;\cf1  \cf0\i // reuse
\par \i0\cf1         \b while\b0  \cf2 (\cf1 Index \cf2 <=\cf1  AStart \cf2 +\cf1  ALen\cf2 )\cf1  \b do
\par \b0         \b begin
\par \b0           DrawFileName \cf2 :=\cf1  False\cf2 ;\cf1   \cf0\i // reuse
\par \i0\cf1           SetNormalColors \cf2 :=\cf1  False\cf2 ;
\par \cf1           SetSelectionColors \cf2 :=\cf1  False\cf2 ;
\par \cf1           \b if\b0  Index \cf2 =\cf1  SelStart \b then
\par \b0           \b begin
\par \b0             DrawFileName \cf2 :=\cf1  True\cf2 ;
\par \cf1             SetSelectionColors \cf2 :=\cf1  True\cf2 ;
\par \cf1           \b end
\par \b0           \b else\b0  \b if\b0  Index \cf2 =\cf1  SelEnd \b then
\par \b0           \b begin
\par \b0             DrawFileName \cf2 :=\cf1  True\cf2 ;
\par \cf1             SetNormalColors \cf2 :=\cf1  True\cf2 ;
\par \cf1           \b end
\par \b0           \b else\b0  \b if\b0  Index \cf2 =\cf1  AStart \cf2 +\cf1  ALen \b then
\par \b0           \b begin
\par \b0             DrawFileName \cf2 :=\cf1  True\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1           \b if\b0  DrawFileName \b then
\par \b0           \b begin
\par \b0             \b if\b0  Index \cf2 >\cf1  SlashPos \b then
\par \b0             \b begin
\par \b0               \b if\b0  SetNormalColors \b then
\par \b0                 DrawFilledRectangle\cf2 (\cf1 FCanvas\cf2 ,\cf1  Rect\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 ,\cf1  X \cf2 +\cf1  AWidth\cf2 ,\cf1  Y \cf2 +\cf1  FFontHeight\cf2 ),\cf1  FBackColor\cf2 );
\par \cf1               \b if\b0  \b not\b0  \cf2 (\cf1 taFillText \b in\b0  Attributes\cf2 )\cf1  \b then
\par \b0                 SetBkMode\cf2 (\cf1 FCanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TRANSPARENT\cf2 );
\par \cf1               TextOutput\cf2 (\cf1 FCanvas\cf2 ,\cf1  X\cf2 ,\cf1  Y\cf2 ,\cf1  S\cf2 ,\cf1  SlashPos\cf2 ,\cf1  Index \cf2 -\cf1  SlashPos\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 );
\par \cf1             \b end\b0\cf2 ;
\par \cf1             Inc\cf2 (\cf1 X\cf2 ,\cf1  AWidth\cf2 );
\par \cf1             AWidth \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1             SlashPos \cf2 :=\cf1  Index\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1           \b if\b0  Index \cf2 <\cf1  AStart \cf2 +\cf1  ALen \b then
\par \b0           \b begin
\par \b0             NewIndex \cf2 :=\cf1  StrNextCharIndex\cf2 (\cf1 FText\cf2 ,\cf1  Index\cf2 );
\par \cf1             Inc\cf2 (\cf1 AWidth\cf2 ,\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  Index\cf2 ,\cf1  NewIndex \cf2 -\cf1  Index\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 ).\cf1 cx\cf2 );
\par \cf1             Index \cf2 :=\cf1  NewIndex\cf2 ;
\par \cf1           \b end\b0  \b else
\par \b0             Inc\cf2 (\cf1 Index\cf2 );
\par \cf1           \b if\b0  SetNormalColors \b then
\par \b0           \b begin
\par \b0             FCanvas\cf2 .\cf1 Font\cf2 .\cf1 Color \cf2 :=\cf1  NormalColor\cf2 ;
\par \cf1             FCanvas\cf2 .\cf1 Brush\cf2 .\cf1 Color \cf2 :=\cf1  NormalBkgnd\cf2 ;
\par \cf1           \b end
\par \b0           \b else\b0  \b if\b0  SetSelectionColors \b then
\par \b0           \b begin
\par \b0             FCanvas\cf2 .\cf1 Font\cf2 .\cf1 Color \cf2 :=\cf1  SelColor\cf2 ;
\par \cf1             FCanvas\cf2 .\cf1 Brush\cf2 .\cf1 Color \cf2 :=\cf1  SelBkgnd\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf1\b var
\par \b0   I\cf2 ,\cf1  Index\cf2 ,\cf1  TextLen\cf2 ,\cf1  LineBegin\cf2 ,\cf1  LineBreaks\cf2 ,\cf1  Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 :\cf1  Integer\cf2 ;
\par \cf1   WordBreak\cf2 ,\cf1  LineBreak\cf2 ,\cf1  WhiteSpace\cf2 ,\cf1  PrevWhiteSpace\cf2 ,\cf1  FirstWord\cf2 ,
\par \cf1   WasLineBreak\cf2 ,\cf1  WrapText\cf2 :\cf1  Boolean\cf2 ;
\par \cf1   Size\cf2 :\cf1  TSize\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  AFunction \b of
\par \b0     tbfMeasure\cf2 :\cf1  FCalcRect \cf2 :=\cf1  CreateEmptyRect\cf2 ;
\par \cf1     tbfGetIndex\cf2 :\cf1  FIndex \cf2 :=\cf1  \cf2 -\cf5 1\cf2 ;
\par \cf1     tbfGetRect\cf2 :\cf1  FCalcRect \cf2 :=\cf1  CreateEmptyRect\cf2 ;
\par \cf1     tbfDraw\cf2 :\cf1  \cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   Vert \cf2 :=\cf1  Y\cf2 ;
\par \cf1   \b if\b0  FText \cf2 <>\cf1  \cf4 ''\cf1  \b then
\par \b0   \b begin
\par \b0     LineBegin \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1     LineBreaks \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1     TextLen \cf2 :=\cf1  Length\cf2 (\cf1 FText\cf2 );
\par \cf1     Width \cf2 :=\cf1  FClipRect\cf2 .\cf1 Right \cf2 -\cf1  FClipRect\cf2 .\cf1 Left\cf2 ;
\par \cf1     WordBreak \cf2 :=\cf1  taWordBreak \b in\b0  Attributes\cf2 ;
\par \cf1     LineBreak \cf2 :=\cf1  taLineBreak \b in\b0  Attributes\cf2 ;
\par \cf1     WrapText \cf2 :=\cf1  taWrapText \b in\b0  Attributes\cf2 ;\cf1  \cf0\i //JR:20091229
\par \i0\cf1     \b if\b0  AFunction \cf2 =\cf1  tbfDraw \b then
\par \b0     \b begin
\par \b0       StartEllipsis \cf2 :=\cf1  taStartEllipsis \b in\b0  Attributes\cf2 ;
\par \cf1       EndEllipsis \cf2 :=\cf1  taEndEllipsis \b in\b0  Attributes\cf2 ;
\par \cf1       PathEllipsis \cf2 :=\cf1  taPathEllipsis \b in\b0  Attributes\cf2 ;
\par \cf1       EllipsisWidth \cf2 :=\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  cEllipsis\cf2 ,\cf1  \cf5 1\cf2 ,\cf1  Length\cf2 (\cf1 cEllipsis\cf2 )).\cf1 cx\cf2 ;
\par \cf1       NormalColor \cf2 :=\cf1  FCanvas\cf2 .\cf1 Font\cf2 .\cf1 Color\cf2 ;
\par \cf1       NormalBkgnd \cf2 :=\cf1  FCanvas\cf2 .\cf1 Brush\cf2 .\cf1 Color\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  WordBreak \b or\b0  LineBreak \b then
\par \b0     \b begin
\par \b0       I \cf2 :=\cf1  LineBegin\cf2 ;
\par \cf1       Index \cf2 :=\cf1  LineBegin\cf2 ;
\par \cf1       WhiteSpace \cf2 :=\cf1  True\cf2 ;
\par \cf1       FirstWord \cf2 :=\cf1  True\cf2 ;
\par \cf1       WasLineBreak \cf2 :=\cf1  False\cf2 ;
\par \cf1       \b while\b0  I \cf2 <=\cf1  TextLen \cf2 +\cf1  \cf5 1\cf1  \b do
\par \b0       \b begin
\par \b0         PrevWhiteSpace \cf2 :=\cf1  WhiteSpace\cf2 ;
\par \cf1         WhiteSpace \cf2 :=\cf1  CharInSetEx\cf2 (\cf1 FText\cf2 [\cf1 I\cf2 ],\cf1  cWordBreaks \cf2 +\cf1  cLineBreaks\cf2 );
\par \cf1         \b if\b0  \cf2 (\cf1\b not\b0  PrevWhiteSpace \b and\b0  WhiteSpace \b and\b0  \cf2 (\cf1 I \cf2 >\cf1  LineBegin\cf2 ))
\par \cf1           \b or\b0  \cf2 (\cf1\b not\b0  PrevWhiteSpace \b and\b0  WrapText \b and\b0  \cf2 (\cf1 I \cf2 >\cf1  LineBegin\cf2 ))\cf1  \b then\b0  \cf0\i //JR:20091229
\par \i0\cf1         \b begin
\par \b0           \b if\b0  \cf2 (\cf1 WordBreak \b or\b0  WrapText\cf2 )\cf1  \b and\b0  \cf2 (\cf1 LineBreaks \cf2 =\cf1  \cf5 0\cf2 )\cf1  \b and\b0  \b not\b0  FirstWord \b then
\par \b0           \b begin
\par \b0             TrimStart \cf2 :=\cf1  LineBegin\cf2 ;
\par \cf1             TrimLen \cf2 :=\cf1  I \cf2 -\cf1  LineBegin\cf2 ;
\par \cf1             TextTrim\cf2 (\cf1 FText\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1             Size \cf2 :=\cf1  TextExtent\cf2 (\cf1 FCanvas\cf2 ,\cf1  FText\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 ,\cf1  FHasTabs\cf2 ,\cf1  FSpacesForTab\cf2 );
\par \cf1             \b if\b0  Size\cf2 .\cf1 cx \cf2 >\cf1  Width \b then
\par \b0               Inc\cf2 (\cf1 LineBreaks\cf2 );
\par \cf1           \b end\b0\cf2 ;
\par \cf1           \b if\b0  LineBreaks \cf2 >\cf1  \cf5 0\cf1  \b then
\par \b0           \b begin
\par \b0             \b if\b0  Index \cf2 >\cf1  LineBegin \b then
\par \b0             \b begin
\par \b0               TrimStart \cf2 :=\cf1  LineBegin\cf2 ;
\par \cf1               TrimLen \cf2 :=\cf1  Index \cf2 -\cf1  LineBegin\cf2 ;
\par \cf1               TextTrim\cf2 (\cf1 FText\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1               \b case\b0  AFunction \b of
\par \b0                 tbfMeasure\cf2 :\cf1  Measure\cf2 (\cf1 TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1                 tbfGetIndex\cf2 :\cf1  GetIndex\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1                 tbfGetRect\cf2 :\cf1  GetRect\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1                 tbfDraw\cf2 :\cf1  Draw\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1               \b end\b0\cf2 ;
\par \cf1               LineBegin \cf2 :=\cf1  Index\cf2 ;
\par \cf1             \b end\b0\cf2 ;
\par \cf1             Inc\cf2 (\cf1 Vert\cf2 ,\cf1  FFontHeight \cf2 *\cf1  LineBreaks\cf2 );
\par \cf1             LineBreaks \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1           \b end\b0\cf2 ;
\par \cf1           Index \cf2 :=\cf1  I\cf2 ;
\par \cf1           FirstWord \cf2 :=\cf1  False\cf2 ;
\par \cf1         \b end\b0\cf2 ;
\par \cf1         \b if\b0  LineBreak \b then
\par \b0           \b if\b0  CharInSetEx\cf2 (\cf1 FText\cf2 [\cf1 I\cf2 ],\cf1  cLineBreaks\cf2 )\cf1  \b then
\par \b0           \b begin
\par \b0             \b if\b0  \b not\b0  WasLineBreak \b then
\par \b0             \b begin
\par \b0               Inc\cf2 (\cf1 LineBreaks\cf2 );
\par \cf1               WasLineBreak \cf2 :=\cf1  True\cf2 ;
\par \cf1             \b end\b0\cf2 ;
\par \cf1           \b end\b0  \b else
\par \b0             WasLineBreak \cf2 :=\cf1  False\cf2 ;
\par \cf1         Inc\cf2 (\cf1 I\cf2 );
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  LineBegin \cf2 <=\cf1  TextLen \b then
\par \b0     \b begin
\par \b0       TrimStart \cf2 :=\cf1  LineBegin\cf2 ;
\par \cf1       TrimLen \cf2 :=\cf1  TextLen \cf2 -\cf1  LineBegin \cf2 +\cf1  \cf5 1\cf2 ;
\par \cf1       TextTrim\cf2 (\cf1 FText\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1       \b case\b0  AFunction \b of
\par \b0         tbfMeasure\cf2 :\cf1  Measure\cf2 (\cf1 TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1         tbfGetIndex\cf2 :\cf1  GetIndex\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1         tbfGetRect\cf2 :\cf1  GetRect\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 );
\par \cf1         tbfDraw\cf2 :\cf1  Draw\cf2 (\cf1 Vert\cf2 ,\cf1  TrimStart\cf2 ,\cf1  TrimLen\cf2 )
\par \cf1       \b end\b0\cf2 ;
\par \cf1       Inc\cf2 (\cf1 Vert\cf2 ,\cf1  FFontHeight \cf2 *\cf1  \cf2 (\cf5 1\cf1  \cf2 +\cf1  LineBreaks\cf2 ));
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1   \b case\b0  AFunction \b of
\par \b0     tbfMeasure\cf2 :
\par \cf1     \b begin
\par \b0       \b if\b0  FText \cf2 =\cf1  \cf4 ''\cf1  \b then
\par \b0         FCalcRect\cf2 .\cf1 Top \cf2 :=\cf1  FFontHeight
\par       \b else
\par \b0         FCalcRect\cf2 .\cf1 Top \cf2 :=\cf1  Vert \cf2 -\cf1  Y\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     tbfGetIndex\cf2 :\cf1  \cf2 ;
\par \cf1     tbfGetRect\cf2 :\cf1  \b if\b0  FText \cf2 =\cf1  \cf4 ''\cf1  \b then
\par \b0     \b begin
\par \b0       I \cf2 :=\cf1  GetHorzPos\cf2 (\cf5 0\cf2 );
\par \cf1       FCalcRect \cf2 :=\cf1  Rect\cf2 (\cf1 I\cf2 ,\cf1  Y\cf2 ,\cf1  I\cf2 ,\cf1  Y \cf2 +\cf1  FFontHeight\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     tbfDraw\cf2 :\cf1  \cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 SetText\cf2 (\cf1\b const\b0  AText\cf2 :\cf1  TKString\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  AText \cf2 <>\cf1  FText \b then
\par \b0   \b begin
\par \b0     FText \cf2 :=\cf1  AText\cf2 ;
\par \cf1     FHasTabs \cf2 :=\cf1  Pos\cf2 (\cf1 cTAB\cf2 ,\cf1  FText\cf2 )\cf1  \cf2 >\cf1  \cf5 0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b function\b0  TKTextBox\cf2 .\cf1 PointToIndex\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;\cf1  APoint\cf2 :\cf1  TPoint\cf2 ):\cf1  Integer\cf2 ;
\par \cf1\b var
\par \b0   Y\cf2 :\cf1  Integer\cf2 ;
\par \cf1\b begin
\par \b0   Initialize\cf2 (\cf1 ACanvas\cf2 ,\cf1  ARect\cf2 );
\par \cf1   Y \cf2 :=\cf1  GetVertPos\cf2 ;
\par \cf1   FCalcRect\cf2 .\cf1 TopLeft \cf2 :=\cf1  APoint\cf2 ;
\par \cf1   Process\cf2 (\cf1 Y\cf2 ,\cf1  tbfGetIndex\cf2 );
\par \cf1   Result \cf2 :=\cf1  FIndex\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b class\b0  \b function\b0  TKTextBox\cf2 .\cf1 TextExtent\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;
\par \cf1   AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 ;\cf1  AExpandTabs\cf2 :\cf1  Boolean\cf2 ;\cf1  ASpacesForTab\cf2 :\cf1  Integer\cf2 ):\cf1  TSize\cf2 ;
\par \cf1\b var
\par \b0   S\cf2 :\cf1  TKString\cf2 ;
\par \cf1   TextPtr\cf2 :\cf1  PKText\cf2 ;
\par \cf1\b begin
\par \b0   S \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1   \b if\b0  AExpandTabs \b then
\par \b0   \b begin
\par \b0     S \cf2 :=\cf1  Copy\cf2 (\cf1 AText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 );
\par \cf1     ConvertTabsToSpaces\cf2 (\cf1 S\cf2 ,\cf1  ASpacesForTab\cf2 );
\par \cf1     TextPtr \cf2 :=\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ];
\par \cf1     ALen \cf2 :=\cf1  Length\cf2 (\cf1 S\cf2 );
\par \cf1   \b end\b0  \b else
\par \b0     TextPtr \cf2 :=\cf1  \cf2 @\cf1 AText\cf2 [\cf1 AStart\cf2 ];
\par \cf1\i \{$IFDEF STRING_IS_UNICODE\}
\par \i0  \i \{$IFDEF FPC\}
\par \i0   \i \{$IFDEF USE_CANVAS_METHODS\}
\par \i0   \b if\b0  \b not\b0  AExpandTabs \b then
\par \b0     S \cf2 :=\cf1  Copy\cf2 (\cf1 AText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 );
\par \cf1   Result \cf2 :=\cf1  ACanvas\cf2 .\cf1 TextExtent\cf2 (\cf1 S\cf2 );\cf1  \cf0\i // little slower but more secure in Lazarus
\par \i0\cf1   \i \{$ELSE\}
\par \i0   GetTextExtentPoint32\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 ,\cf1  Result\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \i0  \i \{$ELSE\}
\par \i0   GetTextExtentPoint32\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 ,\cf1  Result\cf2 );
\par \cf1  \i \{$ENDIF\}
\par \{$ELSE\}
\par \i0   GetTextExtentPoint32W\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 ,\cf1  Result\cf2 );
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b class\b0  \b procedure\b0  TKTextBox\cf2 .\cf1 TextOutput\cf2 (\cf1 ACanvas\cf2 :\cf1  TCanvas\cf2 ;\cf1  X\cf2 ,\cf1  Y\cf2 :\cf1  Integer\cf2 ;
\par \cf1   \b const\b0  AText\cf2 :\cf1  TKString\cf2 ;\cf1  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 ;\cf1  AExpandTabs\cf2 :\cf1  Boolean\cf2 ;\cf1  ASpacesForTab\cf2 :\cf1  Integer\cf2 );
\par \cf1\b var
\par \b0   S\cf2 :\cf1  TKString\cf2 ;
\par \cf1   TextPtr\cf2 :\cf1  PKText\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  AExpandTabs \b then
\par \b0   \b begin
\par \b0     S \cf2 :=\cf1  Copy\cf2 (\cf1 AText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 );
\par \cf1     ConvertTabsToSpaces\cf2 (\cf1 S\cf2 ,\cf1  ASpacesForTab\cf2 );
\par \cf1     TextPtr \cf2 :=\cf1  \cf2 @\cf1 S\cf2 [\cf5 1\cf2 ];
\par \cf1     ALen \cf2 :=\cf1  Length\cf2 (\cf1 S\cf2 );
\par \cf1   \b end\b0  \b else
\par \b0   \b begin
\par \b0     TextPtr \cf2 :=\cf1  \cf2 @\cf1 AText\cf2 [\cf1 AStart\cf2 ];
\par \cf1     S \cf2 :=\cf1  AText\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\i \{$IFDEF STRING_IS_UNICODE\}
\par \i0  \i \{$IFDEF FPC\}
\par \i0   \i \{$IFDEF USE_CANVAS_METHODS\}
\par \i0   \b if\b0  \b not\b0  AExpandTabs \b then
\par \b0     S \cf2 :=\cf1  Copy\cf2 (\cf1 S\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 );
\par \cf1   ACanvas\cf2 .\cf1 TextOut\cf2 (\cf1 X\cf2 ,\cf1  Y\cf2 ,\cf1  S\cf2 );\cf1  \cf0\i // little slower but more secure in Lazarus
\par \i0\cf1   \i \{$ELSE\}
\par \i0   TextOut\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  X\cf2 ,\cf1  Y\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \i0  \i \{$ELSE\}
\par \i0   TextOut\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  X\cf2 ,\cf1  Y\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 );
\par \cf1  \i \{$ENDIF\}
\par \{$ELSE\}
\par \i0   TextOutW\cf2 (\cf1 ACanvas\cf2 .\cf1 Handle\cf2 ,\cf1  X\cf2 ,\cf1  Y\cf2 ,\cf1  TextPtr\cf2 ,\cf1  ALen\cf2 );
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextBox\cf2 .\cf1 TextTrim\cf2 (\cf1\b const\b0  AText\cf2 :\cf1  TKString\cf2 ;\cf1  \b var\b0  AStart\cf2 ,\cf1  ALen\cf2 :\cf1  Integer\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  taLineBreak \b in\b0  Attributes \b then
\par \b0     TrimWhiteSpaces\cf2 (\cf1 AText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  cLineBreaks\cf2 );
\par \cf1   \b if\b0  taTrimWhiteSpaces \b in\b0  Attributes \b then
\par \b0     TrimWhiteSpaces\cf2 (\cf1 AText\cf2 ,\cf1  AStart\cf2 ,\cf1  ALen\cf2 ,\cf1  cWordBreaks\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKDragWindow \}
\par 
\par \cf1 \{$IFDEF USE_WINAPI\}
\par \i0\b const
\par \b0   cLayeredWndClass \cf2 =\cf1  \cf4 'KControls drag window'\cf2 ;
\par 
\par \cf1\b function\b0  DragWndProc\cf2 (\cf1 Window\cf2 :\cf1  HWnd\cf2 ;\cf1  Msg\cf2 ,\cf1  WParam\cf2 ,\cf1  LParam\cf2 :\cf1  Longint\cf2 ):\cf1  Longint\cf2 ;\cf1  \b stdcall\b0\cf2 ;
\par \cf1\b var
\par \b0   DC\cf2 :\cf1  HDC\cf2 ;
\par \cf1   PS\cf2 :\cf1  TPaintStruct\cf2 ;
\par \cf1   AWindow\cf2 :\cf1  TKDragWindow\cf2 ;
\par \cf1\b begin
\par \b0   \b case\b0  Msg \b of
\par \b0     WM_PAINT\cf2 :
\par \cf1     \b begin
\par \b0       AWindow \cf2 :=\cf1  TKDragWindow\cf2 (\cf1 GetWindowLong\cf2 (\cf1 Window\cf2 ,\cf1  GWL_USERDATA\cf2 ));
\par \cf1       \b if\b0  \cf2 (\cf1 AWindow \cf2 <>\cf1  \b nil\b0\cf2 )\cf1  \b and\b0  AWindow\cf2 .\cf1 BitmapFilled \b then
\par \b0       \b begin
\par \b0         \b if\b0  wParam \cf2 =\cf1  \cf5 0\cf1  \b then
\par \b0           DC \cf2 :=\cf1  BeginPaint\cf2 (\cf1 Window\cf2 ,\cf1  PS\cf2 )
\par \cf1         \b else
\par \b0           DC \cf2 :=\cf1  wParam\cf2 ;
\par \cf1         \b try
\par \b0           BitBlt\cf2 (\cf1 DC\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  AWindow\cf2 .\cf1 Bitmap\cf2 .\cf1 Width\cf2 ,\cf1  AWindow\cf2 .\cf1 Bitmap\cf2 .\cf1 Height\cf2 ,
\par \cf1             AWindow\cf2 .\cf1 Bitmap\cf2 .\cf1 Canvas\cf2 .\cf1 Handle\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  SRCCOPY\cf2 );
\par \cf1         \b finally
\par \b0           \b if\b0  wParam \cf2 =\cf1  \cf5 0\cf1  \b then\b0  EndPaint\cf2 (\cf1 Window\cf2 ,\cf1  PS\cf2 );
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1       Result \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b else
\par \b0     Result \cf2 :=\cf1  DefWindowProc\cf2 (\cf1 Window\cf2 ,\cf1  Msg\cf2 ,\cf1  WParam\cf2 ,\cf1  LParam\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$ELSE\}
\par 
\par \i0\b type
\par 
\par \b0   \cf0\i \{ TKDragForm \}
\par 
\par \i0\cf1   TKDragForm \cf2 =\cf1  \b class\b0\cf2 (\cf1 THintWindow\cf2 )
\par \cf1   \b private
\par \b0     FWindow\cf2 :\cf1  TKDragWindow\cf2 ;
\par \cf1     \b procedure\b0  WMEraseBkGnd\cf2 (\cf1\b var\b0  Msg\cf2 :\cf1  TLMessage\cf2 );\cf1  \b message\b0  LM_ERASEBKGND\cf2 ;
\par \cf1   \b protected
\par \b0     \b procedure\b0  Paint\cf2 ;\cf1  \b override\b0\cf2 ;
\par \cf1   \b public
\par \b0     \b constructor\b0  CreateDragForm\cf2 (\cf1 AWindow\cf2 :\cf1  TKDragWindow\cf2 );
\par \cf1   \b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKDragForm \}
\par 
\par \i0\cf1\b constructor\b0  TKDragForm\cf2 .\cf1 CreateDragForm\cf2 (\cf1 AWindow\cf2 :\cf1  TKDragWindow\cf2 );
\par \cf1\b begin
\par \b0   \b inherited\b0  Create\cf2 (\cf1\b nil\b0\cf2 );
\par \cf1   FWindow \cf2 :=\cf1  AWindow\cf2 ;
\par \cf1   ShowInTaskBar \cf2 :=\cf1  stNever\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKDragForm\cf2 .\cf1 Paint\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  FWindow\cf2 .\cf1 Active \b and\b0  FWindow\cf2 .\cf1 BitmapFilled \b then
\par \b0     Canvas\cf2 .\cf1 Draw\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  FWindow\cf2 .\cf1 FBitmap\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKDragForm\cf2 .\cf1 WMEraseBkGnd\cf2 (\cf1\b var\b0  Msg\cf2 :\cf1  TLMessage\cf2 );
\par \cf1\b begin
\par \b0   Msg\cf2 .\cf1 Result \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$ENDIF\}
\par 
\par \i0\b constructor\b0  TKDragWindow\cf2 .\cf1 Create\cf2 ;
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0\b var
\par \b0   Cls\cf2 :\cf1  Windows\cf2 .\cf1 TWndClass\cf2 ;
\par \cf1   ExStyle\cf2 :\cf1  Cardinal\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FActive \cf2 :=\cf1  False\cf2 ;
\par \cf1   FBitmap \cf2 :=\cf1  TKAlphaBitmap\cf2 .\cf1 Create\cf2 ;
\par \cf1   FInitialPos \cf2 :=\cf1  CreateEmptyPoint\cf2 ;
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0   FUpdateLayeredWindow \cf2 :=\cf1  GetProcAddress\cf2 (\cf1 GetModuleHandle\cf2 (\cf4 'user32.dll'\cf2 ),\cf1  \cf4 'UpdateLayeredWindow'\cf2 );
\par \cf1   FLayered \cf2 :=\cf1  Assigned\cf2 (\cf1 FUpdateLayeredWindow\cf2 );
\par \cf1   Cls\cf2 .\cf1 style \cf2 :=\cf1  CS_SAVEBITS\cf2 ;
\par \cf1   Cls\cf2 .\cf1 lpfnWndProc \cf2 :=\cf1  \cf2 @\cf1 DragWndProc\cf2 ;
\par \cf1   Cls\cf2 .\cf1 cbClsExtra \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 cbWndExtra \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 hInstance \cf2 :=\cf1  HInstance\cf2 ;
\par \cf1   Cls\cf2 .\cf1 hIcon \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 hCursor \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 hbrBackground \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 lpszMenuName \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1   Cls\cf2 .\cf1 lpszClassName \cf2 :=\cf1  cLayeredWndClass\cf2 ;
\par \cf1   Windows\cf2 .\cf1 RegisterClass\cf2 (\cf1 Cls\cf2 );
\par \cf1   ExStyle \cf2 :=\cf1  WS_EX_TOOLWINDOW \b or\b0  WS_EX_TOPMOST\cf2 ;
\par \cf1   \b if\b0  FLayered \b then
\par \b0     ExStyle \cf2 :=\cf1  ExStyle \b or\b0  WS_EX_LAYERED \b or\b0  WS_EX_TRANSPARENT\cf2 ;
\par \cf1   FWindow \cf2 :=\cf1  CreateWindowEx\cf2 (\cf1 ExStyle\cf2 ,\cf1  cLayeredWndClass\cf2 ,\cf1  \cf4 ''\cf2 ,\cf1  WS_POPUP\cf2 ,
\par \cf1     Integer\cf2 (\cf1 CW_USEDEFAULT\cf2 ),\cf1  Integer\cf2 (\cf1 CW_USEDEFAULT\cf2 ),\cf1  Integer\cf2 (\cf1 CW_USEDEFAULT\cf2 ),
\par \cf1     Integer\cf2 (\cf1 CW_USEDEFAULT\cf2 ),\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  HInstance\cf2 ,\cf1  \b nil\b0\cf2 );
\par \cf1   Windows\cf2 .\cf1 SetWindowLong\cf2 (\cf1 FWindow\cf2 ,\cf1  GWL_USERDATA\cf2 ,\cf1  Integer\cf2 (\cf1 Self\cf2 ));
\par \cf1\i \{$ELSE\}
\par \i0   FDragForm \cf2 :=\cf1  TKDragForm\cf2 .\cf1 CreateDragForm\cf2 (\cf1 Self\cf2 );
\par \cf1   FLayered \cf2 :=\cf1  False\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b destructor\b0  TKDragWindow\cf2 .\cf1 Destroy\cf2 ;
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   Hide\cf2 ;
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0   DestroyWindow\cf2 (\cf1 FWindow\cf2 );
\par \cf1   Windows\cf2 .\cf1 UnregisterClass\cf2 (\cf1 cLayeredWndClass\cf2 ,\cf1  HInstance\cf2 );
\par \cf1\i \{$ELSE\}
\par \i0   FDragForm\cf2 .\cf1 Free\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0   FBitmap\cf2 .\cf1 Free\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKDragWindow\cf2 .\cf1 Hide\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  FActive \b then
\par \b0   \b begin
\par \b0   \i \{$IFDEF USE_WINAPI\}
\par \i0     ShowWindow\cf2 (\cf1 FWindow\cf2 ,\cf1  SW_HIDE\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     FDragForm\cf2 .\cf1 Hide\cf2 ;
\par \cf1   \i \{$ENDIF\}
\par \i0     FActive \cf2 :=\cf1  False\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKDragWindow\cf2 .\cf1 Init\cf2 (\cf1 IniCtrl\cf2 :\cf1  TCustomControl\cf2 ;\cf1  \b const\b0  ARect\cf2 :\cf1  TRect\cf2 ;
\par \cf1   \b const\b0  AInitialPos\cf2 :\cf1  TPoint\cf2 ;\cf1  AMasterAlpha\cf2 :\cf1  Byte\cf2 ;\cf1  AGradient\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   Org\cf2 :\cf1  TPoint\cf2 ;
\par \cf1   W\cf2 ,\cf1  H\cf2 :\cf1  Integer\cf2 ;
\par \cf1   ScreenDC\cf2 :\cf1  HDC\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  \b not\b0  FActive \b and\b0  \cf2 ((\cf1 IniCtrl \cf2 =\cf1  \b nil\b0\cf2 )\cf1  \b or\b0  \cf2 (\cf1 IniCtrl \b is\b0  TKCustomControl\cf2 ))\cf1  \b then
\par \b0   \b begin
\par \b0     FActive \cf2 :=\cf1  True\cf2 ;
\par \cf1     FBitmapFilled \cf2 :=\cf1  False\cf2 ;
\par \cf1     FControl \cf2 :=\cf1  IniCtrl\cf2 ;
\par \cf1     FMasterAlpha \cf2 :=\cf1  AMasterAlpha\cf2 ;
\par \cf1     FGradient \cf2 :=\cf1  AGradient\cf2 ;
\par \cf1     FInitialPos \cf2 :=\cf1  AInitialPos\cf2 ;
\par \cf1     FRect \cf2 :=\cf1  ARect\cf2 ;
\par \cf1     W \cf2 :=\cf1  ARect\cf2 .\cf1 Right \cf2 -\cf1  ARect\cf2 .\cf1 Left\cf2 ;
\par \cf1     H \cf2 :=\cf1  ARect\cf2 .\cf1 Bottom \cf2 -\cf1  ARect\cf2 .\cf1 Top\cf2 ;
\par \cf1     FBitmap\cf2 .\cf1 SetSize\cf2 (\cf1 W\cf2 ,\cf1  H\cf2 );
\par \cf1     ScreenDC \cf2 :=\cf1  GetDC\cf2 (\cf5 0\cf2 );
\par \cf1     \b try
\par \b0       FAlphaEffects \cf2 :=\cf1  GetDeviceCaps\cf2 (\cf1 ScreenDC\cf2 ,\cf1  BITSPIXEL\cf2 )\cf1  \cf2 >=\cf1  \cf5 15\cf2 ;
\par \cf1       \cf0\i // because alpha blending is not nice elsewhere
\par \i0\cf1     \b finally
\par \b0       ReleaseDC\cf2 (\cf5 0\cf2 ,\cf1  ScreenDC\cf2 );
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  FControl \cf2 <>\cf1  \b nil\b0  \b then
\par \b0     \b begin
\par \b0       Org \cf2 :=\cf1  FControl\cf2 .\cf1 ClientToScreen\cf2 (\cf1 ARect\cf2 .\cf1 TopLeft\cf2 );
\par \cf1       \cf0\i // to be compatible with all LCL widgetsets we must copy the control's part
\par \i0\cf1       \cf0\i // while painting in TKCustomControl.Paint!
\par \i0\cf1       TKCustomControl\cf2 (\cf1 FControl\cf2 ).\cf1 MemoryCanvas \cf2 :=\cf1  FBitmap\cf2 .\cf1 Canvas\cf2 ;
\par \cf1       TKCustomControl\cf2 (\cf1 FControl\cf2 ).\cf1 MemoryCanvasRect \cf2 :=\cf1  ARect\cf2 ;
\par \cf1       TKCustomControl\cf2 (\cf1 FControl\cf2 ).\cf1 Repaint\cf2 ;
\par \cf1     \b end\b0  \b else
\par \b0       Org \cf2 :=\cf1  ARect\cf2 .\cf1 TopLeft\cf2 ;
\par \cf1   \i \{$IFDEF USE_WINAPI\}
\par \i0     \b if\b0  FLayered \b then\b0  \b with\b0  FBlend \b do
\par \b0     \b begin
\par \b0       BlendOp \cf2 :=\cf1  AC_SRC_OVER\cf2 ;
\par \cf1       BlendFlags \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1       SourceConstantAlpha \cf2 :=\cf1  \cf5 255\cf2 ;
\par \cf1       \b if\b0  FAlphaEffects \b then
\par \b0         AlphaFormat \cf2 :=\cf1  AC_SRC_ALPHA
\par       \b else
\par \b0         AlphaFormat \cf2 :=\cf1  \cf5 0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     SetWindowPos\cf2 (\cf1 FWindow\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  Org\cf2 .\cf1 X\cf2 ,\cf1  Org\cf2 .\cf1 Y\cf2 ,\cf1  W\cf2 ,\cf1  H\cf2 ,
\par \cf1       SWP_NOACTIVATE \b or\b0  SWP_NOZORDER\cf2 );
\par \cf1   \i \{$ELSE\}
\par \i0     FDragForm\cf2 .\cf1 SetBounds\cf2 (\cf1 Org\cf2 .\cf1 X\cf2 ,\cf1  Org\cf2 .\cf1 Y\cf2 ,\cf1  W\cf2 ,\cf1  H\cf2 );
\par \cf1   \i \{$ENDIF\}
\par \i0   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKDragWindow\cf2 .\cf1 Move\cf2 (\cf1 ARect\cf2 :\cf1  PRect\cf2 ;\cf1  \b const\b0  ACurrentPos\cf2 :\cf1  TPoint\cf2 ;\cf1  AShowAlways\cf2 :\cf1  Boolean\cf2 );
\par \cf1\b var
\par \b0   R\cf2 :\cf1  TRect\cf2 ;
\par \cf1   DX\cf2 ,\cf1  DY\cf2 :\cf1  Integer\cf2 ;
\par \cf1   BlendColor\cf2 :\cf1  TColor\cf2 ;
\par \cf1   ChangedPos\cf2 :\cf1  Boolean\cf2 ;
\par \cf1\i \{$IFDEF USE_WINAPI\}
\par \i0   ScreenDC\cf2 :\cf1  HDC\cf2 ;
\par \cf1   CanvasOrigin\cf2 :\cf1  TPoint\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b begin
\par \b0   \b if\b0  FActive \b then
\par \b0   \b begin
\par \b0     ChangedPos \cf2 :=\cf1  False\cf2 ;
\par \cf1     DX \cf2 :=\cf1  ACurrentPos\cf2 .\cf1 X \cf2 -\cf1  FInitialPos\cf2 .\cf1 X\cf2 ;
\par \cf1     DY \cf2 :=\cf1  ACurrentPos\cf2 .\cf1 Y \cf2 -\cf1  FInitialPos\cf2 .\cf1 Y\cf2 ;
\par \cf1     \b if\b0  \cf2 (\cf1 DX \cf2 <>\cf1  \cf5 0\cf2 )\cf1  \b or\b0  \cf2 (\cf1 DY \cf2 <>\cf1  \cf5 0\cf2 )\cf1  \b then
\par \b0     \b begin
\par \b0       FInitialPos \cf2 :=\cf1  ACurrentPos\cf2 ;
\par \cf1       ChangedPos \cf2 :=\cf1  True\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  ARect \cf2 <>\cf1  \b nil\b0  \b then
\par \b0       ChangedPos \cf2 :=\cf1  ChangedPos \b or\b0  \b not\b0  EqualRect\cf2 (\cf1 ARect\cf2 ^,\cf1  FRect\cf2 );
\par \cf1     \b if\b0  \cf2 ((\cf1 FControl \cf2 =\cf1  \b nil\b0\cf2 )\cf1  \b or\b0  \cf2 (\cf1 TKCustomControl\cf2 (\cf1 FControl\cf2 ).\cf1 MemoryCanvas \cf2 =\cf1  \b nil\b0\cf2 ))\cf1  \b and\b0  \b not\b0  FBitmapFilled \b or\b0  \cf2 (\cf1 ARect \cf2 <>\cf1  \b nil\b0\cf2 )\cf1  \b then
\par \b0     \b begin
\par \b0       FBitmapFilled \cf2 :=\cf1  True\cf2 ;
\par \cf1       \b if\b0  ARect \cf2 <>\cf1  \b nil\b0  \b then
\par \b0         FBitmap\cf2 .\cf1 SetSize\cf2 (\cf1 ARect\cf2 .\cf1 Right \cf2 -\cf1  ARect\cf2 .\cf1 Left\cf2 ,\cf1  ARect\cf2 .\cf1 Bottom \cf2 -\cf1  ARect\cf2 .\cf1 Top\cf2 );
\par \cf1       FBitmap\cf2 .\cf1 UpdatePixels\cf2 ;
\par \cf1       \b if\b0  FAlphaEffects \b then
\par \b0       \b begin
\par \b0         \b if\b0  FLayered \b then
\par \b0           BlendColor \cf2 :=\cf1  clBlack
\par         \b else
\par \b0           BlendColor \cf2 :=\cf1  clWhite\cf2 ;
\par \cf1         FBitmap\cf2 .\cf1 AlphaFill\cf2 (\cf1 FMasterAlpha\cf2 ,\cf1  BlendColor\cf2 ,\cf1  FGradient\cf2 ,\cf1  FLayered\cf2 );
\par \cf1         FBitmap\cf2 .\cf1 UpdateHandle\cf2 ;
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1     \b if\b0  ChangedPos \b or\b0  AShowAlways \b then
\par \b0     \b begin
\par \b0     \i \{$IFDEF USE_WINAPI\}
\par \i0       \b if\b0  ARect \cf2 <>\cf1  \b nil\b0  \b then
\par \b0         R \cf2 :=\cf1  ARect\cf2 ^
\par \cf1       \b else
\par \b0         GetWindowRect\cf2 (\cf1 FWindow\cf2 ,\cf1  R\cf2 );
\par \cf1       KFunctions\cf2 .\cf1 OffsetRect\cf2 (\cf1 R\cf2 ,\cf1  DX\cf2 ,\cf1  DY\cf2 );
\par \cf1       \b if\b0  FLayered \b then
\par \b0       \b begin
\par \b0         R\cf2 .\cf1 Right \cf2 :=\cf1  FBitmap\cf2 .\cf1 Width\cf2 ;
\par \cf1         R\cf2 .\cf1 Bottom \cf2 :=\cf1  FBitmap\cf2 .\cf1 Height\cf2 ;
\par \cf1         CanvasOrigin \cf2 :=\cf1  CreateEmptyPoint\cf2 ;
\par \cf1         ScreenDC \cf2 :=\cf1  GetDC\cf2 (\cf5 0\cf2 );
\par \cf1         \b try
\par \b0           \b if\b0  FUpdateLayeredWindow\cf2 (\cf1 FWindow\cf2 ,\cf1  ScreenDC\cf2 ,\cf1  \cf2 @\cf1 R\cf2 .\cf1 TopLeft\cf2 ,\cf1  PSize\cf2 (@\cf1 R\cf2 .\cf1 BottomRight\cf2 ),
\par \cf1             FBitmap\cf2 .\cf1 Canvas\cf2 .\cf1 Handle\cf2 ,\cf1  \cf2 @\cf1 CanvasOrigin\cf2 ,\cf1  clNone\cf2 ,\cf1  \cf2 @\cf1 FBlend\cf2 ,\cf1  ULW_ALPHA\cf2 )\cf1  \b then
\par \b0             \b if\b0  FBitmapFilled \b then
\par \b0               ShowWindow\cf2 (\cf1 FWindow\cf2 ,\cf1  SW_SHOWNOACTIVATE\cf2 );
\par \cf1         \b finally
\par \b0           ReleaseDC\cf2 (\cf5 0\cf2 ,\cf1  ScreenDC\cf2 );
\par \cf1         \b end\b0\cf2 ;
\par \cf1       \b end
\par \b0       \b else\b0  \b if\b0  FBitmapFilled \b then
\par \b0         SetWindowPos\cf2 (\cf1 FWindow\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  R\cf2 .\cf1 Left\cf2 ,\cf1  R\cf2 .\cf1 Top\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,
\par \cf1           SWP_NOACTIVATE \b or\b0  SWP_NOSIZE \b or\b0  SWP_NOZORDER \b or\b0  SWP_SHOWWINDOW\cf2 );
\par \cf1     \i \{$ELSE\}
\par \i0       \b if\b0  ARect \cf2 <>\cf1  \b nil\b0  \b then
\par \b0         R \cf2 :=\cf1  ARect\cf2 ^
\par \cf1       \b else
\par \b0         R \cf2 :=\cf1  FDragForm\cf2 .\cf1 BoundsRect\cf2 ;
\par \cf1       OffsetRect\cf2 (\cf1 R\cf2 ,\cf1  DX\cf2 ,\cf1  DY\cf2 );
\par \cf1       FDragForm\cf2 .\cf1 BoundsRect \cf2 :=\cf1  R\cf2 ;
\par \cf1       \b if\b0  FBitmapFilled \b then
\par \b0       \b begin
\par \b0         FDragForm\cf2 .\cf1 Visible \cf2 :=\cf1  True\cf2 ;
\par \cf1         \b if\b0  FControl \cf2 <>\cf1  \b nil\b0  \b then
\par \b0           SetCaptureControl\cf2 (\cf1 FControl\cf2 );
\par \cf1       \b end\b0\cf2 ;
\par \cf1     \i \{$ENDIF\}
\par \i0     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKHintWindow \}
\par 
\par \i0\cf1\b constructor\b0  TKHintWindow\cf2 .\cf1 Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1\i \{$IFDEF FPC\}
\par \i0   ShowInTaskBar \cf2 :=\cf1  stNever\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0   DoubleBuffered \cf2 :=\cf1  True\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKHintWindow\cf2 .\cf1 ShowAt\cf2 (\cf1\b const\b0  Origin\cf2 :\cf1  TPoint\cf2 );
\par \cf1\b begin
\par \b0   ActivateHint\cf2 (\cf1 Rect\cf2 (\cf1 Origin\cf2 .\cf1 X\cf2 ,\cf1  Origin\cf2 .\cf1 Y\cf2 ,\cf1  Origin\cf2 .\cf1 X \cf2 +\cf1  FExtent\cf2 .\cf1 X \cf2 +\cf1  \cf5 10\cf2 ,\cf1  Origin\cf2 .\cf1 Y \cf2 +\cf1  FExtent\cf2 .\cf1 Y \cf2 +\cf1  \cf5 10\cf2 ),\cf1  \cf4 ''\cf2 );
\par \cf0\i //  ActivateWithBounds(Rect(Origin.X, Origin.Y, Origin.X + FExtent.X + 10, Origin.Y + FExtent.Y + 10), '');
\par \i0\cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKHintWindow\cf2 .\cf1 Hide\cf2 ;
\par \cf1\b begin
\par \b0\i \{$IFDEF FPC\}
\par \i0   \b inherited\b0  Hide\cf2 ;
\par \cf1\i \{$ELSE\}
\par \i0    Self\cf2 .\cf1 DestroyHandle\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKHintWindow\cf2 .\cf1 WMEraseBkGnd\cf2 (\cf1\b var\b0  Msg\cf2 :\cf1  TLMessage\cf2 );
\par \cf1\b begin
\par \b0   Msg\cf2 .\cf1 Result \cf2 :=\cf1  \cf5 1\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKTextHint \}
\par 
\par \i0\cf1\b constructor\b0  TKTextHint\cf2 .\cf1 Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FText \cf2 :=\cf1  \cf4 ''\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextHint\cf2 .\cf1 Paint\cf2 ;
\par \cf1\b var
\par \b0   TextBox\cf2 :\cf1  TKTextBox\cf2 ;
\par \cf1\b begin
\par \b0   Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Style \cf2 :=\cf1  bsSolid\cf2 ;
\par \cf1   Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Color \cf2 :=\cf1  clInfoBk\cf2 ;
\par \cf1   Canvas\cf2 .\cf1 FillRect\cf2 (\cf1 ClientRect\cf2 );
\par \cf1   Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Style \cf2 :=\cf1  bsClear\cf2 ;
\par \cf1   TextBox \cf2 :=\cf1  TKTextBox\cf2 .\cf1 Create\cf2 ;
\par \cf1   \b try
\par \b0     TextBox\cf2 .\cf1 Attributes \cf2 :=\cf1  \cf2 [\cf1 taEndEllipsis\cf2 ,\cf1  taWordBreak\cf2 ,\cf1  taLineBreak\cf2 ];
\par \cf1     TextBox\cf2 .\cf1 BackColor \cf2 :=\cf1  clInfoBk\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 HPadding \cf2 :=\cf1  \cf5 5\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 VPadding \cf2 :=\cf1  \cf5 5\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 Text \cf2 :=\cf1  FText\cf2 ;
\par \cf1     TextBox\cf2 .\cf1 Draw\cf2 (\cf1 Canvas\cf2 ,\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  FExtent\cf2 .\cf1 X \cf2 +\cf1  \cf5 10\cf2 ,\cf1  FExtent\cf2 .\cf1 Y \cf2 +\cf1  \cf5 10\cf2 ));
\par \cf1   \b finally
\par \b0      TextBox\cf2 .\cf1 Free\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKTextHint\cf2 .\cf1 SetText\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  TKString\cf2 );
\par \cf1\b var
\par \b0   R\cf2 :\cf1  TRect\cf2 ;
\par \cf1   TextBox\cf2 :\cf1  TKTextBox\cf2 ;
\par \cf1\b begin
\par \b0   \b if\b0  Value \cf2 <>\cf1  FText \b then
\par \b0   \b begin
\par \b0     FText \cf2 :=\cf1  Value\cf2 ;
\par \cf1     R \cf2 :=\cf1  Rect\cf2 (\cf5 0\cf2 ,\cf1  \cf5 0\cf2 ,\cf1  \cf5 300\cf2 ,\cf1  \cf5 0\cf2 );
\par \cf1     TextBox \cf2 :=\cf1  TKTextBox\cf2 .\cf1 Create\cf2 ;
\par \cf1     \b try
\par \b0       TextBox\cf2 .\cf1 Attributes \cf2 :=\cf1  \cf2 [\cf1 taWordBreak\cf2 ,\cf1  taLineBreak\cf2 ];
\par \cf1       TextBox\cf2 .\cf1 Text \cf2 :=\cf1  FText\cf2 ;
\par \cf1       TextBox\cf2 .\cf1 Measure\cf2 (\cf1 Canvas\cf2 ,\cf1  R\cf2 ,\cf1  FExtent\cf2 .\cf1 X\cf2 ,\cf1  FExtent\cf2 .\cf1 Y\cf2 );
\par \cf1     \b finally
\par \b0        TextBox\cf2 .\cf1 Free\cf2 ;
\par \cf1     \b end\b0\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf0\i \{ TKGraphicHint \}
\par 
\par \i0\cf1\b constructor\b0  TKGraphicHint\cf2 .\cf1 Create\cf2 (\cf1 AOwner\cf2 :\cf1  TComponent\cf2 );
\par \cf1\b begin
\par \b0   \b inherited\b0\cf2 ;
\par \cf1   FGraphic \cf2 :=\cf1  \b nil\b0\cf2 ;
\par \cf1\i \{$IFDEF FPC\}
\par \i0   ShowInTaskBar \cf2 :=\cf1  stNever\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0   DoubleBuffered \cf2 :=\cf1  True\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKGraphicHint\cf2 .\cf1 Paint\cf2 ;
\par \cf1\b begin
\par \b0   Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Style \cf2 :=\cf1  bsSolid\cf2 ;
\par \cf1   Canvas\cf2 .\cf1 Brush\cf2 .\cf1 Color \cf2 :=\cf1  clInfoBk\cf2 ;
\par \cf1   Canvas\cf2 .\cf1 FillRect\cf2 (\cf1 ClientRect\cf2 );
\par \cf1   \b if\b0  Assigned\cf2 (\cf1 FGraphic\cf2 )\cf1  \b then
\par \b0     Canvas\cf2 .\cf1 Draw\cf2 (\cf5 5\cf2 ,\cf1  \cf5 5\cf2 ,\cf1  FGraphic\cf2 )
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  TKGraphicHint\cf2 .\cf1 SetGraphic\cf2 (\cf1\b const\b0  Value\cf2 :\cf1  TGraphic\cf2 );
\par \cf1\b begin
\par \b0   \b if\b0  Value \cf2 <>\cf1  FGraphic \b then
\par \b0   \b begin
\par \b0     FGraphic \cf2 :=\cf1  Value\cf2 ;
\par \cf1     FExtent\cf2 .\cf1 X \cf2 :=\cf1  FGraphic\cf2 .\cf1 Width\cf2 ;
\par \cf1     FExtent\cf2 .\cf1 Y \cf2 :=\cf1  FGraphic\cf2 .\cf1 Height\cf2 ;
\par \cf1   \b end\b0\cf2 ;
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  RegisterAlphaBitmap\cf2 ;
\par \cf1\b begin
\par \b0   TPicture\cf2 .\cf1 RegisterFileFormat\cf2 (\cf4 'BMA'\cf2 ,\cf1  sGrAlphaBitmap\cf2 ,\cf1  TKAlphaBitmap\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\b procedure\b0  UnregisterAlphaBitmap\cf2 ;
\par \cf1\b begin
\par \b0   TPicture\cf2 .\cf1 UnregisterGraphicClass\cf2 (\cf1 TKAlphaBitmap\cf2 );
\par \cf1\b end\b0\cf2 ;
\par 
\par \cf1\i \{$IFDEF REGISTER_PICTURE_FORMATS\}
\par \i0\b initialization
\par \b0   RegisterAlphaBitmap\cf2 ;
\par \cf1\b finalization
\par \b0   \cf0\i //not necessary, but...
\par \i0\cf1   UnregisterAlphaBitmap\cf2 ;
\par \cf1\i \{$ENDIF\}
\par \i0\b end\b0\cf2 .
\par 
\par }