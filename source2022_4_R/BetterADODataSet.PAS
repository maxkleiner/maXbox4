(********************************************************************************)
(*                                                                              *)
(* The contents of this file are subject to the Mozilla Public License Version  *)
(* 1.1 (the "License"); you may not use this file except in compliance with the *)
(* License. You may obtain a copy of the License at http://www.mozilla.org/MPL/ *)
(*                                                                              *)
(* Software distributed under the License is distributed on an "AS IS" basis,   *)
(* WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for *)
(* the specific language governing rights and limitations under the License.    *)
(*                                                                              *)
(* The Original Code is BetterADODataSet.PAS                                    *)
(* Supported on Delphi 5,6&7 and BCB 5&6                                        *)
(*                                                                              *)
(* The Developer of the Original Code is Vassil Nazarov                         *)
(* vassil@engineer.bg                                                           *)
(* http://web.orbitel.bg/vassil/                                                *)
(*                                                                              *)
(* Many contributions made by members of the borland.delphi.ado newsgroup.      *)
(*                                                                              *)
(* The latest version is 4.04 from 18.SEP.2003                                  *)
(*                                                                              *)
(********************************************************************************)

Unit BetterADODataSet;

INTERFACE

{$I COMPILERS.INC}
{$RANGECHECKS OFF}

{$DEFINE MDAC26}
(***************************   !!!  ATTENTION  !!!   ***********************)
(*                                                                         *)
(* The NamedParams Property, FieldStatus Property, SaveToADOStream and     *)
(* LoadFromADOStream methods all depend on features that were introduced   *)
(* in MDAC 2.5/2.6. If you want to enable these new features and thus make *)
(* your apps INCOMPATIBLE with versions of MDAC prior to 2.6, place a dot  *)
(* in the $UNDEF clause below to become {.$UNDEF MDAC26}.                  *)
(*                                                                         *)
(***************************************************************************)
{.$UNDEF MDAC26}


Uses
  Windows,
  Classes,
  ADOInt,
  ADODB,
  {$IFDEF MDAC26}
  ADO26_TLB,
  {$ENDIF}
  DB;

Const
  BetterADODataSetVersion = '4.04';

Type

  TUpdateCriteria = (
    adCriteriaKey,
    // Detects conflicts if the key column of the data source row
    // has been changed, which means that the row has been deleted.
    adCriteriaAllCols,
    // Detects conflicts if any column of the data source row
    // has been changed.
    adCriteriaUpdCols,
    // Detects conflicts if any of the columns of the data source row that
    // correspond to updated fields of the Recordset have been changed.
    adCriteriaTimeStamp);
    // Detects conflicts if the timestamp of the data source row has been
    // changed, which means the row has been accessed after the Recordset
    // was obtained.

  TUpdateResyncEnum = (
    ResyncAutoIncrement,
    // Default. Attempts to retrieve the new identity value for columns
    // that are automatically incremented or generated by the data source,
    // such as Microsoft Jet AutoNumber fields or Microsoft SQL Server
    // Identity columns.
    ResyncConflicts,
    // Invokes Resync for all rows in which the update or delete
    // operation failed because of a concurrency conflict.
    ResyncUpdates,
    // Invokes Resync for all successfully updated rows.
    ResyncInserts);
    // Invokes Resync for all successfully inserted rows. However,
    // AutoIncrement column values are not resynchronized. Instead,
    // the contents of newly inserted rows are resynchronized based
    // on the existing primary key value. If the primary key is an
    // AutoIncrement value, Resync won't retrieve the contents of the
    // intended row. For automatically incrementing AutoIncrement
    // primary key values, call UpdateBatch with the combined value
    // adResyncAutoIncrement + adResyncInserts.

  TUpdateResync = Set Of TUpdateResyncEnum;

  TRefreshType = (
    rtRequery,                                 //13.JAN.2001
    rtResyncCurrent,
    rtResyncGroup,
    rtResyncAll,
    // Not recommended unless there's a STRING filter in effect !!!
    // Otherwise ADO will issue a singleton SELECT statement for each
    // record in the RecordSet. If you want to refresh the entire RecordSet
    // (discarding any pending updates), Requery would be more efficient.
    // If you have updates pending, consider rtResyncGroup with a filter
    // set to adFilterPendingRecords.
    rtResyncChapters);
    // Indicates the operation to perform when executing
    // the TDataSet's Refresh method.

  TJoinsResolution = (jrAuto, jrManual, jrNone);
  // jrAuto - Discards any changes made to any TFields NOT belonging to the
  //        UNIQUE_TABLE. Only meaningful when the UNIQUE_TABLE is assigned a
  //        value and (JoinTest=jtJoined) and (CursorLocation=clUseClient).
  //        The original idea by Harry Van Tassel.
  // jrManual - Only discards changes made to TFields whose pfInUpdate provider
  //        flag is NOT SET. This is independent to the above conditions and
  //        makes TBetterADODataSet behave like a TClientDataSet with respect
  //        to the pfInUpdate flag.
  // jrNone - Doesn't discard no changes. Equivalent to TCustomADODataSet.

  TJoinTest = (jtInactive, jtNotJoined, jtJoined); // 23.JAN.2001
  TStartPos = (spFirstRecord, spCurrentRecord);    // 13.MAR.2001

  TBetterADODataSet=Class;

  TADOVersion=Class(TPersistent)                   // 25.FEB.2002
  Private
    FOwner: TBetterADODataSet;
    Function GetVersion: String;
    Function GetProperty(PropertyName: String): String;
    Function GetADOVersion: String;
    Function GetOLEDBVersion: String;
    Function GetProviderName: String;
    Function GetProviderVersion: String;
    Function GetDBMSName: String;
    Function GetDBMSVersion: String;
    Function GetODBCVersion: String;
    Function GetODBCDriverName: String;
    Function GetODBCDriverVersion: String;
    Procedure SetVersion(Value: String);
  Protected
  Public
    Constructor Create(AOwner: TBetterADODataSet); Virtual;
  Published
    Property BetterADSVersion: String Read GetVersion Write SetVersion Stored False;
    Property ADOVersion: String Read GetADOVersion Write SetVersion Stored False;
    Property OLEDBVersion: String Read GetOLEDBVersion Write SetVersion Stored False;
    Property ProviderName: String Read GetProviderName Write SetVersion Stored False;
    Property ProviderVersion: String Read GetProviderVersion Write SetVersion Stored False;
    Property DBMSName: String Read GetDBMSName Write SetVersion Stored False;
    Property DBMSVersion: String Read GetDBMSVersion Write SetVersion Stored False;
    Property ODBCVersion: String Read GetODBCVersion Write SetVersion Stored False;
    Property ODBCDriverName: String Read GetODBCDriverName Write SetVersion Stored False;
    Property ODBCDriverVersion: String Read GetODBCDriverVersion Write SetVersion Stored False;
  End; //TADOVersion

  TBetterADODataSet=Class(TADODataSet)
  Private
    FUpdateCriteria: TUpdateCriteria;
    FUniqueCatalog: String;
    FUniqueSchema: String;
    FUniqueTable: String;
    FUpdateResync: TUpdateResync;
    FResyncCommand: TStringList;
    FRefreshType: TRefreshType;                                  // 13.JAN.2001
    {$IFDEF DELPHI6_UP}
    FInitialFetchSize: Integer;                                  // 25.FEB.2002
    FBackgroundFetchSize: Integer;                               // 25.FEB.2002
    {$ENDIF}
    FLockCursor: ADOInt._Recordset;                              // 19.JAN.2001
    FJoinsResolution: TJoinsResolution;                          // 19.JAN.2001
    FJoinTest: TJoinTest;                                        // 23.JAN.2001
    FDeleteGuardian: Boolean;                                    // 23.JAN.2001
    {$IFDEF MDAC26}
    FNamedParams: Boolean;                                       // 09.MAR.2001
    {$ENDIF}
    FFindCursor: ADOInt._Recordset;                              // 29.SEP.2001 by Peter van Logchem
    FLookupCursor: ADOInt._Recordset;                            // 29.SEP.2001
    FADOVer: TADOVersion;                                        // 25.FEB.2002
    FStateBeforePost: TDataSetState;                             // 25.FEB.2002
    FAutoCalcClear: Boolean;                                     // 25.FEB.2002
    Procedure SetUpdateCriteria(Value: TUpdateCriteria);
    Procedure SetProperty(Var Prop: String; PropertyName, AValue: String);
    Procedure SetUniqueTable(Value: String);
    Procedure SetUniqueSchema(Value: String);
    Procedure SetUniqueCatalog(Value: String);
    Procedure SetUpdateResync(Value: TUpdateResync);
    Procedure SetResyncCommand(Value: TStringList);
    Function IsResyncCommandStored: Boolean;
    Function GetErrors: ADOInt.Errors;                           // 13.JAN.2001
    Procedure SetJoinTest(Value: TJoinTest);                     // 23.JAN.2001
    Function GetParamByName(Const ParamName: WideString): TParameter; // 24.JAN.2001
    {$IFDEF MDAC26}
    Function GetFieldStatus(Const FieldName: WideString): FieldStatusEnum;
    Procedure SetNamedParams(Value: Boolean);                    // 09.MAR.2001
    {$ENDIF}
  Protected
    FModifiedFields: TList;                                      // 25.FEB.2002
    Procedure InternalPost; Override;
    // Implements the functionality for the JoinsResolution Property.
    // This is the most important piece of code in this unit.
    Procedure InternalEdit; Override;                            // 19.JAN.2001
    // Implement support for pessimistic locking.
    // Proposed by Harry Van Tassel 19.JAN.2001
    Procedure InternalCancel; Override;                          // 19.JAN.2001
    // Proposed by Harry Van Tassel 19.JAN.2001
    // Implement support for pessimistic locking with the JET provider.
    Procedure DoAfterOpen; Override;
    // DoAfterOpen - Propagates Dynamic Property values to the underlying RecordSet
    // if and when appropriate. Also sets the JoinTest Property as appropriate.
    Procedure DoAfterScroll; Override;                           // 05.SEP.2002
    // Fixes the AsyncFetchNonBlocking problem where the first/last record isn't shown.
    Procedure DoAfterClose; Override;                            // 20.APR.2001
    // Sets the value of the JoinTest Property back to jtInactive.
    Procedure DoBeforeRefresh; Override;                         // 05.FEB.2001
    // DoBeforeRefresh - Aborts the Inherited Refresh and calls our own Refresh instead.
    // This provides for proper handling of the TDBNavigator's Refresh button and
    // the Inherited Refresh method in general.
    // Note that this will also Abort the calling Procedure. To avoid that simply
    // avoid calling the Inherited Refresh. Here is an example:
    (**************************************************************************)
    (*                                                                        *)
    (*  Procedure BetterADODataSet1.OnSomeEventDo(DataSet: TDataSet);         *)
    (*  Begin                                                                 *)
    (*    ...                                                                 *)
    (*    TBetterADODataSet(DataSet).Refresh; //Call our own Refresh.         *)
    (*    ... Continue execution;                                             *)
    (*    DataSet.Refresh; //DoBeforeRefresh will intercept this and Abort.   *)
    (*    ... This line would not be executed;                                *)
    (*  End;                                                                  *)
    (*                                                                        *)
    (**************************************************************************)

    Procedure DoBeforeOpen; Override;                            // 13.JAN.2001
    Function IsJoinedRecordSet: TJoinTest; Virtual;              // 19.JAN.2001
    // Tests whether it is a Joined ResultSet.
    Procedure DoBeforeDelete; Override;                          // 23.JAN.2001
    // Guards against accidental deletion of records in joined tables.
    // Provided by Harry Van Tassel.
    Procedure InternalInitFieldDefs; Override;                   // 23.JAN.2001
    // Don't allow editing of AutoInc fields. Provided by Harry Van Tassel.
    // Added proper initialization of the "Required" attribute of TFields. // 13.MAR.2001
    Procedure Loaded; Override;                                  // 09.MAR.2001
    Procedure CreateFields; Override;                            // 14.MAR.2001
    // Correctly initializes the AutoGenerateValue Property of Identity fields.
    // Unfortunately when you add persistent fields, the fields editor recreates
    // the fields and this Property is reset back to arNone.
    Procedure MasterChanged(Sender: TObject); Override;          // 15.APR.2001
    // Reinstates the dynamic properties by calling InitDynamicProps.
    // Without this you would be loosing your dynamic properties each time
    // the master scrolls.
    Procedure InitDynamicProps; Virtual;                         // 15.APR.2001
    // Sets some dynamic properties of the underlying RecordSet.
    // Just separated some old code in this Procedure to avoid redundancy.
    Function CorrectlyLocateRecord(Const KeyFields: String;
                                   Const KeyValues: OleVariant;
                                   Options: TLocateOptions;
                                   SyncCursor: Boolean): Boolean; Virtual; // 03.JUN.2001
    // This gets called by the Locate Function to do the dirty work.
    // It corresponds to TCustomADODataSet.LocateRecord only lacks a few bugs. <g>
    Procedure SetFilterText(Const Value: String); Override;      // 12.JUN.2001
    // A workaround for an MS's bug with ADO filters.
    Function FindRecord(Restart, GoForward: Boolean): Boolean; Override; //29.SEP.2001 by Peter van Logchem
    // Fixes some bugs of the inherited method that cause the famous
    // "Either BOF or EOF is true" error when running from within the IDE.
    Procedure InternalClose; Override;                                   //29.SEP.2001 by Peter van Logchem
    Procedure DestroyLookupCursor; Override;                             //29.SEP.2001 by Peter van Logchem
    //InternalClose and DestroyLookupCursor have been overriden to support
    //the FindRecord method above.
    Procedure DoOnNewRecord; Override;                           // 25.FEB.2002
    //Makes use of the TField's DefaultExpression property. Initializes all fields to their
    //default values if specified.

  {$IFDEF DELPHI6_UP}
    Procedure DoRecordsetCreate(DataSet: TCustomADODataSet; Const Recordset: ADODB._Recordset); Virtual; // 25.FEB.2002
  {$ENDIF}
    Procedure ReleaseLock;                                       // 25.FEB.2002
    Procedure SetFieldData(Field: TField; Buffer: Pointer; NativeFormat: Boolean); Override; // 25.FEB.2002
    Procedure DoBeforePost; Override;                            // 25.FEB.2002
    Procedure DoBeforeCancel; Override;                          // 25.FEB.2002
  Public
    Constructor Create(AOwner: TComponent); Override;
    Destructor Destroy; Override;
    Procedure Requery(Options: TExecuteOptions); Reintroduce; Overload; //25.FEB.2002
    Procedure Requery; Overload;
    // Requery - Propagates Dynamic Property values to the underlying RecordSet If And
    // when appropriate (after Requerying first of course <g>).
    // The native ADO's behaviour is to loose these settings upon Requery.
    Procedure Resync(AffectRecords: AffectEnum=adAffectCurrent; ResyncValues: ResyncEnum=adResyncAllValues); Reintroduce; Overload;
    // Resync - Calls the underlying RecordSet's Resync method.
    // The default parameter values are set to Resync the current record only!
    // Example: BetterADODataSet1.Resync;    //Resync the current record only!
    Procedure Refresh; Reintroduce;                                           // 05.FEB.2001
    // Hides the inherited Refresh and calls Requery or Resync
    // depending on the RefreshType Property.
    Procedure DeleteRecords(AffectRecords: TAffectRecords=arAll); Reintroduce; // 23.JAN.2001
    // This hack for deleting all records was provided by Harry Van Tassel.
    // Also added support for deleting all chapters.             // 12.MAR.2001
    Procedure CancelBatch(AffectRecords: TAffectRecords=arAll); // 14.FEB.2001
    // Hides the inherited CancelBatch which has a nasty bug.
    Function GetCanModify: Boolean; Override;                     // 04.MAR.2001 by J.Christin
    // Fixes a bug of the inherited method.
    Function Locate(Const KeyFields: String; Const KeyValues: Variant; Options: TLocateOptions): Boolean; Override;
    // 03.JUN.2001
    // Fixes some serious flaws of the inherited method.
    // Locates correctly on multiple columns and on filtered RecordSets.
    // Always respects the loPartialKey option for all eligible search fields.
    Function Lookup(Const KeyFields: String; Const KeyValues: Variant; Const ResultFields: String): Variant; Override;
    // 26.AUG.2001
    // Fixes some serious flaws of the inherited method.
    // Locates correctly on multiple columns and on filtered RecordSets.

  {$IFNDEF DELPHI6_UP} // 14.JUL.2001
    Procedure GetDetailLinkFields(MasterFields, DetailFields: TList); Override; // 14.JUL.2001
      // Add this method to fix missing key assignment when inserting
      // detail records in a client dataset provided from an ADO dataset.
      // Note: This fix requires an interface change and is therefore not part of the
      //       Version 5 update pack.
  {$ENDIF}

  Procedure ClearCalcFields(Buffer: PChar); Override; //25.FEB.2002
 // procedure ClearCalcFields(Buffer: TRecordBuffer); override; // scholz

  Function GetFieldData(Field: TField; Buffer: Pointer; NativeFormat: Boolean): Boolean; Override; // 05.SEP.2002
  //Fixes a bug of the inherited method which can not deal with DECIMAL(x,0) fields.

  {$IFDEF MDAC26}
    Procedure SaveToADOStream(Destination: OleVariant; PersistFormat: TPersistFormat=pfADTG); // 09.MAR.2001
    // Based on code by Harry Van Tassel.                                                 //
    // Destination: A Variant that represents the complete path name of the               //
    // file where the Recordset is to be saved, or a reference to an ADO Stream object.   //
    // An ADO Stream object is an instance of ADO26_TLB._Stream or any other COM object   //
    // that supports the OLE DB IStream interface.                                        //
    (************************************************************)
    (*                                                          *)
    (*                         Example:                         *)
    (*                                                          *)
    (* Procedure TForm1.Button1Click(Sender: TObject);          *)
    (*   Var ADOStream: _Stream;                                *)
    (* Begin                                                    *)
    (*   ADOStream := CoStream.Create;                          *)
    (*   Try                                                    *)
    (*     BetterADODataSet1.SaveToADOStream(ADOStream, pfXML); *)
    (*     ADOStream.Position := 0;                             *)
    (*     Memo1.Text := ADOStream.ReadText(adReadAll);         *)
    (*     BetterADODataSet2.LoadFromADOStream(ADOStream);      *)
    (*   Finally                                                *)
    (*     ADOStream := Nil;                                    *)
    (*     End; //Try                                           *)
    (* End;                                                     *)
    (*                                                          *)
    (************************************************************)
    Procedure LoadFromADOStream(Source: ADO26_TLB._Stream);          // 09.MAR.2001
    // Source: A Variant that represents a reference to an ADO Stream object.             //
    // An ADO Stream object is an instance of ADO26_TLB._Stream or any other COM object   //
    // that supports the OLE DB IStream interface.                                        //
    Function GetString(                                              // 13.MAR.2001
    //Returns the content of the RecordSet in a formatted WideString.
      NumRows: Integer=-1; //All
        // Number of rows to export starting at StartPos.
        // NumRows<=0 exports all rows.
      StartPos: TStartPos=spFirstRecord;
        // Start exporting at either the First or the Current row of the
        // underlying RecordSet. Note that the Current row of the RecordSet
        // may not always be the same as the Current row of the DataSet.
      Const ColumnDelimeter: WideString=#9; //TAB
      Const RowDelimeter: WideString=#13;   //CR
      Const NullExpr: WideString=''
        // A string literal to substitute for Null values.
        // Returns the Recordset as a string. Row data, but no schema data, is saved
        // to the string. Therefore, a Recordset cannot be reopened using this string.
      ): WideString;

    Property FieldStatus[Const FieldName: WideString]: FieldStatusEnum Read GetFieldStatus Stored False; // 10.MAR.2001
    // Returns the Status Property of the underling ADO Field object.
  {$ENDIF} //IFDEF MDAC26

    Property Errors: ADOInt.Errors Read GetErrors;                   // 13.JAN.2001
    // A reference to the underlying Connection's Errors collection. !!! May be Nil
    // if no connection is currently assigned and/or active so always check before use !!!
    Property ParamByName[Const ParamName: WideString]: TParameter Read GetParamByName Stored False; // 24.JAN.2001
    // The original idea by David B.E.
    Property StateBeforePost: TDataSetState Read FStateBeforePost Stored False; // 25.FEB.2002
    // This is intended to be used from within the AfterPost/Cancel event handlers so that you know
    // what you have just posted/canceled - an edit or an insert. Comes in very handy on certain occasions.
  Published
    Property IndexDefs;
    Property Update_Criteria: TUpdateCriteria Read FUpdateCriteria Write SetUpdateCriteria Default adCriteriaUpdCols;
    // See TUpdateCriteria above.
    Property Unique_Catalog: String Read FUniqueCatalog Write SetUniqueCatalog;
    Property Unique_Schema: String Read FUniqueSchema Write SetUniqueSchema;
    Property Unique_Table: String Read FUniqueTable Write SetUniqueTable;
    {Unique Table, Unique Schema, Unique Catalog Properties — Dynamic (ADO)
        Enables you to closely control modifications to a particular base table in a
        Recordset that was formed by a JOIN operation on multiple base tables.
        Unique Table specifies the name of the base table upon which updates, insertions,
        and deletions are allowed. Unique Schema specifies the schema, or name of the owner
        of the table. Unique Catalog specifies the Catalog, or name of the database
        containing the table. Settings and Return Values Sets or returns a String value that
        is the name of a table, schema, or Catalog.
        Remarks
        The desired base table is uniquely identified by its Catalog, schema, and table names.
        When the Unique Table Property is set, the values of the Unique Schema or Unique Catalog
        properties are used to find the base table. It is intended, but not required, that either
        or both the Unique Schema and Unique Catalog properties be set before the Unique Table
        Property is set.
        The primary key of the Unique Table is treated as the primary key of the entire Recordset.
        This is the key that is used for any method requiring a primary key.
        While Unique Table is set, the Delete method affects only the named table. The AddNew,
        Resync, Update, and UpdateBatch methods affect any appropriate underlying base tables
        of the Recordset.
        Unique Table must be specified before doing any custom resynchronizations. If Unique
        Table has not been specified, the Resync Command Property will have no effect.
        A run-time error results if a unique base table cannot be found.
        These dynamic properties are all appended to the Recordset object Properties collection
        when the CursorLocation Property is set to adUseClient.}
    Property Update_Resync: TUpdateResync Read FUpdateResync Write SetUpdateResync Default
                                          [ResyncAutoIncrement, ResyncUpdates, ResyncInserts];
    // See TUpdateResyncEnum above.
    Property Resync_Command: TStringList Read FResyncCommand Write SetResyncCommand Stored IsResyncCommandStored;
    {Resync Command Property — Dynamic (ADO)
        Specifies a user-supplied command string that the Resync method issues to refresh the data
        in the table named in the Unique Table dynamic Property.
        Settings and Return Values
        Sets or returns a String value which is a command string.
        Remarks
        The Recordset object is the result of a JOIN operation executed on multiple base tables.
        The rows affected depend on the AffectRecords parameter of the Resync method. The standard
        Resync method is executed if the Unique Table and Resync Command properties are not set.
        The command string of the Resync Command Property is a parameterized command or stored
        Procedure that uniquely identifies the row being refreshed, and returns a single row
        containing the same number and order of columns as the row to be refreshed. The command
        string contains a parameter for each primary key column in the Unique Table; otherwise,
        a run-time error is returned. The parameters are automatically filled in with primary key
        values from the row to be refreshed.
        Resync Command is a dynamic Property appended to the Recordset object Properties collection
        when the CursorLocation Property is set to adUseClient.}
    Property RefreshType: TRefreshType Read FRefreshType Write FRefreshType Default rtResyncCurrent; // 13.JAN.2001
    // Determines the operation to perform when executing the inherited TDataSet's
    // Refresh method (for example by the TDBNavigator's Refresh button).
    // See TRefreshType above.
    Property JoinsResolution: TJoinsResolution Read FJoinsResolution Write FJoinsResolution Default jrAuto; // 19.JAN.2001
    // See TJoinsResolution above
    Property JoinTest: TJoinTest Read FJoinTest Write SetJoinTest Stored False; // 23.JAN.2001
    // Indicates whether it is a Joined ResultSet or not. Only meaningful
    // when the DataSet is Active or otherwise returns jtInactive.
    Property DeleteGuardian: Boolean Read FDeleteGuardian Write FDeleteGuardian Default True; // 23.JAN.2001
    // With Joined ResultSets the Unique_Table Property (if set) restricts
    // delete operations to just the [Unique Table]. If (DeleteGuardian=True)
    // and (JoinTest=True) and (Unique_Table='') then a warning message
    // is displayed upon delete operations and the user is given the chance
    // to abort. If you INTEND NOT TO RESTRICT Delete operations to the
    // [Unique Table] only then set DeleteGuardian to False.

  {$IFDEF MDAC26}
    Property NamedParams: Boolean Read FNamedParams Write SetNamedParams Default False; // 09.MAR.2001
    // When this Property is true, ADO passes the value of the Name Property of each
    // parameter in the Command’s Parameter collection. The provider uses a parameter
    // name to match parameters in the CommandText or CommandStream properties. If this
    // Property is false (the default), parameter names are ignored and the provider uses
    // the order of parameters to match values to parameters in the CommandText or
    // CommandStream properties.
  {$ENDIF}

    Property CursorLocation Default clUseClient;                           // 11.JUL.2001 by Rudiger Hoppe
    Property CursorType Default ctStatic;                                  // 11.JUL.2001 by Rudiger Hoppe
    Property EnableBCD Default False;                                      // 14.SEP.2001
    Property Version: TADOVersion Read FADOVer Write FADOVer Stored False; // 25.FEB.2002
    Property AutoCalcClear: Boolean Read FAutoCalcClear Write FAutoCalcClear Default True; // 25.FEB.2002
    // The default TDataSet's behavior is to clear calculated fields just before firing the
    // OnCalcFields event. This property when set to False prevents this clearing.

  {$IFDEF DELPHI6_UP}
    Property InitialFetchSize: Integer Read FInitialFetchSize Write FInitialFetchSize Default 0; // 25.FEB.2002
    Property BackgroundFetchSize: Integer Read FBackgroundFetchSize Write FBackgroundFetchSize Default 15; // 25.FEB.2002
    // When a recordset is opened with adAsyncFetch, only those records that are
    // not returned during the initial fetch of records are asynchronously retrieved.
    // If all of the records are returned in the initial fetch, no asynchronous fetching
    // occurs, and the FetchProgress and the FetchComplete event are never raised.
  {$ENDIF}
  End;

  Procedure Register;


IMPLEMENTATION

Uses
  Controls,
  Dialogs,
  SysUtils,
  ActiveX,
  Variants,          // 11.JUL.2001 To support Delphi 6 & 7
  DBConsts,
  ADOConst,          // 05.SEP.2002
  WideStrUtils,
  FMTBcd;

Const
  cNoConnectionObject = 'No Connection Object';
  cNotUsed            = 'Not used';
  cNull               = 'Null';                  //Do not localize!
  cBaseTableName      = 'BASETABLENAME';         //Do not localize!
  cIsAutoIncrement    = 'ISAUTOINCREMENT';       //Do not localize!
  cUniqueTable        = 'Unique Table';          //Do not localize!
  cUpdateCriteria     = 'Update Criteria';       //Do not localize!
  cUniqueSchema       = 'Unique Schema';         //Do not localize!
  cUniqueCatalog      = 'Unique Catalog';        //Do not localize!
  cUpdateResync       = 'Update Resync';         //Do not localize!
  cResyncCommand      = 'Resync Command';        //Do not localize!
  cOLEDBVersion       = 'OLE DB Version';        //Do not localize!
  cProviderName       = 'Provider Name';         //Do not localize!
  cProviderVersion    = 'Provider Version';      //Do not localize!
  cDBMSName           = 'DBMS Name';             //Do not localize!
  cDBMSVersion        = 'DBMS Version';          //Do not localize!
  cDriverODBCVersion  = 'Driver ODBC Version';   //Do not localize!
  cDriverName         = 'Driver Name';           //Do not localize!
  cDriverVersion      = 'Driver Version';        //Do not localize!
  cInitialFetchSize   = 'Initial Fetch Size';    //Do not localize!              // 25.FEB.2002
  cBackgroundFetchSize= 'Background Fetch Size'; //Do not localize!              // 25.FEB.2002
  AsyncOptions        = [eoAsyncExecute, eoAsyncFetch, eoAsyncFetchNonBlocking]; // 25.FEB.2002

Procedure Register;
Begin
  RegisterComponents('dbGo', [TBetterADODataSet]);
End;

Type
  PRecInfo=^TRecInfo;
  TRecInfo=Packed Record
    Bookmark: OleVariant;
    BookmarkFlag: TBookmarkFlag;
    RecordStatus: Integer;
    RecordNumber: Integer;
    End;

Const
  AffectRecordsValues: Array[TAffectRecords] Of TOleEnum = (
    adAffectCurrent,
    adAffectGroup,
    adAffectAll,
    adAffectAllChapters);

// 05.SEP.2002 - Used by the GetFieldData method.
Function FieldListCheckSum(DataSet: TDataset): Integer;
  Var I: Integer;
Begin
  Result:=0;
  For I:=0 To Pred(DataSet.Fields.Count) Do
    Result:=Result+(Integer(Dataset.Fields[I])Shr(I Mod 16));
End;

Function ADOTypeToFieldType(Const ADOType: DataTypeEnum; EnableBCD: Boolean): TFieldType;
Begin
  Case ADOType Of
    adEmpty:
      Result:=ftUnknown;
    adTinyInt,
    adSmallInt:
      Result:=ftSmallint;
    adError,
    adInteger,
    adUnsignedInt:
      Result:=ftInteger;
    adBigInt,
    adUnsignedBigInt:
      Result:=ftLargeInt;
    adUnsignedTinyInt,
    adUnsignedSmallInt:
      Result:=ftWord;
    adSingle,
    adDouble:
      Result:=ftFloat;
    adCurrency:
      Result:=ftBCD;
    adBoolean:
      Result:=ftBoolean;
    adDBDate:
      Result:=ftDate;
    adDBTime: Result:=ftTime;
    adDate,
    adDBTimeStamp,
    adFileTime,
    adDBFileTime:
       Result:=ftDateTime;
    adChar:
      Result:=ftFixedChar;
    adVarChar:
      Result:=ftString;
    adBSTR,
    adWChar,
    adVarWChar:
      Result:=ftWideString;
    adLongVarChar,
    adLongVarWChar:
      Result:=ftMemo;
    adLongVarBinary:
      Result:=ftBlob;
    adBinary:
      Result:=ftBytes;
    adVarBinary:
      Result:=ftVarBytes;
    adChapter:
      Result:=ftDataSet;
    adPropVariant,
    adVariant:
      Result:=ftVariant;
    adIUnknown:
      Result:=ftInterface;
    adIDispatch:
      Result:=ftIDispatch;
    adGUID:
      Result:=ftGUID;
    adDecimal,
    adNumeric,
    adVarNumeric:
      If EnableBCD Then
        Result:=ftBCD
        //Result:=ftFMTBcd //25.FEB.2002
      Else
        Result:=ftFloat;
    Else //Case
      Result:=ftUnknown;
  End; //Case
End;

Function ADOPropertyExists(Const PropList: ADOInt.Properties; Const PropName: WideString): Boolean;
  Var I: Integer;
Begin
  Result:=False;
  For I:=PropList.Count-1 DownTo 0 Do
    If PropList[I].Name=PropName Then Begin
      Result:=True;
      Break;
      End;
End;

Function GetFilterStr(Field: TField; Value: OleVariant; Partial: Boolean): WideString;
  Var Operator,
      FieldName,
      QuoteCh: String;
Begin
  QuoteCh:='';
  Operator:='=';
  FieldName:=Field.FieldName;
  If Pos(' ', FieldName)>0 Then
    FieldName:=Format('[%s]', [FieldName]);
  If VarIsNull(Value) Or VarIsEmpty(Value) Then
    Value:=cNull
  Else
    Case Field.DataType Of
      ftDate, ftTime, ftDateTime:
        QuoteCh:='#';

      ftFloat, ftCurrency, ftBCD: //18.SEP.2003 by Frank van Boven and Eric ten Westenend.
        Value:=StringReplace(VarToStr(Value), DecimalSeparator, '.', []);

      ftString, ftFixedChar, ftWideString: Begin
        If Partial And (Value<>'') Then Begin
          Value:=Value+'*';
          Operator:=' like ';
          End;
        If Pos('''', Value)>0 Then
          QuoteCh:='#'
        Else
          QuoteCh:='''';
        End; //ftString
      End; //Case
  //Result:=Format('(%s%s%s%s%2:s)', [FieldName, Operator, QuoteCh, VarToStr(Value)]);
  Result:=FieldName+Operator+QuoteCh+VarToStr(Value)+QuoteCh;
End;

Function MakeCloneFilter(SrcFilter: String; Const LocateFilter: String): String; // 12.JUN.2001
  Var UpperSrc: String;
      I, Offset, Delta: Integer;
      List: TStringList;
      S: String[32]; // 13.JUN.2001

  Function CheckParenthesis(AString: String): String;
  // This Function was donated by Peter van Logchem
    Var I, IntLeft, IntRight: Integer;
  Begin
    IntLeft:=0;
    IntRight:=0;
    For I:=1 To Length(AString) Do
      If AString[I]='(' Then
        Inc(IntLeft)
      Else If AString[I]=')' Then
        Inc(IntRight);
    I:=IntLeft-IntRight; // 13.JUN.2001
    If I>0 Then Begin
      FillChar(S, Succ(I), ')'); // 13.JUN.2001
      Byte(S[0]):=I; // 13.JUN.2001
      Result:=AString+S;
      End
    Else If I<0 Then Begin
      I:=Abs(I); // 13.JUN.2001
      FillChar(S, Succ(I), '('); // 13.JUN.2001
      Byte(S[0]):=I; // 13.JUN.2001
      Result:=S+AString
      End
    Else
      Result:=AString;
  End; //Function CheckParenthesis

Begin
  Result:='';
  Offset:=1;
  Delta:=0;
  UpperSrc:=UpperCase(SrcFilter);
  List:=TStringList.Create;
  Try
    I:=Pos('OR', UpperSrc);
    If I>1 Then
      Dec(I)
    Else If I=1 Then Begin // 13.JUN.2001
      UpperSrc:=' '+UpperSrc; // 13.JUN.2001
      SrcFilter:=' '+SrcFilter; // 13.JUN.2001
      End;
    While I>0 Do Begin
      If (UpperSrc[I] In [' ', ')']) And (UpperSrc[I+3] In [' ', '(']) Then Begin
        List.Append('( '+CheckParenthesis(Copy(SrcFilter, Offset-Delta, I+Delta))+' AND '+LocateFilter+' )');
        Delete(UpperSrc, 1, I+2);
        Inc(Offset, I+2);
        Delta:=0; // 13.JUN.2001
        I:=Pred(Pos('OR', UpperSrc));
        End
      Else Begin // 13.JUN.2001
        Inc(I, 2);
        Inc(Delta, I);
        Delete(UpperSrc, 1, I);
        Inc(Offset, I);
        I:=Pos('OR', UpperSrc);
        While I=1 Do Begin
          Delete(UpperSrc, 1, 2);
          Inc(Delta, 2);
          Inc(Offset, 2);
          I:=Pos('OR', UpperSrc);
          End;
        If I>1 Then
          Dec(I);
        End; // 13.JUN.2001
      End; //While
    If List.Count = 0 Then
      Result:='( '+SrcFilter+' ) AND ( '+LocateFilter+' )'
    Else Begin
      List.Append('( '+CheckParenthesis(Copy(SrcFilter, Offset-Delta, MaxInt))+' AND '+LocateFilter+' )');
      For I:=0 To Pred(List.Count) Do
        If Result='' Then
          Result:=List[I]
        Else
          Result:=Result+' OR '+List[I];
      End;
  Finally
    List.Free;
    End;
End;

(*********************************************************************************)
(**************************        TADOVersion      ******************************)
(*********************************************************************************)
Function TADOVersion.GetVersion: String; // 14.SEP.2001
Begin
  Result:=BetterADODataSetVersion;
End;

Function TADOVersion.GetProperty(PropertyName: String): String;
Begin
  If Assigned(FOwner) And Assigned(FOwner.Connection) Then
    Try
      Result:=FOwner.Connection.ConnectionObject.Properties[PropertyName].Value
    Except
      Result:=cNotUsed;
      End
  Else
    Result:=cNoConnectionObject;
End;

Function TADOVersion.GetADOVersion: String; // 14.SEP.2001
Begin
  If Assigned(FOwner) And Assigned(FOwner.Connection) Then
    Result:=FOwner.Connection.ConnectionObject.Version
  Else
    Result:=cNoConnectionObject;
End;

Function TADOVersion.GetOLEDBVersion: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cOLEDBVersion);
End;

Function TADOVersion.GetProviderName: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cProviderName);
End;

Function TADOVersion.GetProviderVersion: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cProviderVersion);
End;

Function TADOVersion.GetDBMSName: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cDBMSName);
End;

Function TADOVersion.GetDBMSVersion: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cDBMSVersion);
End;

Function TADOVersion.GetODBCVersion: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cDriverODBCVersion);
End;

Function TADOVersion.GetODBCDriverName: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cDriverName);
End;

Function TADOVersion.GetODBCDriverVersion: String; // 14.SEP.2001
Begin
  Result:=GetProperty(cDriverVersion);
End;

Procedure TADOVersion.SetVersion(Value: String); // 14.SEP.2001
Begin
  // Only needed to make the Property visible in the object inspector
  // so do nothing here.
End;

Constructor TADOVersion.Create(AOwner: TBetterADODataSet);
Begin
  Inherited Create;
  FOwner:=AOwner;
End;



(*********************************************************************************)
(***********************        TBetterADODataSet      ***************************)
(*********************************************************************************)
Constructor TBetterADODataSet.Create(AOwner: TComponent);
Begin
  Inherited Create(AOwner);
  CursorLocation:=clUseClient;
  CursorType:=ctStatic;
  EnableBCD:=False;
  FUniqueTable:='';
  FUniqueSchema:='';
  FUniqueCatalog:='';
  FResyncCommand:=TStringList.Create;
  FUpdateCriteria:=adCriteriaUpdCols;
  FUpdateResync:=[ResyncAutoIncrement, ResyncUpdates, ResyncInserts];
  FRefreshType:=rtResyncCurrent;       // 13.JAN.2001
  {$IFDEF DELPHI6_UP}
  FInitialFetchSize:=0;                // 25.FEB.2002
  FBackgroundFetchSize:=15;            // 25.FEB.2002
  OnRecordsetCreate:=DoRecordsetCreate;// 25.FEB.2002
  {$ENDIF}
  FLockCursor:=Nil;                    // 19.JAN.2001
  FJoinsResolution:=jrAuto;            // 19.JAN.2001
  FJoinTest:=jtInactive;               // 23.JAN.2001
  FDeleteGuardian:=True;               // 23.JAN.2001
  {$IFDEF MDAC26}
  FNamedParams:=False;                 // 09.MAR.2001
  {$ENDIF}
  FADOVer:=TADOVersion.Create(Self);   // 25.FEB.2002
  FModifiedFields:=TList.Create;       // 25.FEB.2002
  FStateBeforePost:=dsInactive;        // 25.FEB.2002
  FAutoCalcClear:=True;                // 25.FEB.2002
End;

Destructor TBetterADODataSet.Destroy;
Begin
  FreeAndNil(FResyncCommand);
  FLockCursor:=Nil;                    // 23.JAN.2001
  FADOVer.Free;                        // 25.FEB.2002
  FreeAndNil(FModifiedFields);         // 25.FEB.2002
  Inherited Destroy;
End;

Procedure TBetterADODataSet.InternalPost;
  Var i: Integer;

  Procedure UpdateData;
    Var j: Integer;
        OField: ADOint.Field;
        BaseTableAssigned: boolean;
        UniqueTableName: String;
        FieldData: PVariantList;
        Data: OleVariant;
        S: String;
  Begin //Procedure UpdateData;
    Try
      If CursorLocation=clUseClient Then
        UniqueTableName:=UpperCase(Recordset.Properties[cUniqueTable].Value)
      Else
        UniqueTableName:='';
      BaseTableAssigned:=UniqueTableName>'';
      FieldData:=PVariantList(ActiveBuffer+SizeOf(TRecInfo));

      For j:=0 To Pred(FModifiedFields.Count) Do With TField(FModifiedFields[j]) Do Begin
        OField:=Recordset.Fields[Pred(FieldNo)];
        Data:=FieldData[Index];
        {$IFDEF DELPHI6_UP}
        If VarIsClear(Data) Or
        {$ELSE}
        If VarIsEmpty(Data) Or     // 25.FEB.2002 by Peter van Logchem
        {$ENDIF}
           (((adFldUpdatable+adFldUnknownUpdatable)And OField.Attributes)=0) Or
           ((FJoinsResolution=jrManual)And Not(pfInUpdate In ProviderFlags)) Or
           ((FJoinsResolution=jrAuto)And
            (FJoinTest=jtJoined)And
            (BaseTableAssigned) And
            (UpperCase(OField.Properties[cBaseTableName].Value)<>UniqueTableName))
        Then // Discard changes to this field.
          S:=UpperCase(OField.Properties[cBaseTableName].Value)
        Else Begin // Propagate changes.
          If DataType=ftLargeint Then // 05.SEP.2002 - Fixes a bug of the inherited method which raises an exception here.
            TVarData(Data).VType:=VT_I8;
          OField.Value:=Data;
          End;
        End; //For

      If (Recordset.EditMode*(adEditInProgress+adEditAdd))<>0 Then Begin
        Recordset.Update(EmptyParam, EmptyParam);
        {$IFDEF DELPHI6_UP}
        Inherited ReleaseLock;
        {$ENDIF}
        ReleaseLock;
        End;
    Except // 25.JAN.2001
      CursorPosChanged; // 25.JAN.2001
      Recordset.CancelUpdate; // 25.JAN.2001
      raise; // 25.JAN.2001
      End; // 25.JAN.2001
  End; //Procedure UpdateData;

  Procedure CheckForFlyAway;
  Begin
    If BookmarkSize>0 Then Try
      { Check for fly away }
      Recordset.Bookmark:=Recordset.Bookmark;
      If Recordset.EOF Or Recordset.BOF Then Begin
        { If recordset is empty, Then this prevents an error calling InternalFirst }
        If Not Recordset.BOF And Recordset.Supports(adMovePrevious) Then
          Recordset.MovePrevious;
        { Reposition to last record we were on }
        CursorPosChanged;
        UpdateCursorPos;
        End;
    Except
      CursorPosChanged;
      End;
  End; //Procedure CheckForFlyAway;

Begin //InternalPost
  For i:=0 To Pred(Fields.Count) Do With Fields[i] Do // 25.FEB.2002
    If Required And(Not ReadOnly)And(FieldKind=fkData)And IsNull Then Begin
      FocusControl;
      DatabaseErrorFmt(SFieldRequired, [DisplayName]);
      End;

  UpdateCursorPos;
  Try
    If State=dsEdit Then
      UpdateData
    Else Begin
      Recordset.AddNew(EmptyParam, EmptyParam);
      Try
        UpdateData;
      Except
        { When Appending recordset may be left in an invalid state, reset it }
        If Recordset.EOF And Recordset.BOF And (Recordset.RecordCount>0) Then
          Recordset.MoveLast;
        Raise;
        End; //Try
      End; //Else
  Except
    On E: Exception Do Begin
      {$IFDEF DELPHI6_UP}
      Inherited ReleaseLock;
      {$ENDIF}
      ReleaseLock;
      DatabaseError(E.Message);
      End;
    End; //Try
  CheckForFlyAway;
End;

Procedure TBetterADODataSet.DoOnNewRecord; // 25.FEB.2002
  Var i: Integer;
Begin
  FModifiedFields.Clear;
  For i:=0 To Pred(Fields.Count) Do With Fields[i] Do
    If DefaultExpression<>'' Then Try
      AsString:=DefaultExpression;
    Except
      On E: Exception Do
        ShowMessage(E.Message);
      End;
  Inherited DoOnNewRecord;
End;

Procedure TBetterADODataSet.InternalEdit;
  Var i: Integer;
Begin
  FModifiedFields.Clear; // 25.FEB.2002

  If Recordset.LockType=adLockPessimistic Then Begin
    UpdateCursorPos;
    FLockCursor:=Recordset.Clone(adLockUnspecified);
    FLockCursor.Bookmark:=Recordset.Bookmark;
    //Find an updatable field, and then assign the existing value to lock.
    FOR I:=0 TO Pred(FLockCursor.Fields.Count) DO
      If ((adFldUpdatable{+adFldUnknownUpdatable})AND Recordset.Fields[I].Attributes)<>0 Then Begin
        FLockCursor.Fields[I].Value:=FLockCursor.Fields[I].Value;
        Break;
      End;
    End;
  //Inherited InternalEdit;
End;

Procedure TBetterADODataSet.InternalCancel;
Begin
  ReleaseLock; // 25.FEB.2002
  Inherited InternalCancel;   // 25.JAN.2001
End;

Procedure TBetterADODataSet.SetUpdateCriteria(Value: TUpdateCriteria);
Begin
  If FUpdateCriteria<>Value Then Begin
    FUpdateCriteria:=Value;
    If Active And (CursorLocation=clUseClient) Then
      RecordSet.Properties[cUpdateCriteria].Value:=FUpdateCriteria;
    End;
End;

Procedure TBetterADODataSet.SetProperty(Var Prop: String; PropertyName, AValue: String);
Begin
  If Prop<>AValue Then Begin
    Prop:=AValue;
    If Active And (CursorLocation=clUseClient) Then
      If AValue>'' Then
        RecordSet.Properties[PropertyName].Value:=AValue
      Else
        RecordSet.Properties[PropertyName].Value:=Unassigned;
    End;
End;

Procedure TBetterADODataSet.SetUniqueTable(Value: String);
Begin
  SetProperty(FUniqueTable, cUniqueTable, Value);
End;

Procedure TBetterADODataSet.SetUniqueSchema(Value: String);
Begin
  SetProperty(FUniqueSchema, cUniqueSchema, Value);
End;

Procedure TBetterADODataSet.SetUniqueCatalog(Value: String);
Begin
  SetProperty(FUniqueCatalog, cUniqueCatalog, Value);
End;

Procedure TBetterADODataSet.SetUpdateResync(Value: TUpdateResync);
  Var I: Integer;
Begin
  If FUpdateResync<>Value Then Begin
    FUpdateResync:=Value;
    If Active And (CursorLocation=clUseClient) Then Begin
      I:=adResyncNone;
      If ResyncAutoIncrement In FUpdateResync Then
        Inc(I,adResyncAutoIncrement);
      If ResyncConflicts In FUpdateResync Then
        Inc(I,adResyncConflicts);
      If ResyncUpdates In FUpdateResync Then
        Inc(I,adResyncUpdates);
      If ResyncInserts In FUpdateResync Then
        Inc(I,adResyncInserts);
      RecordSet.Properties[cUpdateResync].Value:=I;
      End;
    End;
End;

Procedure TBetterADODataSet.SetResyncCommand(Value: TStringList);
Begin
  If FResyncCommand.Text<>Value.Text Then Begin
    FResyncCommand.BeginUpdate;
    Try
      FResyncCommand.Assign(Value);
    Finally
      FResyncCommand.EndUpdate;
      End;
    If Active And (CursorLocation=clUseClient) Then
      If FResyncCommand.Text>'' Then
        RecordSet.Properties[cResyncCommand].Value:=FResyncCommand.Text
      Else
        RecordSet.Properties[cResyncCommand].Value:=Unassigned;
    End;
End;

Function TBetterADODataSet.IsResyncCommandStored: Boolean;
Begin
  Result:=FResyncCommand.Text>'';
End;

Function TBetterADODataSet.GetErrors: ADOInt.Errors; // 13.JAN.2001
Begin
  If Assigned(Connection) Then
    Result:=Connection.ConnectionObject.Errors
  Else
    Result:=Nil;
End;

Procedure TBetterADODataSet.SetJoinTest(Value: TJoinTest);
Begin
  If csDesigning In ComponentState Then
    ShowMessage(
      'Procedure TBetterADODataSet.SetJoinTest(Value: TJoinTest);'+
      #10#13#10#13+
      'The only purpose of this method is to make the'#10#13+
      'JoinTest Property visible in the Object Inspector!'#10#13+
      'Other than that you are not allowed to explicitly'#10#13+
      'set the value of the JoinTest Property. This is'#10#13+
      'done automatically when the DataSet is created/opened/closed.');
End;

Function TBetterADODataSet.GetParamByName(Const ParamName: WideString): TParameter;
Begin
  If Assigned(Parameters) Then
    Result:=Parameters.ParamByName(ParamName)
  Else
    Result:=Nil;
End;

Procedure TBetterADODataSet.DoAfterOpen;
Begin
  InitDynamicProps; // 15.APR.2001
  FJoinTest:=IsJoinedRecordSet;
  Inherited;
End;

Procedure TBetterADODataSet.DoAfterScroll;
Begin
  // 05.SEP.2002
  // Fixes the AsyncFetchNonBlocking problem where the first/last records aren't shown.

  If (eoAsyncFetchNonBlocking In ExecuteOptions)And
     (BOF Or EOF)And
     (CursorLocation=clUseClient)And
     (stFetching In RecordSetState)
  Then begin
    If Recordset.RecordCount>0 Then
      If BOF Then
        Recordset.MoveFirst
      Else If EOF Then
        Recordset.MoveLast;
    CursorPosChanged;
    Resync([]);
    End;
  Inherited;
End;

Procedure TBetterADODataSet.DoAfterClose;
Begin
  FJoinTest:=jtInactive;
  ReleaseLock;
  Inherited;
End;

Procedure TBetterADODataSet.Requery(Options: TExecuteOptions);
Begin
  ReleaseLock;
  If Assigned(Errors) Then
    Errors.Clear;
  If Not Active Then  //25.FEB.2002 - No need to be active to call Requery - very handy.
    Open              //25.FEB.2002
  Else Begin
    Inherited Requery(Options);
    InitDynamicProps; // 15.APR.2001
    End;
End;

Procedure TBetterADODataSet.Requery;
Begin
  Requery(ExecuteOptions);
End;

Procedure TBetterADODataSet.Resync(AffectRecords: AffectEnum; ResyncValues: ResyncEnum);
Begin
  If (AffectRecords=adAffectCurrent) And
     ((Recordset.RecordCount=0) Or // 15.FEB.2001
      (Recordset.BOF) Or
      (Recordset.EOF))
  Then // 04.JUN.2001
    Exit; // This operation requires a current record so better do nothing rather than let ADO raise an Exception.

  If Assigned(Errors) Then
    Errors.Clear;

  Inherited DoBeforeRefresh;
  CheckBrowseMode;
  UpdateCursorPos;
  Try
    Recordset.Resync(AffectRecords, ResyncValues);
  Finally
    Inherited Resync([]);
    DoAfterRefresh;
    End; //Try
End;

Procedure TBetterADODataSet.Refresh; // 05.FEB.2001
  Var FilterKind: Integer;
Begin
  Case FRefreshType Of
    rtRequery: Begin
      Inherited DoBeforeRefresh;
      Requery;
      DoAfterRefresh;
      End; //rtRequery
    rtResyncCurrent:
      Resync; // Current record only
    rtResyncGroup: Begin
      FilterKind:=VarType(RecordSet.Filter);
      If ((FilterKind=varInteger) Or
          (FilterKind=varSmallint) Or
          (FilterKind=varByte) Or
          ((FilterKind And varArray)=varArray))
      Then // Supported combination
        Resync(adAffectGroup)
      Else // Unsupported combination so
        Resync; // Current record only
      End; // rtResyncGroup
    rtResyncAll:
      Resync(adAffectAll);
    rtResyncChapters:
      Resync(adAffectAllChapters);
    End; //Case
End;

Procedure TBetterADODataSet.CancelBatch(AffectRecords: TAffectRecords);
  Var FocusInvalid: Boolean; // 14.FEB.2001
Begin
ShowMessage('0');
  Cancel;
ShowMessage('1');
  UpdateCursorPos;
ShowMessage('2');
  FocusInvalid:=(Recordset.Status And adRecNew = adRecNew); // 14.FEB.2001
ShowMessage('3');
  Recordset.CancelBatch(AffectRecordsValues[AffectRecords]);
ShowMessage('4');

  If FocusInvalid Or // 14.FEB.2001 Fixes a nasty bug of the inherited CancelBatch.
    (Recordset.EOF And RecordSet.BOF And (Recordset.RecordCount>0)) // If all records were previously deleted, ADO does not reset EOF flag.
  Then
    Recordset.MoveFirst
  Else
    UpdateCursorPos;

  Resync([]);
End;

Function TBetterADODataSet.GetCanModify: Boolean; // 04.MAR.2001 by J.Christin
Begin
  If Active Then
    Result:=Inherited GetCanModify
  Else //The inherited method causes an access violation in this case.
    Result:=False;
End;

Function TBetterADODataSet.Locate(Const KeyFields: String; Const KeyValues: Variant; Options: TLocateOptions): Boolean; Var S: String;
Begin
  CheckBrowseMode; //29.SEP.2001 by Peter Arnold
  S:=RecordSet.Filter;
  {If (S='0') And (Pos(';', KeyFields)=0) Then // Non-filtered RecordSet, single column search. This is the only combination ADOExpress is capable of handling correctly.
    Result:=Inherited Locate(KeyFields, KeyValues, Options) // We call the Inherited Locate here to reuse the inherited FLookupCursor If available.
  Else} Begin // ADOExpress can't handle this case so we'll have to.
    Inherited DoBeforeScroll;
    Result:=CorrectlyLocateRecord(KeyFields, KeyValues, Options, True); //This does the dirty work.
    If Result Then Begin
      Inherited Resync([rmExact, rmCenter]);
      Inherited DoAfterScroll;
      End;
    End;
End;

Function TBetterADODataSet.Lookup(Const KeyFields: String;
                                  Const KeyValues: Variant;
                                  Const ResultFields: String): Variant;
Begin
  Result:=Null;
  If CorrectlyLocateRecord(KeyFields, KeyValues, [], False) Then Begin
    SetTempState(dsCalcFields);
    Try
      CalculateFields(TempBuffer);
      Result:=FieldValues[ResultFields];
    Finally
      RestoreState(dsBrowse);
      End; //Try
    End; //If
End;

Function TBetterADODataSet.CorrectlyLocateRecord(Const KeyFields: String;
                                                 Const KeyValues: OleVariant;
                                                 Options: TLocateOptions;
                                                 SyncCursor: Boolean): Boolean;
  Var Fields: TList;
      Buffer: PChar;
    //  Buffer: TRecordBuffer;
      I, FieldCount: Integer;
      Partial: Boolean;
      SortList, FieldExpr, LocateFilter: String;
      SrcFilter: OleVariant;
Begin
  //CheckBrowseMode;
  UpdateCursorPos;
  CursorPosChanged;
  Buffer:=TempBuffer;
  Partial:=loPartialKey In Options;
  Fields:=TList.Create;
  Try //1
    Try //2
      //DoBeforeScroll;
      GetFieldList(Fields, KeyFields);
      FieldCount:=Fields.Count;
      If Not Assigned(FLookupCursor) Then //29.SEP.2001
        FLookupCursor:=RecordSet.Clone(adLockReadOnly);
      If CursorLocation=clUseClient Then Begin
        For I:=0 To Pred(FieldCount) Do With TField(Fields[I]) Do
          If Pos(' ', FieldName)>0 Then
            SortList:=Format('%s[%s],', [SortList, FieldName])
          Else
            SortList:=Format('%s%s,', [SortList, FieldName]);
        SetLength(SortList, Pred(Length(SortList))); //To remove the trailing comma.
        FLookupCursor.Sort:=SortList;
        End; //If CursorLocation

      SrcFilter:=RecordSet.Filter;
      If FieldCount=1 Then // We support all types of filters here because we are going to use the Find method.
        FLookupCursor.Filter:=SrcFilter
      Else // We can only support string filters here because we'll have to use a string filter to do the actual searching on multiple columns.
        Case VarType(SrcFilter) Of
          varOleStr, varStrArg, varString:
            If SrcFilter<=' ' Then
              SrcFilter:=0;
          Else //Case
            SrcFilter:=0;
          End; //Case

      SetTempState(dsFilter);
      Try //3
        InitRecord(Buffer);
        If FieldCount=1 Then
          FLookupCursor.Find(GetFilterStr(FieldByName(KeyFields), KeyValues, Partial), 0, adSearchForward, EmptyParam)
        Else Begin //1
          For I:=0 To Pred(FieldCount) Do Begin
            FieldExpr:=GetFilterStr(Fields[I], KeyValues[I], Partial {And (I=FieldCount-1)});
            If LocateFilter<>'' Then                                 //I really don't know why Borland put the above there but it breaks partial searching so I commented it out.
              LocateFilter:=LocateFilter+' AND '+FieldExpr
            Else
              LocateFilter:=FieldExpr;
            End; //For
          If VarAsType(SrcFilter, varOleStr)='0' Then
            FLookupCursor.Filter:=LocateFilter
          Else Begin //2
            If (Pos(' OR ', UpperCase(SrcFilter)) = 0) And
               (Pos(')OR(', UpperCase(SrcFilter)) = 0) And
               (Pos(')OR ', UpperCase(SrcFilter)) = 0) And
               (Pos(' OR(', UpperCase(SrcFilter)) = 0)
            Then
              FLookupCursor.Filter:='('+SrcFilter+') AND ('+LocateFilter+')'
            Else Begin //3
              // Here we need to merge the SrcFilter and the LocateFilter so that
              // the resulting compound conforms to the ADO filter format.
              // eg: ((...)AND(...)) OR ((...)AND(...)) OR ((...)AND(...)) OR ...
              FLookupCursor.Filter:=MakeCloneFilter(SrcFilter, LocateFilter); // 12.JUN.2001
              End; //3
            End; //2
          End; //1
      Finally
        RestoreState(dsBrowse);
        End; //Try 3
    Finally
      Fields.Free;
      End; //Try 2
    Result:=Not(FLookupCursor.EOF Or FLookupCursor.BOF);
    If Result Then Begin
      If SyncCursor Then Begin // 30.AUG.2001
        Recordset.Bookmark:=FLookupCursor.Bookmark;
        If Recordset.EOF Or Recordset.BOF Or (Recordset.Bookmark<>FLookupCursor.Bookmark) Then Begin
          Result:=False;
          CursorPosChanged;
          End;
        End
      Else Begin // 30.AUG.2001 This block added to support lookups
        // For lookups, read all field values into the temp buffer
        For I:=0 To Pred(Self.Fields.Count) Do With Self.Fields[I] Do
          If FieldKind=fkData Then
            PVariantList(Buffer+SizeOf(TRecInfo))[Index]:=FLookupCursor.Fields[Pred(FieldNo)].Value;
        End; // 30.AUG.2001
      End; //If Result
  Except
    Result:=False;
    End; //Try 1
End;

{$IFNDEF DELPHI6_UP}
Procedure TBetterADODataSet.GetDetailLinkFields(MasterFields, DetailFields: TList);

  Function AddFieldToList(Const FieldName: string; DataSet: TDataSet; List: TList): Boolean;
    Var Field: TField;
  Begin
    Field:=DataSet.FindField(FieldName);
    If (Field<>Nil) Then
      List.Add(Field);
    Result:=Field<>Nil;
  End;

  Var i: Integer;
      Idx: TIndexDef;
Begin
  MasterFields.Clear;
  DetailFields.Clear;
  If (DataSource<>Nil)And(DataSource.DataSet<>Nil) Then Begin
    If Parameters.Count>0 Then Begin
      For i:=0 To Pred(Parameters.Count) Do
        If AddFieldToList(Parameters[i].Name, DataSource.DataSet, MasterFields) Then
          AddFieldToList(Parameters[i].Name, Self, DetailFields)
      End
    Else If (Self.MasterFields<>'') Then Begin
      Idx:=Nil;
      DataSource.DataSet.GetFieldList(MasterFields, Self.MasterFields);
      UpdateIndexDefs;
      If IndexName<>'' Then
        Idx:=IndexDefs.Find(IndexName)
      Else If IndexFieldNames<>'' Then
        Idx:=IndexDefs.GetIndexForFields(IndexFieldNames, False)
      Else For i:=0 To Pred(IndexDefs.Count) Do
        If ixPrimary In IndexDefs[i].Options Then Begin
          Idx:=IndexDefs[i];
          break;
          End;
      If Idx<>Nil Then
        GetFieldList(DetailFields, Idx.Fields);
      End;
    End;
End;
{$ENDIF}

Procedure TBetterADODataSet.SetFilterText(Const Value: String); // 12.JUN.2001
  Var S: String;
Begin
  If Value<>Filter Then Begin
    S:=StringReplace(Value, 'OR(', 'OR (', [rfReplaceAll, rfIgnoreCase]);
    S:=StringReplace(S, 'AND(', 'AND (', [rfReplaceAll, rfIgnoreCase]);
    Inherited SetFilterText(S);
    End;
End;

Function TBetterADODataSet.FindRecord(Restart, GoForward: Boolean): Boolean; //29.SEPT.2001
Begin
  Result:=False;
  SetFound(False);
  CheckBrowseMode;
  UpdateCursorPos;
  CursorPosChanged;
  DoBeforeScroll;

  If Restart Then
    FFindCursor:=Nil;
  If Not Assigned(FFindCursor) Then
    FFindCursor:=Recordset.Clone(adLockReadOnly);
  FFindCursor.Filter:=Recordset.Filter;
  If Not Restart Then
    FFindCursor.Bookmark:=Recordset.Bookmark;

  If GoForward Then
    If Restart Then
      FFindCursor.MoveFirst
    Else
      FFindCursor.MoveNext
  Else
    If Restart Then
      FFindCursor.MoveLast
    Else
      FFindCursor.MovePrevious;

  If Not (FFindCursor.BOF Or FFindCursor.EOF) Then Begin
    // This check (supplied by Peter van Logchem) prevents the famous
    // "Either BOF Or EOF is true" error that occurs at the line below.
    Recordset.Bookmark:=FFindCursor.Bookmark;
    SetFound(True);
    Result:=True;
    Resync([rmExact, rmCenter]);
    DoAfterScroll;
    End;
End;

Procedure TBetterADODataSet.InternalClose; //29.SEP.2001 by Peter van Logchem
Begin
  DestroyLookupCursor; //25.FEB.2002
  Inherited;
End;

Procedure TBetterADODataSet.DestroyLookupCursor; //29.SEP.2001 by Peter van Logchem
Begin
  FFindCursor:=Nil;
  FLookupCursor:=Nil; //29.SEP.2001 by me.
  Inherited;
End;

Procedure TBetterADODataSet.DoBeforeRefresh;
Begin
  Refresh; // Call our own Refresh here.
  Abort;   // And abort the inherited one.
End;

Procedure TBetterADODataSet.DoBeforeOpen;
Begin
  If Assigned(Errors) Then
    Errors.Clear;
  Inherited;
End;

Function TBetterADODataSet.IsJoinedRecordSet: TJoinTest;
  Var I: Integer;
      S: String;
Begin
  If Not Active Then Begin
    Result:=jtInactive;
    Exit;
    End;
  Result:=jtNotJoined;

  If (CursorLocation=clUseServer) And  //25.FEB.2002
     Assigned(Connection) And
     (Pos('MYSQL', AnsiUpperCase(Connection.Provider))>0)
  Then
    Exit; //The Collibri-Soft MySQL provider doesn't support the 'BaseTableName'
          //dynamic property so automatic joins resolution can't work with it.
          //You may still use manual resolution though.
          //Reported by Michael Collier - mike@adoanywhere.com

  S:=VarToStr(RecordSet.Fields[0].Properties[cBaseTableName].Value);
  For I:=Pred(RecordSet.Fields.Count) DownTo 1 Do With RecordSet.Fields Do
    If (S<>VarToStr(Item[I].Properties[cBaseTableName].Value)) Then Begin
      Result:=jtJoined;
      Break;
      End;
End;

Procedure TBetterADODataSet.DeleteRecords(AffectRecords: TAffectRecords);
Begin
  CheckActive;
  UpdateCursorPos;
  CursorPosChanged;

  // This hack for deleting all records was provided by Harry Van Tassel.
  // Harry warns that it may not work in all cases but he doesn't remember why.
  // I don't have a clue either.<g>

  Try
    If (AffectRecords=arAll) Or
       (AffectRecords=arAllChapters) {12.MAR.2001} //Well, maybe this is what Harry couldn't remember above.
    Then With RecordSet Do Begin
      If RecordCount>0 Then Begin
        MoveFirst;
        While Not EOF Do Begin
          Delete(adAffectCurrent);
          MoveNext;
          End;
        Self.Resync([]);
        Exit;
        End;
      End
    Else
      Recordset.Delete(AffectRecordsValues[AffectRecords]);

    // When CacheSize > 1, Recordset allows fetching of deleted records.
    // Calling MovePrevious seems to work around it.
    If (CacheSize>1)And(PRecInfo(ActiveBuffer).RecordNumber<>1) Then Begin
      Recordset.MovePrevious;
      Recordset.MoveNext;
      End;
    Recordset.MoveNext;
  Except
    On E: Exception Do Begin
      Recordset.CancelUpdate;
      DatabaseError(E.Message);
      End;
    End; //Try

  Resync([]);
End;

Procedure TBetterADODataSet.DoBeforeDelete;
Begin
  If FDeleteGuardian And
     Active And
     (CursorLocation=clUseClient) And
     (FJoinTest=jtJoined) And
     (FUniqueTable='') And
     (MessageDlg('This is a JOINED ResultSet and the [Unique Table] Dynamic Property was'+
                 #13#10#13#10+
                 '                             NOT SET !'+
                 #13#10#13#10+
                 'Do you wish to delete the underlying rows from ALL Base Tables ?',
                 mtWarning, [mbNo, mbYes], 0)=mrNo)
  Then
    Abort;
  Inherited DoBeforeDelete;
End;

Procedure TBetterADODataSet.InternalInitFieldDefs;
  Var HasAutoIncProp: Boolean;
      Count, I: Integer;

  Procedure AddFieldDef(F: ADOInt.Field; FieldDefs: TFieldDefs);
    Var FieldType: TFieldType;
        FieldDef: TFieldDef;
        I, FSize, FPrecision: Integer;
        FName: string;
  Begin

    if (F.Type_=adDecimal) And (F.Precision>15)
    then FieldType:=ADOTypeToFieldType(F.Type_, True)  // 25.FEB.2002
    else FieldType:=ADOTypeToFieldType(F.Type_, EnableBCD);


    If FieldType<>ftUnknown Then Begin
      FSize:=0;
      FPrecision:=0;
      FieldDef:=FieldDefs.AddFieldDef;
{
      if FieldType=ftTime then begin // scholz
       ShowMessage(F.Name+' '+IntToStr(F.Type_));
       ShowMessage(IntToStr(F.NumericScale));
       ShowMessage(IntToStr(F.Precision));
      end;
}
      With FieldDef DO Begin
        FieldNo:=FieldDefs.Count;
        I:=0;
        FName:=F.Name;
        while (FName='') OR (FieldDefs.IndexOf(FName) >= 0) do begin
              Inc(I);
              if F.Name=''
              then FName:=Format('COLUMN%d', [I])
              else FName:=Format('%s_%d', [F.Name, I]);
        end;
        Name:=FName;

        if (F.Type_=adNumeric) and (F.NumericScale=0) and (F.Precision<10) then FieldType:=ftInteger; // 25.FEB.2002
        if (FieldType=ftString) and (F.DefinedSize > dsMaxStringSize) then FieldType:=ftMemo; // 25.FEB.2002 by Ben Geerdes & Peter van Logchem

        Case FieldType Of
          ftString, ftWideString, ftBytes, ftVarBytes, ftFixedChar, ftFixedWideChar: FSize:=F.DefinedSize;
          ftBCD, ftFMTBCD: Begin
            FPrecision:=F.Precision;
            FSize:=ShortInt(F.NumericScale);
            If FSize<0 Then FSize:=4;
            End;
          ftInteger: If HasAutoIncProp And(F.Properties[cIsAutoIncrement].Value=True) Then FieldType:=ftAutoInc;
          ftGuid: FSize:=38;
        end; //Case

        If ((adFldRowID And F.Attributes)<>0) Then Attributes:=Attributes+[faHiddenCol];
        If ((adFldFixed And F.Attributes)<>0) Then Attributes:=Attributes+[faFixed];

        If (FieldType<>ftBoolean) And                  // 04.JUN.2001 by Joerg
           ((adFldIsNullable And F.Attributes)=0)      // 13.MAR.2001
        Then
          Attributes:=Attributes+[faRequired];         // Initialize Required fields as appropriate.

        If (((adFldUpdatable+adFldUnknownUpdatable)And F.Attributes)=0)Or(FieldType=ftAutoInc) Then
          Attributes:=Attributes+[DB.faReadOnly]-[faRequired];
{
      if FieldType=ftTime then begin // scholz
       ShowMessage(Name);
       ShowMessage(IntToStr(Size));
       ShowMessage(IntToStr(Precision));
      end;
}

        DataType:=FieldType;
        Size:=FSize;
        Precision:=FPrecision;
        If (DataType=ftDataSet) And (Fields.Count=0) Then ObjectView:=True;


        End; //With FieldDef DO Begin
      End; //If FieldType<>ftUnknown Then Begin
  End; //Procedure AddFieldDef

Begin //InternalInitFieldDefs
  FieldDefs.Clear;
  Count:=Recordset.Fields.Count;
  If Count>0 Then // Determine If the field's Property list contains an ISAUTOINCREMENT entry.
    HasAutoIncProp:=ADOPropertyExists(Recordset.Fields[0].Properties, cIsAutoIncrement);
  For I:=0 To Pred(Count) Do AddFieldDef(Recordset.Fields[I], FieldDefs);
End;

{$IFDEF MDAC26}
Procedure TBetterADODataSet.SaveToADOStream(Destination: OleVariant; PersistFormat: TPersistFormat); // 09.MAR.2001
Begin
  CheckBrowseMode;
  ADO26_TLB._Recordset(RecordSet).Save(Destination, PersistFormatEnum(PersistFormat));
  CursorPosChanged;
End;

Procedure TBetterADODataSet.LoadFromADOStream(Source: ADO26_TLB._Stream); // 09.MAR.2001
  Var _RS: ADO26_TLB._Recordset;
Begin
  If VarIsEmpty(Source) Or VarIsNull(Source) Then Begin
    MessageDlg('TBetterADODataSet.LoadFromADOStream:#10#13Can not load from a Nil _Stream.', mtError, [mbOK], 0);
    Abort;
    End;
  _RS:=ADO26_TLB.CoRecordset.Create;
  Try
    _RS.Open(Source, EmptyParam, adOpenUnspecified, adLockUnspecified, -1{adCmdUnspecified});
    Close;
    CommandType:=cmdFile;
    LockType:=ltBatchOptimistic;
    CommandText:='';
    RecordSet:=ADOInt._Recordset(_RS);
  Finally
    _RS:=Nil;
    End;
End;

Function TBetterADODataSet.GetString(NumRows: Integer;
                                     StartPos: TStartPos;
                                     Const ColumnDelimeter: WideString;
                                     Const RowDelimeter: WideString;
                                     Const NullExpr: WideString): WideString;
  Var BookMark: OleVariant;
Begin
  If NumRows<1 Then
    NumRows:=-1; // Must be either -1 Or greater than 0.
  BookMark:=Recordset.Bookmark;
  Try
    If StartPos=spFirstRecord Then
      Recordset.MoveFirst;
    Result:=Recordset.GetString(adClipString, NumRows, ColumnDelimeter, RowDelimeter, NullExpr);
  Finally
    Recordset.Bookmark:=BookMark;
    End; //Try
End;

Procedure TBetterADODataSet.SetNamedParams(Value: Boolean); // 09.MAR.2001
Begin
  If FNamedParams<>Value Then Begin
    FNamedParams:=Value;
    If Assigned(Command) And Assigned(Command.CommandObject) Then
      ADO26_TLB._Command(Command.CommandObject).NamedParameters:=FNamedParams;
    End;
End;

Function TBetterADODataSet.GetFieldStatus(Const FieldName: WideString): FieldStatusEnum;
  Var F: ADO26_TLB.Field;
Begin
  F:=ADO26_TLB.Field(RecordSet.Fields[FieldName]);
  Try
    Result:=F.Status;
  Finally
    F:=Nil;
    End;
End;
{$ENDIF}


Procedure TBetterADODataSet.ClearCalcFields(Buffer: PChar);
  Var i: Integer;
Begin
  If FAutoCalcClear Then
    Inherited ClearCalcFields(Buffer)
  Else If CalcFieldsSize>0 Then
    For i:=0 To Pred(Fields.Count) Do With Fields[i] Do
      If FieldKind In [fkLookup] Then
        PVariantList(Buffer+SizeOf(TRecInfo))[Index]:=Null;
End;


(*procedure TBetterADODataSet.ClearCalcFields(Buffer: TRecordBuffer);
var
  I: Integer;
begin
  if FAutoCalcClear
  then inherited ClearCalcFields(Buffer)
  else if CalcFieldsSize > 0 then
          for I := 0 to Fields.Count - 1 do
            with Fields[I] do
              if FieldKind in [fkLookup] then
                PVariantList(Buffer+SizeOf(TRecInfo))[Index] := Null;
end;*)

Function TBetterADODataSet.GetFieldData(Field: TField; Buffer: Pointer; NativeFormat: Boolean): Boolean;
  Var RecBuf: PChar;
      //RecBuf:TRecordBuffer;
      Data: OleVariant;

  procedure CurrToBuffer(Const C: Currency);
  begin
    if NativeFormat
    then DataConvert(Field, @C, Buffer, True)
    else Currency(Buffer^):=C;
  end;

  Procedure VarToBuffer;
  Begin
    With tagVariant(Data) Do
      Case Field.DataType Of
        ftGuid, ftFixedChar, ftString: Begin
          PAnsiChar(Buffer)[Field.Size] := #0;
          WideCharToMultiByte(0, 0, bStrVal, SysStringLen(bStrVal)+1, Buffer, Field.Size, nil, nil);
          End;
        ftFixedWideChar, ftWideString:
          WStrCopy(Buffer, bstrVal);
        ftSmallint:
          If vt=VT_UI1
          Then SmallInt(Buffer^):=Byte(cVal)
          Else SmallInt(Buffer^):=iVal;
        ftWord:
          If vt=VT_UI1
          Then Word(Buffer^):=bVal
          Else Word(Buffer^):=uiVal;
        ftAutoInc, ftInteger:
          if (vt=VT_DECIMAL) and (tagDEC(Data).sign>0) // 05.SEP.2002 - Deal with DECIMAL(x.0) here.
          then Integer(Buffer^):=-1*lVal
          else Integer(Buffer^):=lVal;
        ftFloat, ftCurrency:
          If vt=VT_R8
          Then Double(Buffer^):=dblVal
          Else Double(Buffer^):=Data;
        ftBCD:
          If vt=VT_CY
          Then CurrToBuffer(cyVal)
          Else CurrToBuffer(Data);
        ftBoolean:
          WordBool(Buffer^):=vbool;
        ftDate, ftDateTime:
          {
          if NativeFormat
          then DataConvert(Field, @date, Buffer, True)
          else TOleDate(Buffer^):=date;
          }
          begin
          if NativeFormat
          then ShowMessage(Field.FieldName+': ftDate NativeFormat')
          else ShowMessage(Field.FieldName+': ftDate kein NativeFormat');
          if NativeFormat
          then DataConvert(Field, @date, Buffer, True)
          else TOleDate(Buffer^):=date;

//        DataConvert(Field, @date, Buffer, True);
          end;
        ftTime: // scholz
          {
          if NativeFormat
          then DataConvert(Field, @date, Buffer, True)
          else TOleDate(Buffer^):=date;
          }
          begin
          if NativeFormat
          then ShowMessage(Field.FieldName+': ftTime NativeFormat')
          else ShowMessage(Field.FieldName+': ftTime kein NativeFormat');
          if NativeFormat
          then DataConvert(Field, @date, Buffer, True)
          else TOleDate(Buffer^):=date;
//        DataConvert(Field, @date, Buffer, True);
          end;
        ftBytes, ftVarBytes:
          if NativeFormat
          then DataConvert(Field, @Data, Buffer, True)
          else OleVariant(Buffer^):=Data;
        ftInterface: IUnknown(Buffer^):=Data;
        ftIDispatch: IDispatch(Buffer^):=Data;
        ftLargeInt:
          if Decimal(Data).sign > 0
          then LargeInt(Buffer^):=-1*Decimal(Data).Lo64
          else LargeInt(Buffer^):=Decimal(Data).Lo64;
        ftBlob..ftTypedBinary, ftVariant, ftWideMemo: OleVariant(Buffer^) := Data;
      Else
        DatabaseErrorFmt(SUsupportedFieldType, [FieldTypeNames[Field.DataType], Field.DisplayName]);
        End; //Case
  End; //VarToBuffer

  Procedure RefreshBuffers;
  Begin
    Reserved:=Pointer(FieldListCheckSum(Self));
    UpdateCursorPos;
    Resync([]);
  End;

BEGIN //GetFieldData
  if not Assigned(Reserved) then RefreshBuffers;
  Result:=GetActiveRecBuf(RecBuf);
  if not Result then Exit;

  Data:=PVariantList(RecBuf+SizeOf(TRecInfo))[Field.Index];

  if VarIsClear(Data) and (Field.FieldNo>0) then begin
    { Don't try to read data from a deleted record }
    if (PRecInfo(RecBuf)^.RecordStatus And adRecDeleted)=0 then begin
       UpdateRecordSetPosition(RecBuf);

       Case Field.DataType Of
         ftDate: ShowMessage(Field.FieldName+': ftDate Hallo');
         ftDateTime: ShowMessage(Field.FieldName+': ftDateTime Hallo');
         ftTime: ShowMessage(Field.FieldName+': ftTime Hallo');
       end;
       if Field.DataType=ftTime
       then Data:=0.5
       else Data:=Recordset.Fields[Field.FieldNo-1].Value; // hier kommt der Fehler
       ShowMessage('OK');

//       Data:=Recordset.Fields[Field.FieldNo-1].Value; // hier kommt der Fehler
    end;

    If VarIsClear(Data) then Data:=Null;

    PVariantList(RecBuf+SizeOf(TRecInfo))[Field.Index]:=Data;
  end;

  Result:=Not VarIsNull(Data);


  If Result And (Buffer<>Nil) Then VarToBuffer;
END; //GetFieldData

{
  Type  (in ADODB)
  PVariantList = ^TVariantList;
  TVariantList = array[0..0] of OleVariant;
}
Procedure TBetterADODataSet.SetFieldData(Field: TField; Buffer: Pointer; NativeFormat: Boolean); // scholz

  procedure BufferToVar(var Data: OleVariant);
  begin
    case Field.DataType of
      ftString, ftFixedChar, ftGuid:
        Data := AnsiString(PAnsiChar(Buffer));
      ftWideString, ftFixedWideChar:
        Data := WideString(PWideChar(Buffer));
      ftAutoInc, ftInteger:
        Data := LongInt(Buffer^);
      ftSmallInt:
        Data := SmallInt(Buffer^);
      ftWord:
        Data := Word(Buffer^);
      ftBoolean:
        Data := WordBool(Buffer^);
      ftFloat, ftCurrency:
        Data := Double(Buffer^);
      ftBlob, ftMemo, ftGraphic, ftVariant, ftWideMemo:
        Data := Variant(Buffer^);
      ftInterface:
        Data := IUnknown(Buffer^);
      ftIDispatch:
        Data := IDispatch(Buffer^);
      ftDate, ftDateTime:

        if NativeFormat
        then DataConvert(Field, Buffer, @TVarData(Data).VDate, False)
        else Data := TDateTime(Buffer^);

      ftTime:

        if NativeFormat
        then DataConvert(Field, Buffer, @TVarData(Data).VDate, False)
        else Data := TDateTime(Buffer^);

      ftFMTBCD:
        Data := VarFMTBcdCreate(TBcd(Buffer^));
      ftBCD:
        if NativeFormat
        then DataConvert(Field, Buffer, @TVarData(Data).VCurrency, False)
        else Data := Currency(Buffer^);
      ftBytes, ftVarBytes:
        if NativeFormat
        then DataConvert(Field, Buffer, @Data, False)
        else Data := OleVariant(Buffer^);
      ftLargeInt:
        Data := LargeInt(Buffer^);
      else
        DatabaseErrorFmt(SUsupportedFieldType, [FieldTypeNames[Field.DataType], Field.DisplayName]);
    end;
  end;

var
  Data: OleVariant;
  RecBuf: PChar;
  //RecBuf: TRecordBuffer;
Begin
//  Inherited SetFieldData(Field, Buffer, NativeFormat);

  with Field do begin
       if not (State in dsWriteModes) then DatabaseError(SNotEditing, Self);
       GetActiveRecBuf(RecBuf);
       if FieldNo > 0 then begin
          if ReadOnly and not (State in [dsSetKey, dsFilter]) then DatabaseErrorFmt(SFieldReadOnly, [DisplayName]);
          Validate(Buffer);
          if FModifiedFields.IndexOf(Field) = -1 then FModifiedFields.Add(Field);
       end;

       if Buffer = nil
       then Data := Null
       else BufferToVar(Data);

       PVariantList(RecBuf+SizeOf(TRecInfo))[Field.Index] := Data;

       if not (State in [dsCalcFields, dsInternalCalc, dsFilter, dsNewValue]) then
          DataEvent(deFieldChange, Longint(Field));

       If (FieldNo>0) And (FModifiedFields.IndexOf(Field)=-1) Then FModifiedFields.Add(Field); // hinzugefügt
  end;
End; //SetFieldData

{$IFDEF DELPHI6_UP}
Procedure TBetterADODataSet.DoRecordsetCreate(DataSet: TCustomADODataSet; Const Recordset: ADODB._Recordset);
Begin
  If Recordset.CursorLocation=adUseClient Then Begin
    Recordset.Properties[cInitialFetchSize].Value:=FInitialFetchSize;
    Recordset.Properties[cBackgroundFetchSize].Value:=FBackgroundFetchSize;
    End;
End;
{$ENDIF}
Procedure TBetterADODataSet.ReleaseLock;
Begin
  If Assigned(FLockCursor) Then Begin
    FLockCursor.CancelUpdate;
    FLockCursor:=nil;
    End;
End;

Procedure TBetterADODataSet.DoBeforePost; // 25.FEB.2002
Begin
  FStateBeforePost:=State;
  Inherited DoBeforePost;
End;

Procedure TBetterADODataSet.DoBeforeCancel; // 25.FEB.2002
Begin
  FStateBeforePost:=State;
  Inherited DoBeforeCancel;
End;

Procedure TBetterADODataSet.Loaded; // 09.MAR.2001
Begin
  Inherited Loaded;
  {$IFDEF MDAC26}
  If Assigned(Command) And Assigned(Command.CommandObject) Then
    ADO26_TLB._Command(Command.CommandObject).NamedParameters:=FNamedParams;
  {$ENDIF}
End;

Procedure TBetterADODataSet.CreateFields;
  Var I: Integer;
      F: TField;
      S: String;
Begin
  If ObjectView Then Begin
    For I:=0 To Pred(FieldDefs.Count) Do With FieldDefs[I] Do
      If (DataType<>ftUnknown) And Not((faHiddenCol In Attributes)And Not FIeldDefs.HiddenFields) Then
        CreateField(Self);
    End    
  Else Begin
    For I:=0 To Pred(FieldDefList.Count) Do With FieldDefList[I] Do
      If (DataType<>ftUnknown) And
         Not(DataType In ObjectFieldTypes) And
         Not((faHiddenCol In Attributes) And Not FIeldDefs.HiddenFields)
      Then Begin
        S:=FieldDefList.Strings[I];
        F:=CreateField(Self, Nil, S);
        If DataType=ftAutoInc Then        // 14.MAR.2001
          F.AutoGenerateValue:=arAutoInc; // 14.MAR.2001
        End;
    End; //Else
End;

Procedure TBetterADODataSet.MasterChanged(Sender: TObject);
Begin
  If Not Active Then
    Exit;
  If Parameters.Count=0 Then Begin
    CheckBrowseMode;
    If SetDetailFilter Then
      First;
    End
  Else Begin
    RefreshParams;
    InitDynamicProps; // 15.APR.2001
    End;
End;

Procedure TBetterADODataSet.InitDynamicProps; // 15.APR.2001
  Var I: Integer;
Begin
  If Active And(CursorLocation=clUseClient) Then Begin
    RecordSet.Properties[cUpdateCriteria].Value:=FUpdateCriteria;
    If FUniqueCatalog>'' Then
      RecordSet.Properties[cUniqueCatalog].Value:=FUniqueCatalog;
    If FUniqueSchema>'' Then
      RecordSet.Properties[cUniqueSchema].Value:=FUniqueSchema;
    If FUniqueTable>'' Then
      RecordSet.Properties[cUniqueTable].Value:=FUniqueTable;
    If FResyncCommand.Text>'' Then
      RecordSet.Properties[cResyncCommand].Value:=FResyncCommand.Text;
    I:=adResyncNone;
    If ResyncAutoIncrement In FUpdateResync Then
      Inc(I,adResyncAutoIncrement);
    If ResyncConflicts In FUpdateResync Then
      Inc(I,adResyncConflicts);
    If ResyncUpdates In FUpdateResync Then
      Inc(I,adResyncUpdates);
    If ResyncInserts In FUpdateResync Then
      Inc(I,adResyncInserts);
    RecordSet.Properties[cUpdateResync].Value:=I;
    End;
End;

End.

