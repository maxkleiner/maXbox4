{***************************************************************
 *
 * Project  : Operating System Series with Object Pascal
 * App Name: 253_opearatingsystem3.txt (192_operatingsystem.txt), loc's = 430 
 * Purpose  : Demonstrates functions of operating systems with mX4 compiler
 * Date  : 30/12/2012  -  14:56
 * History  : getHostbyName, HINSTANCE, TPrinter, TMediaPlayer
 *          : TClipboard, TStatusBar, Ressources, Registry Read, Jedi SystemLib 
 *          : System demo for mX3.8 and mX3.9 - single responsibility
 ****************************************************************}

Program OperatingSystem_Tutorial_Delphi;
{BOOL WINAPI MessageBeep(
  __in  UINT uType
);}

// for DLL Load Demo
function  MessageBeep(para: integer): byte;
  external 'MessageBeep@user32.dll stdcall';  
  
function  CoCreateGuid(var pguid: TGUID):longint;
  external 'CoCreateGuid@OLE32.dll stdcall';  

{function  CoCreateGzuid2(var pguid: TGUID): Longint;
      external 'CoCreateGuid@activex.dll stdcall';
}

function  AdjustTokenPrivileges(tokenhandle: THandle): bool;
  external 'AdjustTokenPrivileges@advapi32.dll stdcall';  

function  SoundCardInstalled: longint;
  external 'waveOutGetNumDevs@winmm.dll stdcall';  


const REGPATH= '\SYSTEM\CurrentControlSet\services\SCCSService';  
      REGROOT= HKEY_LOCAL_MACHINE;

      REGPATH3= '\Software\Microsoft\Internet Explorer\TypedURLs';  
      REGROOT3= HKEY_CURRENT_USER;
      
      REGPATH4 ='\Software\Microsoft\Internet Explorer\Security';
      VAL4 ='Viewing_Security';
      VAL5 ='Sending_Security';
      
      REGPATH5 ='\SOFTWARE\Microsoft\Windows\CurrentVersion\Run';//
      REGPATH6 ='\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce';//
      
      REGPATH7 ='\SOFTWARE\Skype\Installer';

      MAINFORM = 'TMaxForm1';  
      BITMAPPATH = '\examples\citymax.bmp'; 

var
  rStr: String;
  StringGrid1: TStringGrid;
  mytimestamp, dt: TDateTime;
  osType: TIdWin32Type;
  frmMon: TForm;

procedure Signal_Sounds;
var sound: integer;
begin
for sound:= 1 to 100 do
  if sound mod 10 = 0 then begin
    MessageBeep(sound)
    Sleep(1500)
  end  
end;

//Recursion
Function Fakultaet(Zahl: integer): Integer;
begin
  If Zahl = 0 then
    result:= 1
  else
    result:= Zahl * Fakultaet(Zahl - 1);
end;


procedure TmainForm1_parseReg(regKey: string; rootKey:byte);
var reg: TRegistry;
    mySV: TStringList;
    keyContent: string;
    i: integer; 
    view: TListView;
  ListItem: TListItem;
      
begin
 reg:= TRegistry.create;
 try
  case rootKey of
    1:reg.RootKey:= HKEY_LOCAL_MACHINE;
    2:reg.RootKey:= HKEY_CURRENT_USER;
  end;
  if reg.OpenKey(regKey, false) then begin
      mySV:= TStringList.Create;
      view.Items.Clear;
    try
      //reg.GetKeyNames(mySK);
      //returns keys!
    reg.GetValueNames(mySV);
      for i:= 0 to mySV.Count - 1 do begin
        keyContent:= mySv.Strings[i];
        ListItem:= view.Items.Add;
        ListItem.Caption:=
               keyContent +'/ '+ reg.ReadString(keyContent);
        //ListItem.Subitems.Add(reg.ReadString(keyContent));
      end;
    finally
       mySV.Free;
     end;
     reg.CloseKey;
  end;// if
 finally
   reg.Free;
 end;
end;


Function getFileCount: integer;
var
  DOSerr: integer;
  //fsrch: TsearchRec;
begin
  result:= 0;
  doserr:= FindFirst('*.*',faAnyFile);
  if (DOSerr = 0) then begin
    while (DOSerr = 0) do begin
      if (searchRecAttr and faDirectory) = 0 then inc(result);
      //writeln(searchRecName)
      DOSerr:= findNext;
    end;
  findClose;
  end;
end;

function GetFolderDate(Folder: String): TDateTime;
var
  Found: integer;
  Date: TDateTime;
begin
  if Folder[length(folder)]= '\' then
    Delete(Folder, length(folder), 1);
  Result:= 0;
  Found:= FindFirst(Folder, faDirectory);
  try
  if Found = 0 then begin
    Date:= FileDateToDateTime(searchRecTime);
    result:= Date;
  end;
  finally
    FindClose;
  end;
end;

function GetTextFromFile(AFile: String; var ReturnString: string): boolean;
var
  FileStream: TFileStream;
begin
  result:= false;
  if not fileExists(AFile) then Exit;
  FileStream:= TFileStream.Create(AFile, fmOpenRead);
  try
    if FileStream.Size > 0 then begin
      SetLength(ReturnString, FileStream.Size);
      FileStream.Read(ReturnString, FileStream.Size);
      result:= true;
    end;
  finally
    FileStream.Free;
  end; //try
end;

function ExeFileIsRunning(ExeFile: string): boolean;
begin
  result:= ExeFileIsRunning(ExeFile);
end;

procedure getDriveTypesF;
var
  Drive: byte;
  DriveLetter: String;
begin   
  for Drive:= ord('A') to ord('Z') do begin
    DriveLetter:= chr(Drive) + ':\';
    case GetDriveType(PChar(chr(Drive) + ':\')) of
      0: //DRIVE_UNKNOWN
      Memo2.Lines.Add(DriveLetter + ' Unknown Drive');
      {1: //DRIVE_NO_ROOT_DIR
      Memo2.Lines.Add(DriveLetter + ' No Root Dir or mount Point');}
      2: //DRIVE_REMOVABLE:
      Memo2.Lines.Add(DriveLetter + ' Removable or Floppy Drive');
      3: //DRIVE_FIXED:
      Memo2.Lines.Add(DriveLetter + ' Fixed Drive');
      4: //DRIVE_REMOTE:
      Memo2.Lines.Add(DriveLetter + ' Network Drive');
      5: //DRIVE_CDROM:
      Memo2.Lines.Add(DriveLetter + ' CD-ROM Drive');
      6: //DRIVE_RAMDISK:
      Memo2.Lines.Add(DriveLetter + ' RAM Disk');
    end;
  end;
end;

Procedure TimeCounter;
var
  time: longint;
begin
  time:= GetTickCount;
  //Put the commands to measure...
  Sleep(500)
  maxform1.StatusBar1.SimpleText:= 
                       ('Time Diff of OS Tester: '+IntToStr(GetTickCount-time));
end;

function getBitMap: TBitmap;
begin
  result:= TBitmap.Create; 
  result.LoadFromFile(ExePath+BITMAPPATH);
  //result.Free;
end;  


procedure StringGrid1DrawCell(Sender: TObject; ACol, ARow: Integer;
                                      Rect: TRect; State: TGridDrawState);
begin
if ARow = 1 then
  StringGrid1.Canvas.Draw(Rect.Left,Rect.Top, getBitmap);
end;

procedure btnClick(sender: TObject);
begin
 Speak(' this is the hit big bit button')
end; 

procedure BuildFormMenu;
var //frmMon: TForm;
    myButton: TSpeedButton;
begin  
  frmMon:= TForm.Create(self);
  with frmMon do begin
    //FormStyle := fsStayOnTop;
    Position := poScreenCenter;
    caption:='Operating Systems for Admins';
    color:= clred;
    width:= 750;
    height:= 750;
    Show
  end;
  
  stringGrid1:= TStringGrid.Create(frmMon);
  with stringGrid1 do begin
    Parent:= frmMon;
    defaultcolwidth:= 154;
    defaultrowheight:= 154;
    height:= 360;
    width:= 360;   
    colcount:= 2;  //buggg solved!!!
    rowcount:= 2;
    top:= 20;
    GridLineWidth:= 8;
    Scrollbars:= false;
    onDrawCell:= @StringGrid1DrawCell;
  end;
  
    with TShape.Create(frmMon) do begin
      parent:= frmMon;
      setbounds(322,232,round(Sqrt(PI)*100),round(Sqrt(PI)*100));
      sendToback;
      shape:= strectangle;
      brush.color:= clblue;
      pen.width:= 2;
    //borderStyle:= bsNone;
    end;
 
  myButton:= TSpeedButton.Create(frmMon)
  with myButton do begin
    Parent:= frmMon;
    setbounds(10,440,380,80);
    caption:= 'Big Bit Button';
    font.size:= 14;
    font.Style:= [fsbold];
    //glyph.loadfromfile(BITMAPPATH); 
    //glyph.loadfromresourcename(getHINSTANCE,'HARD'); 
    glyph.loadfromresourcename(getHINSTANCE,'OPENFOLDER'); 
    //event handler
    onclick:= @btnClick;
  end;
end; 

procedure Apploop_Tester;
var i,j: integer;
    c: TComponent;
begin
  for i:= 0 to Application.ComponentCount - 1 do begin
    // all components of a Form
    for j:= 0 to Application.Components[i].ComponentCount - 1 do begin
      c:= Application.Components[i].Components[j];
      if c is TComponent then
        writeln(inttostr(j)+ ' '+c.name +' '+ c.classname)
    end;
  end; 
end;  

FUNCTION GetIpAddressByName(const AHostName: String): String;
begin
  result:= GetHostByName(AHostName)
end;  

function GetURLByIndy(const AURL: String): String;
var
IdHTTP: TIdHTTP;
begin
  IdHTTP:= TIdHTTP.Create(NIL);
try
  Result:= IdHTTP.Get(AURL);
finally
  IdHTTP.Free;
end;
end;

FUNCTION HINSTANCE: longword;
begin
  result:= GetHINSTANCE;
end;  

Function RegRead(keyRoot: Longint; keyPath, myField: String): string;
begin
  result:= RegistryRead(keyroot, keyPath, myField)
end;  

procedure IsAppAlive;
var Handle: THandle;
begin
  Handle:= FindWindow(MAINFORM,''); //FindReplDialog does not
  if Handle <> 0 then 
    Showmessage('maXbox is alive')
  else
    Showmessage('maXbox still sleeps');
end;

procedure PrintMap(aGraphic: TGraphic; title: string);
begin
  Printer.Title:= Title;
  Printer.BeginDoc;
  // in to the center                          
  Printer.Canvas.Draw((Printer.PageWidth  - aGraphic.Width ) div 2,
                (Printer.PageHeight - aGraphic.Height) div 2,aGraphic);
  //Printer.Canvas.Draw(40,40,aGraphic);
  Printer.Canvas.TextOut(480,480,'Place any text here');
  Printer.EndDoc;
end;

procedure Sierpinski(a,b,c: TPoint; Recdeepth: integer; aCanvas: TCanvas);
{
Sierpinski Dreieck (Rekursiv)
Algorithmus von Alleinherrscher ([url]www.delphipraxis.net[/url])
28.10.2009 , MX, small correction by c.y, cause sinus() won't work, just cos }
var new_a,new_b,new_c: TPoint;
begin
  acanvas.Pen.Color:= clblack;
  with acanvas do begin
    moveto((a.x),(a.y));
    lineto((b.x),(b.y));
    lineto((c.x),(c.y));
    lineto((a.x),(a.y));
  end;
  new_c.x:= (a.x+b.x ) div 2;
  new_c.y:= (a.y+b.y) div 2;
  new_a.x:= (b.x+c.x ) div 2;
  new_a.y:= (b.y+c.y) div 2;
  new_b.x:= (a.x+c.x) div 2;
  new_b.y:= (a.y+c.y) div 2;             
  if Recdeepth > 0 then begin
    Sierpinski(a,new_c,new_b, Recdeepth-1, aCanvas);
    Sierpinski(new_c,b,new_a, Recdeepth-1, aCanvas);
    Sierpinski(new_b,new_a,c, Recdeepth-1, aCanvas);
  end;
end; 

procedure Sierpinski_Setup(vForm: TForm);
var a,b,c:TPoint;
    awidth, atop, aleft, i: integer;
begin
  awidth:=650;
  atop:=680;
  aleft:=50;
  //edgepoints of first triangle left, bottom:
  a.x:= aleft;
  a.y:= atop;
  b.X:= awidth+a.x;
  b.y:= atop;
  c.X:= awidth div 2+aleft;
  c.y:= atop - awidth;
  //c.y:= round(atop-Cos((60/360)*2*Pi)*awidth);
  for i:= 1 to 7 do begin
    Sierpinski(a,b,c,i,vForm.canvas);
    sleep(500)
  end;  
end;

type
   TIdHTTPReqRespOnLog = procedure (Sender: TComponent; 
                            aOutbound, aHeader: Boolean; st: TStream); 

var
  FIdHttpServer: TIdCustomHttpServer;
  FIdRequest : TIdHTTPRequestInfo;
  FIdResponse: TIdHTTPResponseInfo; //IdResponse;
  fOnLog: TIdHTTPReqRespOnLog;

function StripHTTP(const Name: string): string;
begin
  if Pos('HTTP_', Name) = 1 then
    Result := Copy(Name, Length('HTTP_')+1, MaxInt)
  else
  Result := Name;
end;

function TIdWebRequest_GetFieldByName(const Name: string): string;
begin
//{$IF gsIdVersion = '8.0.25'} // D6, K2 compatible
//Result := FIdRequest.Headers.Values[StripHTTP(Name)];
//{$ELSE}
Result:= FIdRequest.RawHeaders.Values[StripHTTP(Name)];
//{$IFEND}
end;

function GetScriptName: string;
var
SlashPos: Integer;
begin
  Result := FIdRequest.Document;
  if Length(Result) > 0 then begin
    Delete(Result, 1, 1); // delete the first /
    SlashPos := Pos('/', Result);
    if SlashPos <> 0 then
    Delete(Result, SlashPos, MaxInt); // delete everything after the next /
    // Add back in the starting slash
    Result := '/' + Result;
  end;
end;

function DateTimemsToStr(aDT: TDateTime): string;
begin
  Result:= FormatDateTime(ShortDateFormat+' hh:nn:ss.zzz', aDT);
end;

procedure TIdHTTPReqResp_Log(aOutbound, aHeader: Boolean; St: TStream);
begin
//if Assigned(TComponent(fOnLog)) then begin
St.Position:= 0;
fOnLog(Self, aOutbound, aHeader, St);
//end;
end;

procedure TIdHTTPReqResp_LogString(aOutbound, aHeader: Boolean; S: string);
var
St: TStringStream;
begin
  St:= TStringStream.Create(S);
   try
     TIdHTTPReqResp_Log(aOutbound, aHeader, St);
   finally
  St.Free;
end;
end;


var
  tidd: tidhttpprotocolversion;
  ProtocolVersionString: array[0..1] of string; // = ('1.0', '1.1');

procedure TIdHTTPReqResp_Get(Response: TStream);
var FIdHTTP: TIdCustomHTTP;
   fURL, name: string;
begin
//if URL = '' then
   //raise EIdSOAPHTTPException.Create(SEmptyURL);
fIdHttp.Request.Accept := '*/*';
fIdHttp.Request.ContentType := 'sTextXml';
fIdHttp.Request.CustomHeaders.Clear;
try
  TIdHTTPReqResp_LogString(False, True, Format('GET %s HTTP/%s [%s @ %s]', [fURL,
  ProtocolVersionString[1{fIdHttp.ProtocolVersion}],
   Name, DateTimeMsToStr(Now)])+#13#10);
  fIdHttp.Request.CustomHeaders.Values['X-Debug']:= Format('%s %s', [fUrl,
   DateTimeToXMLTime(Now,true)]);
  //fIdHttp.Request.SetHeaders; // postponed to log correct RawHeaders
  TIdHTTPReqResp_LogString(False, True, fIdHttp.Request.RawHeaders.Text);
except
  end;
try
  fIdHttp.Get1(fURL, Response);
finally
  if Response.Size > 0 then begin
 try
   TIdHTTPReqResp_LogString(True,True,fIdHttp.ResponseText+Format(' [%s @ %s]', [Name,
   DateTimeMsToStr(Now)])+#13#10);
   TIdHTTPReqResp_LogString(True, True, fIdHttp.Response.RawHeaders.Text);
   TIdHTTPReqResp_Log(True, False, Response);
   Response.Position:= 0;
 except
  end;
  ///GetMimeBoundaryFromType(
  end;
 end;
end;

type
  IdSOAPInvokeOptions = (soNoValueForEmptySOAPAction, { Send "" or absolutely no
value for empty SOAPAction }
              soIgnoreInvalidCerts { xxx Handle Invalid Server
Cert and ask HTTP runtime to ignore }  );
  TIdSOAPInvokeOptions= set of IdSOAPInvokeOptions;

procedure constructor_TIdHTTPReqResp_Create(Owner: TComponent);
var FIdHTTP: TIdCustomHTTP;
    FInvokeOptions: TIdSOAPInvokeOptions;
begin
//inherited;
  FIdHTTP:= TIdCustomHTTP.Create(Self);
  FIdHttp.Request.AcceptCharSet:= 'utf-8';
  FIdHttp.Request.UserAgent := 'Borland SOAP 1.2'; { Do not localize }
  FInvokeOptions:= [soIgnoreInvalidCerts];
  //GetMimeBoundaryFromType
end;

procedure switchmonitortest(aon: boolean);
var lp : array[0..1] of longint;
begin
  lp[0]:= 0; lp[1]:= -1;
  SendMessage(application.handle, 
                WM_SYSCOMMAND, SC_MONITORPOWER, lp[booltoint(aon)]);
end;                
  

procedure GUIDTester;
var
  MyGuid0, MyGuid1 : TGUID;

begin
  { Create a new GUID from the string representation }
  MyGuid0:= StringToGUID('{00020400-0000-0000-C000-000000000046}');
  //Memo2.Lines.Add('The GUID is: ' + GUIDToString(MyGuid0));
  writeln('The GUID is: ' + GUIDToString(MyGuid0));
  {
  Accessing GUID's internal fields. Using Format function to obtain the
  same output as GUIDToString
  }
  writeln(Format('GUID using formatting is: ' +
       '{%0.8X-%0.4X-%0.4X-%0.2X%0.2X-%0.2X%0.2X%0.2X%0.2X%0.2X%0.2X}',
       [MyGuid0.D1, MyGuid0.D2, MyGuid0.D3,
       MyGuid0.D4[0], MyGuid0.D4[1], MyGuid0.D4[2], MyGuid0.D4[3],
       MyGuid0.D4[4], MyGuid0.D4[5], MyGuid0.D4[6], MyGuid0.D4[7]]));
       
    { Auto-generate a random GUID at runtime }
    writeln('Auto-generate a random GUID: '+CreateGUIDID) 
    
    MyGuid1:= BoldCreateGUID;  
    if MyGuid1.D1 = 0 then
     writeln('Creating GUID failed!')
  else
     writeln('The generated guid is: ' + GUIDToString(MyGuid1));
     
    { Generating second random GUID }
  MyGuid0:= BoldCreateGUID;

  { Testing if 2 guids are equal }
  if IsEqualGUID(MyGuid0, MyGuid1) then
     writeln('This cannot happen! CreateGUID guarantees that ' +
                     '2 randomly generated GUIDs cannot be equal!');
                     
   writeln(BoldCreateGUIDWithBracketsAsString)                      

end;

function IsGUID(expression: string): boolean;
var regx: string;
begin

    if (expression <> '') then begin
      regx:= '^\{([0-9a-fA-F]){8}?(-([0-9a-fA-F]){4}){3}-([0-9a-fA-F]){12}\}?$';
      result:= ExecRegExpr(regx, expression)
    
    //Regex guidRegEx = new Regex(@"^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$");

    end else result:= false;
end;

 function PalindromeChecker3(sc: string): boolean;
 begin
   result:= false;
   sc:= ReplaceRegExpr('[^a-zA-Z]',sc,'',true);
   if CompareText(sc,ReverseString(sc))=0 then
     result:= true;
 end;    
 
function TestClassRegEx(subjectString: string): string;
 var
  RegEx: TPerlRegEx;
begin
  RegEx:= TPerlRegEx.Create;
  try
    Regex.RegEx:= '\["(.+?)"\]';
    Regex.Subject:= SubjectString;  // ["any text between brackets & quotes"]
    Regex.Replacement:= '$1';
    Regex.ReplaceAll;
    Result:= Regex.Subject;
  finally
    RegEx.Free;
  end;
end;

const
  //CBenchResult = 100*1000*1000; //100 million
  CBenchResult = 1000*1000; //1 million
  
 //http://www.thedelphigeek.com/2010/03/speed-comparison-variant-tvalue-and.html
  
type TBenchProc = procedure(var benchRes: integer);  

procedure TfrmBenchmark_Benchmark(const benchName: string; 
  benchProc: TBenchProc);
var
  benchRes : integer;
  stopwatch: TStopWatch;
begin
  stopwatch:= TStopWatch.create;
  stopwatch.start;
  benchProc(benchRes);
  stopwatch.Stop;
  Assert(benchRes = CBenchResult,'cbench not reached');
  writeln(Format('%s: %s ms', [benchName, stopwatch.getvaluestr]));
  //lbLog.Items.Add(Format('%s: %d ms', 
    //[benchName, stopwatch.ElapsedMilliseconds]));
  //lbLog.Update;
end;

procedure TfrmBenchmark_TestVariant(var benchRes: integer);
var
  counter: Variant;
  i      : integer;
begin
  counter:= 0;
  for i:= 1 to CBenchResult do
    counter:= counter + 1;
  benchRes:= counter;
end;

procedure TfrmBenchmark_TestInteger(var benchRes: integer);
var
  counter: Integer;
  i      : integer;
begin
  counter:= 0;
  for i:= 1 to CBenchResult do
    counter:= counter + 1;
  benchRes:= counter;
end;

procedure TfrmBenchmark_TestInt64(var benchRes: integer);
var
  counter: int64;
  i      : integer;
begin
  counter:= 0;
  for i:= 1 to CBenchResult do
    counter:= counter + 1;
  benchRes:= counter;
end;


procedure TfrmBenchmark_TestVariant2(var benchRes: integer);
var
  counter: Variant;
  i,j    : integer;
begin
  counter:= 0;
  for i:= 1 to CBenchResult do begin
    j:= counter;
    counter:= j + 1;
  end;
  benchRes:= counter;
end;

{Once you've set up the regular expression and the replacement, then you're ready to assign Subject to the string you want to process. Finally, call ReplaceAll, and when it's finished, the new string will be in Subject again.}

type Closure = procedure(var benchRes: integer);  

procedure TfrmBenchmark_Benchmark2(const benchName: string; 
                                                benchProc: Closure);
var
  benchRes : integer;
  stopwatch: TStopWatch;
begin
  stopwatch:= TStopWatch.create;
  stopwatch.start;
  benchProc(benchRes);
  stopwatch.Stop;
  Assert(benchRes = CBenchResult,'cbench not reached');
  writeln(Format('%s: %s ms', [benchName, stopwatch.getvaluestr]));
  //lbLog.Items.Add(Format('%s: %d ms', 
    //[benchName, stopwatch.ElapsedMilliseconds]));
  //lbLog.Update;
end;

{Once you've set up the regular expression and the replacement, then you're ready to assign Subject to the string you want to process. Finally, call ReplaceAll, and when it's finished, the new string will be in Subject again.}




type TArrayOfString2 = array[1..40] of string;

var arrstr: TArrayOfString; //array[1..40] of string;
    udtGuid: TGUID;
    MyGuid0, MyGuid1 : TGUID;
    regx, regx1, regx2, cont, cont1, cont2, rets, sc, s1: string;
    //avt: TVariantManager;
    //att:TValue;
    ac: Closure;
    regdata: string;

begin   //main app
   //Signal_Sounds;
   //maxForm1.Console1Click(self);
   Writeln('All files in Exe Path: ' +intToStr(GetFileCount));
   Writeln('folder date of: '+datetimetostr(getFolderDate('examples')))
   dt:= getFolderDate('examples')
   //if GetTextFromFile(ExePath+'firstdemo3.txt',rStr) then ShowMessage(rStr);
   //0 = Current drive
   getDriveTypesF;
   //writeln(GetSHA1OfString('const S: AnsiString): String')); 
   //GetSHA1OfAnsiString  
   //inCreateShellLink(
   //ReplaceSystemDirWithSysWow64(
   //ExecAsOriginalUser
   MakePendingFileRenameOperationsChecksum;
   TimeCounter;
 
   BuildFormMenu; //calls StringGrid1DrawCell and getBitMap
   Sierpinski_Setup(frmMon);
   
   //Apploop_Tester;
   Writeln('IP Address of: '+GetIpAddressByName('www.softwareschule.ch'));
   Writeln('IP Address of own Host: '+GetIpAddressByName(getHostName));
   //Memo2.Lines.Text:= GetURLByIndy('http://www.delphi-treff.de'); 
   Writeln('instance of module is: '+intToStr(HINSTANCE))
   //Writeln('Registry read of url2: '+RegRead(REGROOT3, REGPATH3, 'url2'))
   
   Writeln('Registry read of view_sec: '+RegRead(REGROOT3, REGPATH4, VAL4))
   Writeln('Registry read of send_sec: '+RegRead(REGROOT3, REGPATH4, VAL5))
   
   //IsAppAlive;
   //PrintMap(getBitMap,'print of mX3.1')
   //SearchAndOpenDoc(ExePath+'examples\boxprint2.xps');
    writeln('IsAdminLoggedOn: '+botostr(IsAdminLoggedOn));
    writeln('IsPowerUserLoggedOn: '+botostr(IsPowerUserLoggedOn));

 //-IsPowerUserLoggedOn: Boolean;
 //cyGetWindowsVersion;
 //+GetWindowsVersionString: String;
   writeln('IsWin64: '+botostr(IsWin64));
   writeln('GetWindowsVersionString '+GetWindowsVersionString);
   writeln('GetUserNameString: '+GetUserNameString);
   writeln('GetComputerNameString: '+GetComputerNameString);
   Writeln('machine name is: '+getHostName)
   Writeln('user name is: '+getUserName)
   Writeln('proc id is: '+inttostr(currentProcessId))
   Writeln('path of maXbox exe is: '+ExePath)
   Writeln('Processor Numbers: '+intToStr(GetNumberOfProcessors))
   Writeln('Page Size: '+intToStr(GetPageSize))
   osType:= Win32Type;
   writeln('OS type is: '+intToStr(ord(osType)));
   mytimestamp:= GetFileCreationTime(exepath+'maxbox3.exe')
   writeln(DateTimeToStr(mytimestamp)+' for maXbox3 file')
   writeln('DateTimemsToStr: '+DateTimemsToStr(now));
   //ExecuteCommand('cmd','/k dir *.*')
   //ShowMessage('Examples Date: '+FormatDateTime('dddd,d.mmmm yyyy,hh:mm:ss',dt));
   //memo2.font.name:= 'Courier New';
   Writeln(floatToStr(Fibo(100)))
   //Say('This is maXbox 3.1')
   //Writeln(SHA1(exepath+'maxbox3.exe'));
   //GetSHA1OfFile
   //arraylength
   Writeln(MBVER);
   //from unit uPSI_JclSysInfo;
   //CoFreeUnusedLibraries
   //OleCheck(hresult)
   //procedure RegisterServer(const Is64Bit: Boolean; const Filename: String; const FailCriticalErrors: Boolean);
    {RegGetSubkeyNames(const RootKey: Integer; const SubKeyName: String; var Names: TArrayOfString): Boolean;
   RegGetValueNames(const RootKey: Integer; const SubKeyName: String; var Names: TArrayOfString): Boolean; }
   //inRegisterServer(true, 'servername', true);
   //GenerateNonRandomUniqueFilename(
   //'\Software\Microsoft\Internet Explorer\Security'
   {Function RegGetValueNames( const RootKey : HKEY; const Key : string; const List : TStrings) : Boolean 11243:}
   srlist:= TStringlist.create;
   if RegGetValueNames(REGROOT3, REGPATH4, srlist) then
     writeln('more regs found: ');
     for it:= 0 to srlist.count-1 do 
       writeln(' -'+srlist.strings[it]);
     srlist.Free;  
   
   srlist:= TStringlist.create;
   if RegGetValueNames(REGROOT3, REGPATH5, srlist) then
     writeln('more sec regs found: ');
     for it:= 0 to srlist.count-1 do 
       writeln(' -'+srlist.strings[it]);
     srlist.Free;  
  
   try
   srlist:= TStringlist.create;
   if RegGetValueNames(REGROOT3, REGPATH6, srlist) then
     writeln('more sec regs found: ');
     for it:= 0 to srlist.count-1 do 
       writeln(' -'+srlist.strings[it]);
     srlist.Free;  
   
   srlist:= TStringlist.create;
   if RegGetValueNames(REGROOT, REGPATH7, srlist) then
     writeln('more skype sec regs found: ');
     srlist.sorted:= true;
     for it:= 0 to srlist.count-1 do 
       writeln(' -'+srlist.strings[it]);
     srlist.Free;  
   
    except
     writeln('reg except')
     end  
       //RegDeleteKeyIfEmpty 
     //RegDeleteKeyIncludingSubkeys
   Writeln('Function GetCommonFilesFolder :'+GetCommonFilesFolder);
   Writeln('Function GetCurrentFolder :'+GetCurrentFolder);
   Writeln('Function GetProgramFilesFolder :'+GetProgramFilesFolder);
   Writeln('Function GetWindowsFolder :'+GetWindowsFolder);
   Writeln('Function GetWindowsSystemFolder :'+GetWindowsSystemFolder);
   Writeln('Function GetWindowsTempFolder :'+GetWindowsTempFolder);
   Writeln('Function GetDesktopFolder :'+GetDesktopFolder);
   Writeln('Function GetProgramsFolder :'+GetProgramsFolder);
   Writeln('Function GetPersonalFolder :'+GetPersonalFolder);
   Writeln('Function GetFavoritesFolder :'+GetFavoritesFolder);
   Writeln('Function GetStartupFolder :'+GetStartupFolder);
   Writeln('Function GetRecentFolder :'+GetRecentFolder);
   Writeln('Function GetSendToFolder :'+GetSendToFolder);
   Writeln('Function GetStartmenuFolder :'+GetStartmenuFolder);
   Writeln('Function GetDesktopDirectoryFolder :'+GetDesktopDirectoryFolder);
   Writeln('Function GetNethoodFolder :'+GetNethoodFolder);
   Writeln('Function GetFontsFolder :'+GetFontsFolder);
   Writeln('Function GetCommonStartmenuFolder :'+GetCommonStartmenuFolder);
   Writeln('Function GetCommonProgramsFolder :'+GetCommonProgramsFolder);
   Writeln('Function GetCommonStartupFolder :'+GetCommonStartupFolder);
   Writeln('Function GetCommonDesktopDiroryFolder:'+GetCommonDesktopdirectoryFolder);
   Writeln('Function GetCommonAppdataFolder :'+GetCommonAppdataFolder);
   Writeln('Function GetAppdataFolder :'+GetAppdataFolder); 
                             
   Writeln('Function GetPrinthoodFolder :'+GetPrinthoodFolder);
   Writeln('Function GetCommonFavoritesFolder :'+GetCommonFavoritesFolder);
   Writeln('Function GetTemplatesFolder :'+GetTemplatesFolder);
   Writeln('Function GetInternetCacheFolder :'+GetInternetCacheFolder);
   Writeln('Function GetCookiesFolder :'+GetCookiesFolder);
   Writeln('Function GetHistoryFolder :'+GetHistoryFolder);
   //Writeln('Function GetAPMLineStatus : TAPMLineStatus;
   //Function GetAPMBatteryFlag : TAPMBatteryFlag;
   Writeln('Function GetAPMBatteryLifePerct :'+InttoStr(GetAPMBatteryLifePercent));
   //Function GetAPMBatteryLifeTime : DWORD;
   //Function GetAPMBatteryFullLifeTime : DWORD;
   Writeln('Function GetVolumeName(const Drive : string) : '+GetVolumeName('C'));
   Writeln('Function GetVolumeSerialNumber :'+GetVolumeSerialNumber('C'));
   Writeln('Function GetVolumeFileSystem  :'+GetVolumeFileSystem('C'));
   //Function GetIPAddress( const HostName : string) : string;
   Writeln('Function GetLocalComputerName :'+GetLocalComputerName);
   Writeln('Function GetLocalUserName :'+GetLocalUserName);
   //Function GetUserDomainName( const CurUser : string) : string;
   Writeln('Function GetDomainName :'+GetDomainName);
   Writeln('Function GetRegisteredCompany :'+GetRegisteredCompany);
   Writeln('Function GetRegisteredOwner :'+GetRegisteredOwner);
   Writeln('Function GetBIOSName :'+GetBIOSName);
   Writeln('Function GetBIOSCopyright :'+GetBIOSCopyright);
   Writeln('Function GetBIOSExtendedInfo :'+GetBIOSExtendedInfo);
   Writeln('Function GetMaxAppAddress :'+IntToStr(GetMaxAppAddress));
   Writeln('Function GetMinAppAddress :'+IntToStr(GetMinAppAddress));
   Writeln('Function GetMemoryLoad :'+IntToStr(GetMemoryLoad));
   Writeln('Function GetSwapFileSize :'+IntToStr(GetSwapFileSize));
   Writeln('Function GetSwapFileUsage :'+InttoStr(GetSwapFileUsage));
   Writeln('Function GetTotalPhysicalMemory :'+IntToStr(GetTotalPhysicalMemory));
   Writeln('Function GetFreePhysicalMemory :'+IntToStr(GetFreePhysicalMemory));
   Writeln('Function GetTotalPageFileMemory :'+IntToStr(GetTotalPageFileMemory));
   Writeln('Function GetFreePageFileMemory :'+InttoStr(GetFreePageFileMemory));
   Writeln('Function GetTotalVirtualMemory :'+InttoStr(GetTotalVirtualMemory));
   Writeln('Function GetFreeVirtualMemory :'+InttoStr(GetFreeVirtualMemory));
   Writeln('Function GetShellProcessName :'+GetShellProcessName);
   //Function GetShellProcessHandle : THandle;
   //Function GetWindowsVersion : TWindowsVersion;
   //Function NtProductType : TNtProductType;
   Writeln('Function GetWindowsVersionString :'+GetWindowsVersionString);
   Writeln('Function NtProductTypeString :'+NtProductTypeString);
   Writeln('Function IsAdministrator :'+BoolToStr(IsAdministrator, True));
   PrintF('Factorial %-4.16f ',[fact(221)])

   //coinitialize(NIL, COINIT_MULTITHREADED)
   //couninitialize(nil)
   
   writeln(inttostr(coCreateGUID(udtGuid)))
   if coCreateGUID(udtGuid) = 0 then begin
     writeln(itoa(udtGuid.D1));
     writeln(itoa(udtGuid.D2));
     writeln(itoa(udtGuid.D3));
   end;  
     
     if Succeeded(coCreateGUID(udtGuid)) then writeln('createguid succeeded');
     
     //CreateGuid(MyGuid0)
     
     GUIDTester;
     
     if SoundCardInstalled > 0 then writeln('Sound Card available');
     
  Writeln('IP Test '+boToStr(ExecRegExpr('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}',
                                  '192.168.1.044'))) 
    //{FCCE3D50-FEB7-478C-80E3-B649B2BC4D4E}
    
    //regx:= '^\{?([0-9a-fA-F]){8}(-([0-9a-fA-F]){4}){3}-([0-9a-fA-F]){12}\}?$';
    regx:= '^\{([0-9a-fA-F]){8}?(-([0-9a-fA-F]){4}){3}-([0-9a-fA-F]){12}\}?$';
    regx1:= '\w{8}-(\w{4}-){3}\w{12}';
  
    //regx:= '^\{([0-9a-fA-F]){8}?(-([0-9a-fA-F]){4}){3}\}?$';
   
    cont:= '{BCCE3D50-FEB7-478C-80E3-B649B2BC4D4E}';
    //cont:= '{FCCE3D50-FEB7-478C-80E3}';
    
   Writeln('GUID Test 1: '+boToStr(ExecRegExpr(regx, cont))) 
   Writeln('GUID Test 2: '+botoStr(IsGUID(cont))) 
   
   //positive false
   cont:= '{KCCE3D50-FEB7-478C-80E3-B649B2BC4D4E}';
   Writeln('GUID Test 3: '+boToStr(ExecRegExpr(regx1, cont))) 
   
    rets:= 'Leben Sie, mit im Eisnebel!';
    writeln('palindrome check3: '+botoStr(palindromechecker3(rets)))
 
 //I am looking for a small example using TPerlRegEx to remove brackets and quotes as follows:   I do have 4 solutions:
 
     sc:= '["some trex text"]';
     sc:= ReplaceRegExpr('[^a-zA-Z ]',sc,'',true);
     writeln(sc)
     
     s1:= '["some trex text"]';
     s1:= Copy(s1,3,Length(s1)- 4)
     writeln(s1)
     
     sc:= '["some trex text"]';
     sc:= ReplaceRegExpr('\["(.+?)"\]',sc,'',true);
     writeln(sc)
   
     //Capturing Group
     sc:= '["some trex text"]';
     sc:= ReplaceRegExpr('\["(.+?)"\]',sc,'$1',true);
     writeln(sc)
    
     //Capturing Group 2    -backreference number 1
     sc:= '["some trex text"]';
     sc:= ReplaceRegExpr('^\["(.*)"\]$',sc,'$1',true);
     writeln(sc)
     
     sc:= '["some trex text"]';
     sc:= ReplaceRegExpr('\[|"|\]',sc,'',true);
     writeln(sc)
     
     writeln('TestClassRegEx: '+TestClassRegEx('["some trex text"]'));
     
     TfrmBenchmark_Benchmark('TestInteger ',@TfrmBenchmark_TestInteger);
     TfrmBenchmark_Benchmark('Test_Int64 ',@TfrmBenchmark_TestInt64);
     TfrmBenchmark_Benchmark('TestVariant ',@TfrmBenchmark_TestVariant);
     TfrmBenchmark_Benchmark('TestVariant2 ',@TfrmBenchmark_TestVariant2);
     TfrmBenchmark_Benchmark2('TestVariant3 ',@TfrmBenchmark_TestVariant2);
  
     ac:= @TfrmBenchmark_TestVariant2;
    
    TfrmBenchmark_Benchmark2('TestVariant4 ',ac);
    
    //OleVarFromInt
   
    
End.   


Ref:

TGUID = packed record
  D1: LongWord;
  D2: Word;
  D3: Word;
  D4: array[0..7] of Byte;
end;

@eelias because what is matched with (.+?) pattern i.e. between double quotes becomes a capturing group. You can reference capturing groups by index. In the case of ["some text"] the text <some text> will be captured as group 1. Then he replaces all occurrences of ["(.+?)"] with contents of capturing group 1 (i.e. $1) which is <some text> in your case. You can find more info here: regular-expressions.info/brackets.html –  

Allows for strings in the following forms

    32 contiguous digits: dddddddddddddddddddddddddddddddd

    -or-

    Groups of 8, 4, 4, 4, and 12 digits with hyphens between the groups. The entire GUID can optionally be enclosed in matching braces or parentheses: dddddddd-dddd-dddd-dddd-dddddddddddd

    -or-

    {dddddddd-dddd-dddd-dddd-dddddddddddd}

    -or-

    (dddddddd-dddd-dddd-dddd-dddddddddddd)

    -or-

    Groups of 8, 4, and 4 digits, and a subset of eight groups of 2 digits, with each group prefixed by "0x" or "0X", and separated by commas. The entire GUID, as well as the subset, is enclosed in matching braces: {0xdddddddd, 0xdddd, 0xdddd,{0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd,0xdd}}


How to test using regex in C# if:

    length of string is exactly 32
    string contains only numbers from 0-9 and small letters from a-f

Regex regex = new Regex("^[0-9a-f]{32}$");
if (regex.IsMatch(text))

shorter guid:

^{?([0-9a-fA-F]){8}(-([0-9a-fA-F]){4}){3}-([0-9a-fA-F]){12}}?$

if(!Regex.IsMatch(__systemGUID,
@"^([\w]{8}-[\w]{4}-[\w]{4}-[\w]{4}-[\w]{12})"))
Why not /\w{8}-(\w{4}-){3}\w{12}/

http://www.geekzilla.co.uk/View8AD536EF-BC0D-427F-9F15-3A1BC663848E.htm


public static bool IsGUID(string expression)
{
    if (expression != null)
    {
        Regex guidRegEx = new Regex(@"^(\{{0,1}([0-9a-fA-F]){8}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){4}-([0-9a-fA-F]){12}\}{0,1})$");

        return guidRegEx.IsMatch(expression);
    }
    return false;
}



I need to use regular expression to this string:

"\r\n+CMGL: 0,\"REC READ\",\"+79119968091\",,\"13/10/28,15:22:36+16\"\r\n10160008\r\n$GPMC,081915,A,5614.6801,N,04359.0266,E,0.0,190.2,121109,,*19\r\n+CMGL: 1,\"REC READ\",\"+79119968091\",,\"13/10/28,15:34:26+16\"\r\n#ALARM! \r\n10160008\r\n$GPMC,081915,A,5614.6801,N,04359.0266,E,0.0,190.2,121109,,*19\r\n\r\nOK\r\n"

I need to get 2 substrings(every substring starts with \r\n+CMGL: and ends with \r\n) from string above:

    \r\n+CMGL: 0,\"REC READ\",\"+79119968091\",,\"13/10/28,15:22:36+16\"\r\n10160008\r\n$GPMC,081915,A,5614.6801,N,04359.0266,E,0.0,190.2,121109,,*19\r\n
    \r\n+CMGL: 1,\"REC READ\",\"+79119968091\",,\"13/10/28,15:34:26+16\"\r\n#ALARM! \r\n10160008\r\n$GPMC,081915,A,5614.6801,N,04359.0266,E,0.0,190.2,121109,,*19\r\n

I have this regular expression

Regex r = new Regex(@"\+CMGL: (\d+),""(.+)"",""(.+)"",(.*),""(.+)""(\r\n((.|\n)*)\r\n\b)");

This regular expression works good but not for last group (\r\n((.|\n)*)\r\n\b). Problem is that i don't know how much \r\n symbols string will have until I see start of new substring (\r\n+CMGL: ). Thank in advance

For Starting with \r\n+CMGL: and ending with \r\n you can use below regular expression :

\\r\\n\+CMGL:.*?\*19\\r\\n


procedure TmainForm1.r1Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\Run',1);//
end;

procedure TmainForm1.r2Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',1);
end;

procedure TmainForm1.R3Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx',1);
end;

procedure TmainForm1.R4Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices',1);
end;

procedure TmainForm1.R5Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce',1)
end;

procedure TmainForm1.T1Click(Sender: TObject);
begin
  parseReg('Software\Microsoft\Internet Explorer\TypedURLs',2);//
end;



There is no place like 127.0.0.1 

Microsoft Windows [Version 6.1.7600]
Copyright (c) 2009 Microsoft Corporation.  All rights reserved.

C:\Windows\system32>sc stop "geekbuddyrsp"

SERVICE_NAME: geekbuddyrsp
        TYPE               : 10  WIN32_OWN_PROCESS
        STATE              : 3  STOP_PENDING
                                (STOPPABLE, NOT_PAUSABLE, IGNORES_SHUTDOWN)
        WIN32_EXIT_CODE    : 0  (0x0)
        SERVICE_EXIT_CODE  : 0  (0x0)
        CHECKPOINT         : 0x1
        WAIT_HINT          : 0x0

C:\Windows\system32>sc config "geekbuddyrsp" start= disabled
[SC] ChangeServiceConfig SUCCESS

C:\Windows\system32>sc delete "geekbuddyrsp"
[SC] DeleteService SUCCESS

C:\Windows\system32>

C:\maXbook\maxbox3\mX3999\maxbox3>sc stop "geekbuddyrsp"
[SC] OpenService FAILED 5:

Access is denied.


//-------------------------------------------------------------------
 DiskSize returns -1 if the drive number is invalid. Drive parameter can be set to: 0 = Current drive, 1 = A, 2 = B, 3 = C and so on. 


DRIVE_UNKNOWN
0 The drive type cannot be determined.
 
DRIVE_NO_ROOT_DIR
1 The root path is invalid; for example, there is no volume mounted at the specified path.
 
DRIVE_REMOVABLE
2 The drive has removable media; for example, a floppy drive, thumb drive, or flash card reader.
 
DRIVE_FIXED
3 The drive has fixed media; for example, a hard drive or flash drive.
 
DRIVE_REMOTE
4 The drive is a remote (network) drive.
 
DRIVE_CDROM
5 The drive is a CD-ROM drive.
 
DRIVE_RAMDISK
6 The drive is a RAM disk.

------------------------------------------------------
//USES WinSock;
FUNCTION GetIpAddressByName(const AComputerName: STRING): STRING;
VAR
TMPResult: STRING;
WSA: TWSAData;
H: PHostEnt;
P: PChar;
BEGIN
IF WSAStartUp($101, WSA) = 0 THEN BEGIN
GetMem(P,255 + 1);
StrPCopy(P, ComputerName);
H:= GetHostByName(P);
FreeMem(P);
IF H <> NIL THEN BEGIN
P:= inet_ntoa(PInAddr(H^.h_addr_list^)^);
TMPResult:= StrPas(P)
END;
WSACleanUp;
IF TMPResult <> '' THEN
Result:=TMPResult
ELSE
Result:= '0';
END;
END;

----------------------------------
Function TForm1.RegRead (keyPath, myField: String): string;
begin
//Create the Object
with (TRegistry.Create) do begin //als Instanz
RootKey:=HKEY_LOCAL_MACHINE;
//Check if whe can open key, if the key dosn't exist, we create it
if OpenKey(keyPath,true) then begin
if ValueExists(myField) then
result:= ReadString(myField) else
ShowMessage(myField+' does not exists under '+keyPath);
end else
ShowMessage('Error opening/creating key : '+keyPath);
closeKey;
Free;
end; //with
end;

------------------------------------------------
function GetNumberOfProcessors: longint;
var
SystemInfo: TSystemInfo;
begin
GetSystemInfo(SystemInfo);
Result:= SystemInfo.dwNumberOfProcessors;
end;

In Delphi, you print via the TPrinter object.

    * Add printers to your uses clause
    * Use the Printer function to access the global instance of TPrinter
    * Printer.BeginDoc starts the print job
    * Printer.EndDoc stops the print job and sends it to the printer
    * Printer.NewPage forces a new page
    * Printer.Canvas is used to generate the output page 
    
                                                 1
                                              1     1
                                          1     2     1
                                      1     3     3     1
                                  1     4     6     4     1
                              1     5    10    10     5     1
                          1     6    15    20    15     6     1
                      1     7    21    35    35    21     7     1
                  1     8    28    56    70    56    28     8     1
              1     9    36    84   126   126    84    36     9     1
          1    10    45   120   210   252   210   120    45    10     1
      1    11    55   165   330   462   462   330   165    55    11     1
  1    12    66   220   495   792   924   792   495   220    66    12     1
 
 
                                                 1
                                              1     1
                                           1     2     1
                                        1     3     3     1
                                     1     4     6     4     1
                                  1     5    10    10     5     1
                               1     6    15    20    15     6     1
                            1     7    21    35    35    21     7     1
                         1     8    28    56    70    56    28     8     1
                      1     9    36    84   126   126    84    36     9     1
                   1    10    45   120   210   252   210   120    45    10     1
                1    11    55   165   330   462   462   330   165    55    11     1
             1    12    66   220   495   792   924   792   495   220    66    12     1
 
unit patternFrm;

//========================================================================
//  free for all(o) 2003, Max Kleiner
//  sample application for the book Delphi Design Patterns
//  proofed by Bernhard Angerer
//  controls & lists external files
//  ex.:  if Text = 'MVC' then
//             toogleview_orfile('boldmain.pas');
//========================================================================
{$UNDEF PATTERNS}
//{$DEFINE PATTERNS}

interface

uses
  Windows, Messages, SysUtils, Classes, Controls, Forms, Dialogs,
  Menus, ImgList, ExtCtrls, uStrategy, IVCLScanner1,
  Grids, ComCtrls, StdCtrls, OleCtrls, ToolWin;

type
  TmainForm1 = class(TForm)
    StatusBar1: TStatusBar;
    MainMenu1: TMainMenu;
    Datei1: TMenuItem;
    Beenden1: TMenuItem;
    CoolBar1: TCoolBar;
    ToolBar1: TToolBar;
    tbtnClose: TToolButton;
    ImageList1: TImageList;
    ImageList2: TImageList;
    tbtnGenerator: TToolButton;
    ImageList3: TImageList;
    tbtnOptions: TToolButton;
    Generator: TMenuItem;
    mnEncrypt: TMenuItem;
    mnDecrypt: TMenuItem;
    progBar: TProgressBar;
    TreeView1: TTreeView;
    Splitter1: TSplitter;
    view: TListView;
    ImageList4: TImageList;
    ImageList5: TImageList;
    info1: TMenuItem;
    Fractals: TMenuItem;
    options: TMenuItem;
    MATestCase1: TMenuItem;
    tbtnTrans: TToolButton;
    mnOpentree: TMenuItem;
    mnSearch: TMenuItem;
    mnRegistryReader: TMenuItem;
    r1: TMenuItem;
    r2: TMenuItem;
    R3: TMenuItem;
    R4: TMenuItem;
    R5: TMenuItem;
    T1: TMenuItem;
    procedure tbtnCloseClick(Sender: TObject);
    procedure tbtnOptionsClick(Sender: TObject);
    procedure mnEncryptClick(Sender: TObject);
    procedure mnDecryptClick(Sender: TObject);
    procedure TreeView1Change(Sender: TObject; Node: TTreeNode);
    procedure FractalsClick(Sender: TObject);
    procedure MovingAverage1Click(Sender: TObject);
    procedure MATestCase1Click(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure tbtnTransClick(Sender: TObject);
    procedure mnOpentreeClick(Sender: TObject);
    procedure info1Click(Sender: TObject);
    procedure mnSearchClick(Sender: TObject);
    procedure dlgSearchFind(Sender: TObject);
    procedure r1Click(Sender: TObject);
    procedure r2Click(Sender: TObject);
    procedure R3Click(Sender: TObject);
    procedure R4Click(Sender: TObject);
    procedure R5Click(Sender: TObject);
    procedure T1Click(Sender: TObject);
    procedure FormActivate(Sender: TObject);
    procedure viewClick(Sender: TObject);
    //procedure FormClose(Sender: TObject; var Action: TCloseAction);
  private
    { Private-Deklarationen}
    FRegCharges: TChargeContext;
    FPrefCharges: TChargeContext;
    FTrialCharges: TChargeContext;
    memMon: TMemo;
    frmMon: TForm;
    mem2: TMemo;
    dlgSearch: TFindDialog;
    ws_url: string[255];
  {$IFDEF PATTERNS}
    myWS: IVCLScanner;
    myFac: T_RIOFactory;
  {$ENDIF}
   procedure scanFile_orStream(myFile: string);
   procedure FindDlgClose(Sender: TObject; var action: TCloseaction);
   procedure Mem2Close(Sender: TObject);
   function OpenRead(myfile: String) : String;
   procedure parseReg(regKey: string; rootKey: byte);
   procedure toogleView_orFile(ufile: string);
  public
    ListItem: TListItem;
    //cause of chartview callback
  end;

var
  mainForm1: TmainForm1;
  Win32Platform: integer =2;

implementation

uses ulooktrans, usingletonF, uFilexport,
     fchaos, registry, uCrypto, graphics, chartView;

//{$R *.DFM}

procedure TmainForm1.FormCreate(Sender: TObject);
begin
  tbtnTrans.Enabled:=false;
  FRegCharges:= TMonthlyCharges.Create(TRegularCharge.Create);
  FPrefCharges:= TMonthlyCharges.Create(TPreferredCharge.Create);
  FTrialCharges:= TMonthlyCharges.Create(TTrialCharge.Create);
  frmChart:=TfrmChart.create(self);
  self.Visible:=true;
  self.Height:= 550;
  self.ClientHeight:= 500;
  self.Width:= 765;
  self.ClientWidth:= 755;
end;

procedure TmainForm1.FormActivate(Sender: TObject);
begin
  self.Caption:='Delphi Design Patterns';
  progBar.visible:= false;
  statusbar1.simplepanel:= true;
  //trans.strlit[19];
  statusBar1.SimpleText:='max@kleiner.com';
end;

procedure TmainForm1.FormDestroy(Sender: TObject);
begin
  frmChart.release;
  messagebeep(0);
  FRegCharges.Free;
  FPrefCharges.Free;
  FTrialCharges.Free;
  //mem2.Free;
end;


procedure TmainForm1.tbtnCloseClick(Sender: TObject);
begin
  mainform1.close;
end;

procedure TmainForm1.tbtnOptionsClick(Sender: TObject);
begin
  trans.showmodal;
end;

procedure TmainForm1.mnEncryptClick(Sender: TObject);
var myCrypt: TCryptoDecorator2;
    od1: TOpenDialog;
    step, size: Longint;
    passB: integer;
    psStr, dataStr, chiffr: string;
    crMode: byte;
    F, F1: TextFile;
begin
  if TMenuItem(sender).Name = 'mnDecrypt' then
  crMode:= 2 else crMode:= 1;
  myCrypt:= TCryptoDecorator2.create(TCrypto.create);
  od1:= TOpenDialog.Create(NIL);
  step:= 0;
  psStr:= InputBox(trans.strLit[2], trans.strlit[3], '');
  //trans.password:= psStr;
  if psStr = '' then begin
    messagedlg(trans.strlit[4], mtError, [mbOk], 0);
    exit;
  end;
  od1.execute;
  try
    passB:= strToInt(psStr);
    if length(od1.FileName) < 1 then
      messagedlg(trans.strlit[5],mtError,[mbOk], 0)
    else begin
      AssignFile(F, OD1.FileName);
      Reset(F);
      //fHandle:= FileOpen(Od1.FileName, 2);
      Size:= filesize(F);
      with progbar do begin
        visible:= True;
        Min:= 0;
        Max:= Size;
        Step:= 1;
      end;
      if crMode = 1 then begin
      //more performance without progbar
        AssignFile(F1, 'chiffrat.txt');
        Rewrite(F1);
        while not EOF(F) do begin
          readln(F,dataStr);
          chiffr:= myCrypt.encrypt1(passB, dataStr, step);
          if trans.cbcrypt.checked then progBar.StepIt;
          writeln(F1, chiffr);
        end;
        messagedlg(trans.strlit[6], mtInformation, [mbOk], 0)
      end else if crMode = 2 then begin
         AssignFile(F1, 'clear.txt');
         Rewrite(F1);
         while not EOF(F) do begin
           readln(F,dataStr);
           chiffr:= myCrypt.decrypt1(passB, dataStr, step);
           if trans.cbcrypt.checked then progBar.StepIt;
           writeln(F1, chiffr);
          //append(F1);
         end;
         messagedlg(trans.strlit[7], mtInformation, [mbOk], 0);
      end; //crMode
    end; //filename
  finally
    flush(F1);
    myCrypt.Free;
    od1.Free;
    closeFile(F);
    closeFile(F1);
    progbar.Visible:= False;
  end;
end;

procedure TmainForm1.mnDecryptClick(Sender: TObject);
begin
  mnEncryptClick(sender);
  //selects the sender
end;


function TmainForm1.OpenRead(myfile: String) : String;
var
  f: TextFile;
  content, row: string;
 begin
   content:= '';
   if fileexists(myfile) then begin
    Assignfile(f, myfile);
    Reset(f);
      while not eof(f) do begin
         ReadLn(F, row);
         content:= content + row + chr(13);
      end;
    CloseFile(F);
    Result := content;
   end else
   Result := trans.strlit[5];
end;

procedure TMainForm1.scanFile_orStream(myFile: string);
var
  Tempstr, cont: String;
  position: integer;
begin
  mem2close(NIL);
  with view do begin
    if fileexists(myFile) then
    cont:= openRead(myFile) else
    cont:= myfile;
    position:= pos(chr(13), cont);
    if (position = 0) and (length(trim(cont)) > 0) then begin
     ListItem:= Items.Add;
     ListItem.Caption := cont;
     exit
    end;
    while position > 0 do begin
      TempStr:= cont;
      delete(TempStr, position, length(TempStr) - position + 1);
      delete(cont, 1, position);
      ListItem:= Items.Add;
      ListItem.Caption := TempStr;
      position:= pos(chr(13), cont);
    end;
  end;
end;

procedure TMainForm1.toogleView_orFile(ufile: string);
begin
  if not assigned(mem2) then begin
    mem2:= TMemo.Create(application);
    //if q.loadFromStreamFile('patterns.dsm',aStream) then
    mem2.parent:= view;
    mem2.Align:= alclient;
    mem2.Font.Size:= 12;
    mem2.OnDblClick:= mem2Close;
      //mem2.lines.LoadFromStream(aStream);
  end;
  if fileexists(uFile) then
    mem2.lines.LoadFromFile(ufile)
  else begin
    mem2.Clear;
    mem2.Lines.add(ufile);
  end;
  mem2.Show;
end;

procedure TmainForm1.Mem2Close(Sender: TObject);
begin
  if assigned(mem2) then begin
    mem2.clear;
    mem2.Parent:= NIL;
    mem2:= NIL;
    mem2.Free;
  end;
end;

procedure TmainForm1.TreeView1Change(Sender: TObject; Node: TTreeNode);
const
//array of critical files just to test
    sProgs: array[0..3, 0..1] of ShortString = (
     ('Passwort.ini', 'T-Online Passwörter'),
     ('Cis.ini', 'CompuServe Passwortdatei'),
     ('Services', 'Port-Eintraege zu TCP/IP'),
     ('Sam','Sicherheits-Eintraege'));
var i: integer;
  //aStream: TMemoryStream;
  //q: TTxtFile;
begin
  view.Items.Clear;
  //****************start treeview events********************
  with Treeview1.selected do begin
    if Text = 'OCL' then
      scanFile_orStream('ocl_facts.txt');
    if Text = 'Delegation' then
      scanFile_orStream('delegate.txt');
    if Text = 'Refactoring' then
      scanFile_orStream('refactoring.txt');
    if Text = 'Redesign' then
      scanFile_orStream('redesign.txt');
    if Text = 'DUnit' then
      scanFile_orStream('algorithms.pas');
    if Text = 'NUnit' then
      scanFile_orStream('nunit.txt');
    if Text = 'Interfaces' then
      toogleview_orfile('IVCLScanner1.pas');
    if Text = 'Lists' then
      toogleview_orfile('listCollect.pas');
    if Text = 'Singleton' then begin
      toogleview_orfile('uSingletonF.pas');
      SingleKeeper.Show;
      //TSingletonForm.Create(self);
      for i:= 1 to trans.GetWinner.Count-1 do with view do begin
      //test routine
        ListItem:= Items.Add;
        ListItem.Caption:= trans.getwinner.Strings[i];
      end;
      trans.GetWinner.Free
    end;
    if Text = 'SingletonAlt' then
       TSingletonForm.Instance.Show;
    if Text = 'Observer' then begin
      SingleKeeper.Show;
      toogleview_orfile('uObserver.pas');
    end;
    if Text = 'Template' then begin
      mem2close(sender);
      scanFile_orStream(trans.executeTemplate.strings[0]);
      trans.executeTemplate.Free
    end;
    if Text = 'Strategy' then with view do begin
    //simulating client using Strategy context object
      mem2close(sender);
      Clear;
      listItem:= Items.Add;
      listItem.Caption:= (trans.strlit[16]);
      listItem:= Items.Add;
      listItem.Caption:=
         Format('Regular %m',[FRegCharges.CompCharges(1000)]);
      listItem:= Items.Add;
      listItem.caption:=
         Format('Preferred %m',[FPrefCharges.CompCharges(1000)]);
      listItem:= Items.Add;
      listItem.Caption:=
         Format('Trial %m',[FTrialCharges.CompCharges(1000)]);
    end;
    if Text = 'Lock' then begin
      transMonitor.createTrans(NIL); //class instance
      statusBar1.SimpleText:='running trans in button';
      tbtnTrans.Enabled:=not(tbtnTrans.Enabled);
      //toogle button
      toogleview_orfile('ulooktrans.pas');
    end;
    if Text = 'Abstract' then
      toogleview_orfile('abstfact.htm');
    if Text = 'Builder' then
      toogleview_orfile('uSingletonF.pas');
    if Text = 'Factory' then
      toogleview_orfile('uObserver.pas');
    if Text = 'Adapter' then
      toogleview_orfile('uObserver.pas');
    if Text = 'Bridge' then
      toogleview_orfile('uFilexport.pas');
    if Text = 'Composite' then
      toogleview_orfile('u_Composition.pas');
    if Text = 'Decorator' then
      toogleview_orfile('uCrypto.pas');
    if Text = 'Facade' then
      toogleview_orfile('marshall.pas');
    if Text = 'Flyweight' then
      toogleview_orfile('uStrategy.pas');
    if Text = 'Proxy' then
      toogleview_orfile('IVCLScanner1.pas');
    if Text = 'Wrapper' then
      toogleview_orfile('uFilexport.pas');
    if Text = 'Chain' then
      toogleview_orfile('ulooktrans.pas');
    if Text = 'Command' then begin
      toogleview_orfile('uStrategy.pas');
      TFrmChaos.getFrmInstance.Show;
    end;
    if Text = 'Interpreter' then
      toogleview_orfile('patternFrm.pas');
    if Text = 'Iterator' then
      toogleview_orfile('iterator.txt');
    if Text = 'Mediator' then
      toogleview_orfile('uFilexport.pas');
    if Text = 'Memento' then
      toogleview_orfile('Graphics.pas');
    if Text = 'State' then
      toogleview_orfile('foerderband.pas');
    if Text = 'Visitor' then
      toogleview_orfile('RND.pas');
    if Text = 'Automation' then
      toogleview_orfile('i2c.pas');
    if Text = 'Broker' then begin
      toogleview_orfile('IVCLScanner1.pas');
       //like an abstract factory in HTTPRIO
      ws_url:=WSURL1;
      {$IFDEF PATTERNS}
      myWS:= myFac.GetIVCLScanner(false, ws_url);
      myWS.PostUser(trans.strlit[19], trans.strlit[14], 'mix')
      {$ENDIF}
    end;
    if Text = 'Container' then
      toogleview_orfile('income.dpr');
    if Text = 'Layers' then
      toogleview_orfile('banklogic.pas');
    if Text = 'Master-Slave' then
      toogleview_orfile('sortThds.pas');
    if Text = 'Microkernel' then
      toogleview_orfile('shellConsts.pas');
    if Text = 'Monitor' then
      toogleview_orfile('chartView.pas');
    if Text = 'MVC' then
      toogleview_orfile('boldmain.pas');
    if Text = 'PAC' then
      toogleview_orfile('boldbase.pas');
    if Text = 'Prototyp' then
      toogleview_orfile('testmodules.pas');
    if Text = 'Provider' then
      toogleview_orfile('DMU.pas');
    if Text = 'Simulator' then
      toogleview_orfile('RND.pas');
    if Text = 'Terminal-Server' then
      toogleview_orfile('fterminal.pas');
    if Text = 'Transaction' then
      toogleview_orfile('u_dwsserver1.pas');
    if Text = 'Watchdog' then
      toogleview_orfile('monForm.pas');
    end; //with
end; //treeview


procedure TmainForm1.FractalsClick(Sender: TObject);
begin
  //if win32platform = VER_PLATFORM_WIN32_WINDOWS then
   TFrmChaos.getFrmInstance.ShowModal;
end;

procedure TmainForm1.MovingAverage1Click(Sender: TObject);
begin
  try
    frmChart.Show;
  finally
  end;
end;

procedure TmainForm1.MATestCase1Click(Sender: TObject);
begin
  movingAverage1click(sender);
end;


procedure TmainForm1.tbtnTransClick(Sender: TObject);
begin
  transMonitor.addTransactions(trans.strlit[20]);
end;

procedure TmainForm1.mnOpentreeClick(Sender: TObject);
begin
  with mnOpenTree do begin
    if tag=0 then begin
      treeview1.FullExpand;
      Caption:=trans.strlit[21];
      tag:=1
    end else begin
      treeview1.FullCollapse;
      mnOpenTree.Caption:=trans.strlit[22];
      tag:=0;
    end;
  end
end;

procedure TmainForm1.info1Click(Sender: TObject);
begin
  statusBar1.Font.color:=clblue;
  statusBar1.SimpleText:=trans.strlit[19];
end;


procedure TmainForm1.mnSearchClick(Sender: TObject);
var  aTop: TPoint;
begin
 if not assigned(dlgsearch) then begin
  dlgSearch:= TFindDialog.Create(self);
  frmMon:= TForm.create(dlgSearch);
  memMon:= TMemo.create(frmMon);
    with mainForm1 do begin
      aTop.y:=Top;
      aTop.x:=Left;
    end;
    try
      dlgSearch.OnFind:=dlgSearchfind;
      frmMon.OnClose:=findDlgClose; //on destroy
      frmMon.Parent:= self;
      memMon.parent:= frmMon;
      memMon.setbounds(10,10,290,190);
      frmMon.caption:=trans.strLit[14];
      memMon.lines.LoadFromFile(TESTFILE);
      with frmMon do begin
        top:=ATop.y + self.view.Top + toolbar1.Height + 12;
        left:=ATop.x + self.view.left + 6;
        show;
      end;
        dlgSearch.Execute
    finally
     //memMon:=NIL;
     //frmMon.Release;
    end;
  end else exit
end;

procedure TmainForm1.dlgSearchFind(Sender: TObject);
begin
 if assigned(dlgSearch) then
  trans.txtSearch(mainForm1, memMon, dlgSearch, memMon.text);
end;

procedure TmainForm1.FindDlgClose(Sender: TObject; var action: TcloseAction);
begin
  dlgSearch.CloseDialog;
  dlgSearch:= NIL;
  dlgSearch.Free;
end;

procedure TmainForm1.r1Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\Run',1);//
end;

procedure TmainForm1.r2Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce',1);
end;

procedure TmainForm1.R3Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnceEx',1);
end;

procedure TmainForm1.R4Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices',1);
end;

procedure TmainForm1.R5Click(Sender: TObject);
begin
  parseReg('SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce',1)
end;

procedure TmainForm1.T1Click(Sender: TObject);
begin
  parseReg('Software\Microsoft\Internet Explorer\TypedURLs',2);//
end;

procedure TmainForm1.parseReg(regKey: string; rootKey:byte);
var reg: TRegistry;
    mySV: TStringList;
    keyContent: string;
    i: integer;
begin
 reg:= TRegistry.create;
 try
  case rootKey of
    1:reg.RootKey:= HKEY_LOCAL_MACHINE;
    2:reg.RootKey:= HKEY_CURRENT_USER;
  end;
  if reg.OpenKey(regKey, false) then begin
      mySV:= TStringList.Create;
      view.Items.Clear;
    try
      //reg.GetKeyNames(mySK);
      //returns keys!
    reg.GetValueNames(mySV);
      for i:= 0 to mySV.Count - 1 do begin
        keyContent:= mySv.Strings[i];
        ListItem:= view.Items.Add;
        ListItem.Caption:=
               keyContent +'/ '+ reg.ReadString(keyContent);
        //ListItem.Subitems.Add(reg.ReadString(keyContent));
      end;
    finally
       mySV.Free;
     end;
     reg.CloseKey;
  end;// if
 finally
   reg.Free;
 end;
end;


procedure TmainForm1.viewClick(Sender: TObject);
var cycle: byte;
  fname: string;
begin
  with View do begin
    if frmchart.optimise then begin
    frmchart.SetFocus;
    frmchart.Timer1.Enabled:= false;
    cycle:=  strToint(copy(selected.Caption,1,2)) ;
    frmchart.drawListChart(cycle);
   end;
   if frmchart.optimiseall then begin
    frmchart.SetFocus;
    frmchart.Timer1.Enabled:= false;
    fname:= copy(selected.caption,1,pos(':',selected.Caption));
    frmchart.loadChartDirect(fname);
   end; 
  end;
end;

end.



A debut psychological thriller about a woman who becomes emotionally entangled in a murder investigation because of something she witnesses on her daily commute. Rachel takes the same commuter train every morning and every night. Every day she rattles over the same track junctions, flashes past the same stretch of cozy suburban homes. And every day she stops at the same signal and she sees the same couple, breakfasting on their roof deck, living the perfect life that Rachel craves for herself—a lifestyle she recently lost. She looks forward to observing this household every morning, even makes up names and narratives for its residents. Then one day Rachel sees someone new in their garden, and soon after, the woman who lived there disappears. Unable to keep this information to herself, Rachel offers what she knows to the police, and in the process is drawn into the lives of the couple she thought of as Jason and Jess but whose names—she has learned from the news—are really Megan and Scott Hipwell. But the police accuse Rachel of being unreliable, and it’s true that her memories can’t always be trusted. Plus there are the stories that her ex-husband’s new wife has been spreading about her. By the time Megan’s body is found, Rachel is in over her head, intricately entangled in the details of the investigation, as well as in the lives of everyone involved. Has she put others in danger? Has she done more harm than good? A compulsively readable, emotionally immersive, Hitchcockian thriller that draws comparisons to Gone Girl, The Silent Wife, or Before I Go to Sleep, this is an electrifying debut embraced by readers across markets and categories.

https://www.academia.edu/14505151/Tutor_38_3D_Printing_and_Coding?auto_accept_coauthor=true

  TVariantManager = record
    VarClear: procedure(var V : Variant);
    VarCopy: procedure(var Dest: Variant; const Source: Variant);
    VarCopyNoInd: procedure; // ARGS PLEASE!
    VarCast: procedure(var Dest: Variant; const Source: Variant; VarType: Integer);
    VarCastOle:procedure(var Dest: Variant;const Source: Variant; VarType: Integer);
    VarToInt: function(const V: Variant): Integer;
    VarToInt64: function(const V: Variant): Int64;
    VarToBool: function(const V: Variant): Boolean;
    VarToReal: function(const V: Variant): Extended;
    VarToCurr: function(const V: Variant): Currency;
    VarToPStr: procedure(var S; const V: Variant);
    VarToLStr: procedure(var S: string; const V: Variant);
    VarToWStr: procedure(var S: _WideStr; const V: Variant);
    VarToIntf: procedure(var Unknown: IInterface; const V: Variant);
    VarToDisp: procedure(var Dispatch: IDispatch; const V: Variant);
    VarToDynArray:procedure(var DynArray:Pointer;const V:Variant; TypeInfo: Pointer);
    VarFromInt: procedure(var V:Variant; const Value:Integer; const Range: ShortInt);
    VarFromInt64: procedure(var V: Variant; const Value: Int64);
    VarFromBool: procedure(var V: Variant; const Value: Boolean);
    VarFromReal: procedure; // var V: Variant; const Value: Real
    VarFromTDateTime: procedure; // var V: Variant; const Value: TDateTime
    VarFromCurr: procedure; // var V: Variant; const Value: Currency
    VarFromPStr: procedure(var V: Variant; const Value: _ShortStr);
    VarFromLStr: procedure(var V: Variant; const Value: string);
    VarFromWStr: procedure(var V: Variant; const Value: _WideStr);
    VarFromIntf: procedure(var V: Variant; const Value: IInterface);
    VarFromDisp: procedure(var V: Variant; const Value: IDispatch);
    VarFromDynArray: procedure(var V: Variant; const DynArray: Pointer; TypeInfo: Pointer);
    OleVarFromPStr: procedure(var V: OleVariant; const Value: _ShortStr);
    OleVarFromLStr: procedure(var V: OleVariant; const Value: string);
    OleVarFromVar: procedure(var V: OleVariant; const Value: Variant);
    OleVarFromInt: procedure(var V: OleVariant; const Value: Integer; const Range: ShortInt);
    OleVarFromInt64: procedure(var V: OleVariant; const Value: Int64);
    VarOp: procedure(var Left: Variant; const Right: Variant; OpCode: TVarOp);
    VarCmp: procedure(const Left, Right: TVarData; const OpCode: TVarOp); { result is set in the flags }
    VarNeg: procedure(var V: Variant);
    VarNot: procedure(var V: Variant);
    DispInvoke: procedure(Dest: PVarData; const Source: TVarData;
      CallDesc: PCallDesc; Params: Pointer); cdecl;
    VarAddRef: procedure(var V: Variant);
    VarArrayRedim: procedure(var A : Variant; HighBound: Integer);
    VarArrayGet: function(var A: Variant; IndexCount: Integer;
      Indices: Integer): Variant; cdecl;
    VarArrayPut: procedure(var A: Variant; const Value: Variant;
      IndexCount: Integer; Indices: Integer); cdecl;
    WriteVariant: function(var T: Text; const V: Variant; Width: Integer): Pointer;
    Write0Variant: function(var T: Text; const V: Variant): Pointer;
  end deprecated;

C++ 

TestClassRegEx: some trex text
TestVariant : 0:0:4.895 ms
TestInteger : 0:0:4.292 ms
Test_Int64 : 0:0:4.374 ms

My debit card has been fraudulently used today at 8 online sites. This DLX thing was for 9.95. I think it's the one that I've been hearing about lately that thinks they can "sneak" such a low charge in onto people's accounts without being noticed. Not sure how to report it but thankfully my bank is handling it, as well as all the other charges. I'm just trying to do what I can to report these charges to all the companies involved so they can reverse charges/ not send the creep products.

http://betadata.courier-journal.com/crime/case/8012001579

Einem Sicherheitsforscher ist es gelungen, eine Sicherheitslücke in der OnStar-App von General Motors auszunutzen, um Auto-Türen zu entriegeln und sogar den Motor per Fernsteuerung zu starten.

Der US-Autohersteller General Motors bietet seinen Kunden mit OnStar ein Kommunikationssystem an, mit dem sich Fahrzeugfunktionen per App steuern lassen. Der Hacker Samy Kamkar konnte sich nach eigenen Aussagen zwischen die OnStar RemoteLink App und die Server des Unternehmens einklinken. In einem Video zeigt Kamkar, wie er über sein Smartphone den Standort des Fahrzeugs ausfindig macht, dessen Türen öffnet und schließlich sogar den Motor starten kann. 

http://www.heise.de/newsticker/meldung/Hacker-knackt-OnStar-Kommunikationssystem-von-General-Motors-2766786.html?wt_mc=nl.ho.2015-08-01

el pan de la vida eterna