unit uPSI_neuralabfun;
{
This file has been generated by UnitParser v0.7, written by M. Knight
and updated by NP. v/d Spek and George Birbilis. 
Source Code from Carlo Kok has been used to implement various sections of
UnitParser. Components of ROPS are used in the construction of UnitParser,
code implementing the class wrapper is taken from Carlo Kok's conv utility

}
interface
 

 
uses
   SysUtils
  ,Classes
  ,uPSComponent
  ,uPSRuntime
  ,uPSCompiler
  ;
 
type 
(*----------------------------------------------------------------------------*)
  TPSImport_neuralabfun = class(TPSPlugin)
  public
    procedure CompileImport1(CompExec: TPSScript); override;
    procedure ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter); override;
  end;
 
 
{ compile-time registration functions }
procedure SIRegister_TCreateValidOperations(CL: TPSPascalCompiler);
procedure SIRegister_TRunOperation(CL: TPSPascalCompiler);
procedure SIRegister_TTestsClass(CL: TPSPascalCompiler);
procedure SIRegister_TOperation(CL: TPSPascalCompiler);
procedure SIRegister_neuralabfun(CL: TPSPascalCompiler);

{ run-time registration functions }
procedure RIRegister_TCreateValidOperations(CL: TPSRuntimeClassImporter);
procedure RIRegister_TRunOperation(CL: TPSRuntimeClassImporter);
procedure RIRegister_TTestsClass(CL: TPSRuntimeClassImporter);
procedure RIRegister_neuralabfun_Routines(S: TPSExec);
procedure RIRegister_TOperation(CL: TPSRuntimeClassImporter);
procedure RIRegister_neuralabfun(CL: TPSRuntimeClassImporter);

procedure Register;

implementation


uses
   neuralab
  ,neuralabfun
  ;
 
 
procedure Register;
begin
  RegisterComponents('Pascal Script', [TPSImport_neuralabfun]);
end;

(* === compile-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure SIRegister_TCreateValidOperations(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TRunOperation', 'TCreateValidOperations') do
  with CL.AddClassN(CL.FindClass('TRunOperation'),'TCreateValidOperations') do
  begin
    RegisterMethod('Procedure LoadCreationData( PredictedBytePos : integer)');
    RegisterMethod('Function GetCount( ) : integer');
    RegisterMethod('Function GetRandomOp : TOperation');
    RegisterMethod('Function GetFeatureCenter2D : integer');
    RegisterMethod('Procedure Clear');
    RegisterMethod('Procedure Create( Tests, FullEqual : boolean; var ERRORS : array of byte)');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TRunOperation(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TOBJECT', 'TRunOperation') do
  with CL.AddClassN(CL.FindClass('TOBJECT'),'TRunOperation') do
  begin
    RegisterMethod('Procedure Load( PCS : TCreateOperationSettings; var PActions, PCurrentStates, PNextStates : array of byte)');
    RegisterMethod('Function Make2D( X, Y : integer) : integer');
    RegisterMethod('Function CreateFeatureCenter( ) : integer');
    RegisterMethod('Function GetRandom2DPos( Center : integer) : integer');
    RegisterMethod('Function CreateActionRandomBinaryTest( ) : TOperation');
    RegisterMethod('Function OperateAndTestOperation( Oper : TOperation; BasePosition : integer; var NextState : byte) : byte');
    RegisterMethod('Function TestTests( var Tests : TTestsClass) : integer');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TTestsClass(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TOBJECT', 'TTestsClass') do
  with CL.AddClassN(CL.FindClass('TOBJECT'),'TTestsClass') do
  begin
    RegisterProperty('TestBasePosition', 'integer', iptrw);
    RegisterProperty('TestThreshold', 'byte', iptrw);
    RegisterProperty('N', 'byte', iptrw);
    RegisterProperty('T', '', iptrw);
    RegisterMethod('Function ToHumanString( ) : string');
    RegisterMethod('Procedure DeleteOperation( operationIndex : integer)');
    RegisterMethod('Function ToString( ) : string');
    RegisterMethod('Procedure LoadFromString( str : string)');
    RegisterMethod('Procedure AddTest( Adding : TOperation)');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TOperation(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TOBJECT', 'TOperation') do
  with CL.AddClassN(CL.FindClass('TOBJECT'),'TOperation') do
  begin
    RegisterProperty('OpCode', 'byte', iptrw);
    RegisterProperty('Op1', 'integer', iptrw);
    RegisterProperty('Op2', 'integer', iptrw);
    RegisterProperty('RelativeOperandPosition1', 'boolean', iptrw);
    RegisterProperty('RelativeOperandPosition2', 'boolean', iptrw);
    RegisterProperty('RunOnAction', 'boolean', iptrw);
    RegisterMethod('Function ToString( ) : string');
    RegisterMethod('Function ToHumanString( ) : string');
    RegisterMethod('Procedure LoadFromString( str : string)');
    RegisterMethod('Function Define( FN : byte; pOp1 : integer; pOp2 : integer; RelOp1 : boolean; RelOp2 : boolean; PRunOnAction : boolean) : TOperation');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_neuralabfun(CL: TPSPascalCompiler);
begin
 CL.AddConstantN('csNop','LongInt').SetInt( 0);
 CL.AddConstantN('csEqual','LongInt').SetInt( 1);
 CL.AddConstantN('csEqualM','LongInt').SetInt( 2);
 CL.AddConstantN('csDifer','LongInt').SetInt( 3);
 CL.AddConstantN('csGreater','LongInt').SetInt( 4);
 CL.AddConstantN('csLesser','LongInt').SetInt( 5);
 CL.AddConstantN('csTrue','LongInt').SetInt( 6);
 CL.AddConstantN('csSet','LongInt').SetInt( 7);
 CL.AddConstantN('csInc','LongInt').SetInt( 8);
 CL.AddConstantN('csDec','LongInt').SetInt( 9);
 CL.AddConstantN('csAdd','LongInt').SetInt( 10);
 CL.AddConstantN('csSub','LongInt').SetInt( 11);
 CL.AddConstantN('csMul','LongInt').SetInt( 12);
 CL.AddConstantN('csDiv','LongInt').SetInt( 13);
 CL.AddConstantN('csMod','LongInt').SetInt( 14);
 CL.AddConstantN('csAnd','LongInt').SetInt( 15);
 CL.AddConstantN('csOr','LongInt').SetInt( 16);
 CL.AddConstantN('csXor','LongInt').SetInt( 17);
 CL.AddConstantN('csInj','LongInt').SetInt( 18);
 CL.AddConstantN('csNot','LongInt').SetInt( 19);
  CL.AddTypeS('TPositionArray', 'array of integer');
  SIRegister_TOperation(CL);
 CL.AddDelphiFunction('Function CreateOperation( FN : byte; pOp1 : integer; pOp2 : integer; RelOp1 : boolean; RelOp2 : boolean; PRunOnAction : boolean) : TOperation');
 CL.AddDelphiFunction('Function CreateValidBinaryTest( Val1, Val2 : byte; pOp1, pOp2 : integer; RelOp1, RelOp2, PRunOnAction : boolean) : TOperation');
 CL.AddConstantN('csMaxOperations','LongInt').SetInt( 20);
  CL.AddTypeS('TOperationSet', 'set of Integer');
 CL.AddConstantN('TestOperationSet','TOperationSet').SetString(ord(csEqual) or ord(csEqualM) or ord(csDifer) or ord(csGreater) or ord(csLesser) or ord(csTrue));
 CL.AddConstantN('ImediatSet','TOperationSet').SetString(ord(csEqual) or ord(csSet));
 CL.AddConstantN('FirstImediatSet','TOperationSet').SetString(ord(csEqual));
 CL.AddConstantN('StateOperationSet','TOperationSet').SetString(ord(csInc) or ord(csDec) or ord(csAdd) or ord(csSub) or ord(csMul) or ord(csDiv) or ord(csMod) or ord(csAnd) or ord(csXor) or ord(csOr) or ord(csNot) or ord(csInj));
 CL.AddConstantN('BinaryOperationSet','TOperationSet').SetString(ord(csAdd) or ord(csSub) or ord(csMul) or ord(csDiv) or ord(csMod) or ord(csAnd) or ord(csXor) or ord(csOr) or ord(csEqual) or ord(csEqualM) or ord(csDifer) or ord(csGreater) or ord(csLesser));
 CL.AddConstantN('NoArgSet','TOperationSet').SetString(ord(csInc) or ord(csDec) or ord(csNot) or ord(csInj));
 CL.AddConstantN('csMaxTests','LongInt').SetInt( 30);
  SIRegister_TTestsClass(CL);
  CL.AddTypeS('TCreateOperationSettings', 'record AddSetOp : boolean; AddBinary'
   +'Op : boolean; AddBinaryTest : boolean; AddEqualTest : boolean; AddTrueTest'
   +' : boolean; AddIncOp : boolean; AddDecOp : boolean; AddInjOp : boolean; Ad'
   +'dNotOp : boolean; TestOnActions : boolean; TestOnStates : boolean; Bidimen'
   +'sional : boolean; PartialTestEval : boolean; MinTests : byte; MaxTests : b'
   +'yte; FeatureSize : byte; ImageSizeX : integer; ImageSizeY : integer; MinSa'
   +'mpleForPrediction : integer; end');
  SIRegister_TRunOperation(CL);
 CL.AddConstantN('csMaxOperationsArray','LongInt').SetInt( 1500);
  SIRegister_TCreateValidOperations(CL);
end;

(* === run-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure TTestsClassT_W(Self: TTestsClass; const T: );
Begin Self.T := T; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassT_R(Self: TTestsClass; var T: );
Begin T := Self.T; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassN_W(Self: TTestsClass; const T: byte);
Begin Self.N := T; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassN_R(Self: TTestsClass; var T: byte);
Begin T := Self.N; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassTestThreshold_W(Self: TTestsClass; const T: byte);
Begin Self.TestThreshold := T; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassTestThreshold_R(Self: TTestsClass; var T: byte);
Begin T := Self.TestThreshold; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassTestBasePosition_W(Self: TTestsClass; const T: integer);
Begin Self.TestBasePosition := T; end;

(*----------------------------------------------------------------------------*)
procedure TTestsClassTestBasePosition_R(Self: TTestsClass; var T: integer);
Begin T := Self.TestBasePosition; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRunOnAction_W(Self: TOperation; const T: boolean);
Begin Self.RunOnAction := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRunOnAction_R(Self: TOperation; var T: boolean);
Begin T := Self.RunOnAction; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRelativeOperandPosition2_W(Self: TOperation; const T: boolean);
Begin Self.RelativeOperandPosition2 := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRelativeOperandPosition2_R(Self: TOperation; var T: boolean);
Begin T := Self.RelativeOperandPosition2; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRelativeOperandPosition1_W(Self: TOperation; const T: boolean);
Begin Self.RelativeOperandPosition1 := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationRelativeOperandPosition1_R(Self: TOperation; var T: boolean);
Begin T := Self.RelativeOperandPosition1; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOp2_W(Self: TOperation; const T: integer);
Begin Self.Op2 := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOp2_R(Self: TOperation; var T: integer);
Begin T := Self.Op2; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOp1_W(Self: TOperation; const T: integer);
Begin Self.Op1 := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOp1_R(Self: TOperation; var T: integer);
Begin T := Self.Op1; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOpCode_W(Self: TOperation; const T: byte);
Begin Self.OpCode := T; end;

(*----------------------------------------------------------------------------*)
procedure TOperationOpCode_R(Self: TOperation; var T: byte);
Begin T := Self.OpCode; end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TCreateValidOperations(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TCreateValidOperations) do
  begin
    RegisterMethod(@TCreateValidOperations.LoadCreationData, 'LoadCreationData');
    RegisterMethod(@TCreateValidOperations.GetCount, 'GetCount');
    RegisterMethod(@TCreateValidOperations.GetRandomOp, 'GetRandomOp');
    RegisterMethod(@TCreateValidOperations.GetFeatureCenter2D, 'GetFeatureCenter2D');
    RegisterMethod(@TCreateValidOperations.Clear, 'Clear');
    RegisterMethod(@TCreateValidOperations.Create, 'Create');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TRunOperation(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TRunOperation) do
  begin
    RegisterMethod(@TRunOperation.Load, 'Load');
    RegisterMethod(@TRunOperation.Make2D, 'Make2D');
    RegisterMethod(@TRunOperation.CreateFeatureCenter, 'CreateFeatureCenter');
    RegisterMethod(@TRunOperation.GetRandom2DPos, 'GetRandom2DPos');
    RegisterMethod(@TRunOperation.CreateActionRandomBinaryTest, 'CreateActionRandomBinaryTest');
    RegisterMethod(@TRunOperation.OperateAndTestOperation, 'OperateAndTestOperation');
    RegisterMethod(@TRunOperation.TestTests, 'TestTests');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TTestsClass(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TTestsClass) do
  begin
    RegisterPropertyHelper(@TTestsClassTestBasePosition_R,@TTestsClassTestBasePosition_W,'TestBasePosition');
    RegisterPropertyHelper(@TTestsClassTestThreshold_R,@TTestsClassTestThreshold_W,'TestThreshold');
    RegisterPropertyHelper(@TTestsClassN_R,@TTestsClassN_W,'N');
    RegisterPropertyHelper(@TTestsClassT_R,@TTestsClassT_W,'T');
    RegisterMethod(@TTestsClass.ToHumanString, 'ToHumanString');
    RegisterMethod(@TTestsClass.DeleteOperation, 'DeleteOperation');
    RegisterMethod(@TTestsClass.ToString, 'ToString');
    RegisterMethod(@TTestsClass.LoadFromString, 'LoadFromString');
    RegisterMethod(@TTestsClass.AddTest, 'AddTest');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_neuralabfun_Routines(S: TPSExec);
begin
 S.RegisterDelphiFunction(@CreateOperation, 'CreateOperation', cdRegister);
 S.RegisterDelphiFunction(@CreateValidBinaryTest, 'CreateValidBinaryTest', cdRegister);
  RIRegister_TTestsClass(CL);
  RIRegister_TRunOperation(CL);
  RIRegister_TCreateValidOperations(CL);
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TOperation(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TOperation) do
  begin
    RegisterPropertyHelper(@TOperationOpCode_R,@TOperationOpCode_W,'OpCode');
    RegisterPropertyHelper(@TOperationOp1_R,@TOperationOp1_W,'Op1');
    RegisterPropertyHelper(@TOperationOp2_R,@TOperationOp2_W,'Op2');
    RegisterPropertyHelper(@TOperationRelativeOperandPosition1_R,@TOperationRelativeOperandPosition1_W,'RelativeOperandPosition1');
    RegisterPropertyHelper(@TOperationRelativeOperandPosition2_R,@TOperationRelativeOperandPosition2_W,'RelativeOperandPosition2');
    RegisterPropertyHelper(@TOperationRunOnAction_R,@TOperationRunOnAction_W,'RunOnAction');
    RegisterMethod(@TOperation.ToString, 'ToString');
    RegisterMethod(@TOperation.ToHumanString, 'ToHumanString');
    RegisterMethod(@TOperation.LoadFromString, 'LoadFromString');
    RegisterMethod(@TOperation.Define, 'Define');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_neuralabfun(CL: TPSRuntimeClassImporter);
begin
  RIRegister_TOperation(CL);
end;

 
 
{ TPSImport_neuralabfun }
(*----------------------------------------------------------------------------*)
procedure TPSImport_neuralabfun.CompileImport1(CompExec: TPSScript);
begin
  SIRegister_neuralabfun(CompExec.Comp);
end;
(*----------------------------------------------------------------------------*)
procedure TPSImport_neuralabfun.ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter);
begin
  RIRegister_neuralabfun(ri);
  RIRegister_neuralabfun_Routines(CompExec.Exec); // comment it if no routines
end;
(*----------------------------------------------------------------------------*)
 
 
end.
