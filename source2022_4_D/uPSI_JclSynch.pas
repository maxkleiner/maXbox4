unit uPSI_JclSynch;
{
This file has been generated by UnitParser v0.7, written by M. Knight
and updated by NP. v/d Spek and George Birbilis. 
Source Code from Carlo Kok has been used to implement various sections of
UnitParser. Components of ROPS are used in the construction of UnitParser,
code implementing the class wrapper is taken from Carlo Kok's conv utility

}
interface
 
uses
   SysUtils
  ,Classes
  ,uPSComponent
  ,uPSRuntime
  ,uPSCompiler
  ;
 
type 
(*----------------------------------------------------------------------------*)
  TPSImport_JclSynch = class(TPSPlugin)
  protected
    procedure CompileImport1(CompExec: TPSScript); override;
    procedure ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter); override;
  end;
 
 
{ compile-time registration functions }
procedure SIRegister_TJclMeteredSection(CL: TPSPascalCompiler);
procedure SIRegister_TJclMultiReadExclusiveWrite(CL: TPSPascalCompiler);
procedure SIRegister_TJclOptex(CL: TPSPascalCompiler);
procedure SIRegister_TJclMutex(CL: TPSPascalCompiler);
procedure SIRegister_TJclSemaphore(CL: TPSPascalCompiler);
procedure SIRegister_TJclWaitableTimer(CL: TPSPascalCompiler);
procedure SIRegister_TJclEvent(CL: TPSPascalCompiler);
procedure SIRegister_TJclCriticalSectionEx(CL: TPSPascalCompiler);
procedure SIRegister_TJclCriticalSection(CL: TPSPascalCompiler);
procedure SIRegister_TJclDispatcherObject(CL: TPSPascalCompiler);
procedure SIRegister_JclSynch(CL: TPSPascalCompiler);

{ run-time registration functions }
procedure RIRegister_TJclMeteredSection(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclMultiReadExclusiveWrite(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclOptex(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclMutex(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclSemaphore(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclWaitableTimer(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclEvent(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclCriticalSectionEx(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclCriticalSection(CL: TPSRuntimeClassImporter);
procedure RIRegister_TJclDispatcherObject(CL: TPSRuntimeClassImporter);
procedure RIRegister_JclSynch_Routines(S: TPSExec);
procedure RIRegister_JclSynch(CL: TPSRuntimeClassImporter);


procedure Register;

implementation


uses
   Windows
  ,JclBase
  ,JclSynch
  ;
 
 
procedure Register;
begin
  RegisterComponents('Pascal Script', [TPSImport_JclSynch]);
end;

(* === compile-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclMeteredSection(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TJclMeteredSection') do
  with CL.AddClassN(CL.FindClass('TObject'),'TJclMeteredSection') do begin
     RegisterMethod('Procedure Free');
     RegisterMethod('Constructor Create( InitialCount, MaxCount : Longint; const Name : string);');
    RegisterMethod('Constructor Open( const Name : string)');
    RegisterMethod('Function Enter( TimeOut : Longword) : TJclWaitResult');
    RegisterMethod('Function Leave( ReleaseCount : Longint) : Boolean;');
    RegisterMethod('Function Leave1( ReleaseCount : Longint; var PrevCount : Longint) : Boolean;');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclMultiReadExclusiveWrite(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TJclMultiReadExclusiveWrite') do
  with CL.AddClassN(CL.FindClass('TObject'),'TJclMultiReadExclusiveWrite') do begin
    RegisterMethod('Constructor Create( Preferred : TMrewPreferred)');
       RegisterMethod('Procedure Free');
     RegisterMethod('Procedure BeginRead');
    RegisterMethod('Procedure BeginWrite');
    RegisterMethod('Procedure EndRead');
    RegisterMethod('Procedure EndWrite');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclOptex(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TJclOptex') do
  with CL.AddClassN(CL.FindClass('TObject'),'TJclOptex') do begin
    RegisterMethod('Constructor Create( const Name : string; SpinCount : Integer)');
   RegisterMethod('Procedure Free');
     RegisterMethod('Procedure Enter');
    RegisterMethod('Procedure Leave');
    RegisterMethod('Function TryEnter : Boolean');
    RegisterProperty('Existed', 'Boolean', iptr);
    RegisterProperty('Name', 'string', iptr);
    RegisterProperty('SpinCount', 'Integer', iptrw);
    RegisterProperty('UniProcess', 'Boolean', iptr);
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclMutex(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TJclDispatcherObject', 'TJclMutex') do
  with CL.AddClassN(CL.FindClass('TJclDispatcherObject'),'TJclMutex') do
  begin
    RegisterMethod('Constructor Create( SecAttr : PSecurityAttributes; InitialOwner : Boolean; const Name : string)');
    RegisterMethod('Constructor Open( Access : Cardinal; Inheritable : Boolean; const Name : string)');
    RegisterMethod('Function Release : Boolean');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclSemaphore(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TJclDispatcherObject', 'TJclSemaphore') do
  with CL.AddClassN(CL.FindClass('TJclDispatcherObject'),'TJclSemaphore') do
  begin
    RegisterMethod('Constructor Create( SecAttr : PSecurityAttributes; Initial, Maximum : Longint; const Name : string)');
    RegisterMethod('Constructor Open( Access : Cardinal; Inheritable : Boolean; const Name : string)');
    RegisterMethod('Function Release( ReleaseCount : Longint) : Boolean');
    RegisterMethod('Function ReleasePrev( ReleaseCount : Longint; var PrevCount : Longint) : Boolean');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclWaitableTimer(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TJclDispatcherObject', 'TJclWaitableTimer') do
  with CL.AddClassN(CL.FindClass('TJclDispatcherObject'),'TJclWaitableTimer') do
  begin
    RegisterMethod('Constructor Create( SecAttr : PSecurityAttributes; Manual : Boolean; const Name : string)');
    RegisterMethod('Constructor Open( Access : Cardinal; Inheritable : Boolean; const Name : string)');
    RegisterMethod('Function Cancel : Boolean');
    RegisterMethod('Function SetTimer( const DueTime : Int64; Period : Longint; Resume : Boolean) : Boolean');
    RegisterMethod('Function SetTimerApc( const DueTime : Int64; Period : Longint; Resume : Boolean; Apc : TFNTimerAPCRoutine; Arg : Pointer) : Boolean');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclEvent(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TJclDispatcherObject', 'TJclEvent') do
  with CL.AddClassN(CL.FindClass('TJclDispatcherObject'),'TJclEvent') do begin
    RegisterMethod('Constructor Create( SecAttr : PSecurityAttributes; Manual, Signaled : Boolean; const Name : string)');
    RegisterMethod('Constructor Open( Access : Cardinal; Inheritable : Boolean; const Name : string)');
    RegisterMethod('Function Pulse : Boolean');
    RegisterMethod('Function ResetEvent : Boolean');
    RegisterMethod('Function SetEvent : Boolean');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclCriticalSectionEx(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TJclCriticalSection', 'TJclCriticalSectionEx') do
  with CL.AddClassN(CL.FindClass('TJclCriticalSection'),'TJclCriticalSectionEx') do
  begin
    RegisterMethod('Constructor Create');
    RegisterMethod('Constructor CreateEx( SpinCount : Cardinal; NoFailEnter : Boolean)');
    RegisterMethod('Function GetSpinTimeOut : Cardinal');
    RegisterMethod('Procedure SetSpinTimeOut( const Value : Cardinal)');
    RegisterMethod('Function TryEnter : Boolean');
    RegisterProperty('SpinCount', 'Cardinal', iptrw);
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclCriticalSection(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TJclCriticalSection') do
  with CL.AddClassN(CL.FindClass('TObject'),'TJclCriticalSection') do begin
    RegisterMethod('Constructor Create');
    RegisterMethod('Procedure CreateAndEnter( var CS : TJclCriticalSection)');
    RegisterMethod('Procedure Enter');
    RegisterMethod('Procedure Leave');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_TJclDispatcherObject(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'TObject', 'TJclDispatcherObject') do
  with CL.AddClassN(CL.FindClass('TObject'),'TJclDispatcherObject') do begin
    RegisterMethod('Constructor Attach( Handle : THandle)');
       RegisterMethod('Procedure Free');
    RegisterMethod('Function SignalAndWait( const Obj : TJclDispatcherObject; TimeOut : Cardinal; Alertable : Boolean) : TJclWaitResult');
    RegisterMethod('Function WaitAlertable( const TimeOut : Cardinal) : TJclWaitResult');
    RegisterMethod('Function WaitFor( const TimeOut : Cardinal) : TJclWaitResult');
    RegisterMethod('Function WaitForever : TJclWaitResult');
    RegisterProperty('Existed', 'Boolean', iptr);
    RegisterProperty('Handle', 'THandle', iptr);
    RegisterProperty('Name', 'string', iptr);
  end;
end;

(*----------------------------------------------------------------------------*)
procedure SIRegister_JclSynch(CL: TPSPascalCompiler);
begin
 CL.AddDelphiFunction('Function LockedAdd( var Target : Integer; Value : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedCompareExchange( var Target : Integer; Exch, Comp : Integer) : Integer;');
 CL.AddDelphiFunction('Function LockedCompareExchange1( var Target : ___Pointer; Exch, Comp : ___Pointer) : ___Pointer;');
 CL.AddDelphiFunction('Function LockedDec( var Target : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedExchange( var Target : Integer; Value : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedExchangeAdd( var Target : Integer; Value : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedExchangeDec( var Target : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedExchangeInc( var Target : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedExchangeSub( var Target : Integer; Value : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedInc( var Target : Integer) : Integer');
 CL.AddDelphiFunction('Function LockedSub( var Target : Integer; Value : Integer) : Integer');
  CL.AddTypeS('TJclWaitResult', '( wrAbandoned, wrError, wrIoCompletion, wrSignaled, wrTimeout )');
  SIRegister_TJclDispatcherObject(CL);
 CL.AddDelphiFunction('Function WaitForMultipleObjects( const Objects : array of TJclDispatcherObject; WaitAll : Boolean; TimeOut : Cardinal) : Cardinal');
 CL.AddDelphiFunction('Function WaitAlertableForMultipleObjects( const Objects : array of TJclDispatcherObject; WaitAll : Boolean; TimeOut : Cardinal) : Cardinal');
  SIRegister_TJclCriticalSection(CL);
  SIRegister_TJclCriticalSectionEx(CL);
  SIRegister_TJclEvent(CL);
  SIRegister_TJclWaitableTimer(CL);
  SIRegister_TJclSemaphore(CL);
  SIRegister_TJclMutex(CL);
  //CL.AddTypeS('POptexSharedInfo', '^TOptexSharedInfo // will not work');
  CL.AddTypeS('TOptexSharedInfo', 'record SpinCount : Integer; LockCount : Inte'
   +'ger; ThreadId : Longword; RecursionCount : Integer; end');
  SIRegister_TJclOptex(CL);
  CL.AddTypeS('TMrewPreferred', '( mpReaders, mpWriters, mpEqual )');
  CL.AddTypeS('TMrewThreadInfo', 'record ThreadId : Longword; RecursionCount : '
   +'Integer; Reader : Boolean; end');
  CL.AddTypeS('TMrewThreadInfoArray', 'array of TMrewThreadInfo');
  SIRegister_TJclMultiReadExclusiveWrite(CL);
  //CL.AddTypeS('PMetSectSharedInfo', '^TMetSectSharedInfo // will not work');
  CL.AddTypeS('TMetSectSharedInfo', 'record Initialized : Bool; SpinLock : '
   +'Longint; ThreadsWaiting : Longint; AvailableCount : Longint; MaximumCount: Longint; end');
  //CL.AddTypeS('PMeteredSection', '^TMeteredSection // will not work');
  //CL.AddTypeS('TMeteredSection', 'record Event : THandle; FileMap : THandle; SharedInfo : PMetSectSharedInfo; end');
  SIRegister_TJclMeteredSection(CL);
  CL.AddTypeS('TEventInfo', 'record EventType : Longint; Signaled : LongBool; end');
  CL.AddTypeS('TMutexInfo', 'record SignalState : Longint; Owned : Boolean; Abandoned : Boolean; end');
  CL.AddTypeS('TSemaphoreCounts', 'record CurrentCount : Longint; MaximumCount: Longint; end');
  CL.AddTypeS('TTimerInfo', 'record Remaining : TLargeInteger; Signaled : LongBool; end');
 CL.AddDelphiFunction('Function QueryCriticalSection( CS : TJclCriticalSection; var Info : TRTLCriticalSection) : Boolean');
 CL.AddDelphiFunction('Function QueryEvent( Handle : THandle; var Info : TEventInfo) : Boolean');
 CL.AddDelphiFunction('Function QueryMutex( Handle : THandle; var Info : TMutexInfo) : Boolean');
 CL.AddDelphiFunction('Function QuerySemaphore( Handle : THandle; var Info : TSemaphoreCounts) : Boolean');
 CL.AddDelphiFunction('Function QueryTimer( Handle : THandle; var Info : TTimerInfo) : Boolean');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclWin32HandleObjectError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclDispatcherObjectError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclCriticalSectionError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclEventError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclWaitableTimerError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclSemaphoreError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclMutexError');
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclMeteredSectionError');
end;

(* === run-time registration functions === *)
(*----------------------------------------------------------------------------*)
Function TJclMeteredSectionLeave1_P(Self: TJclMeteredSection;  ReleaseCount : Longint; var PrevCount : Longint) : Boolean;
Begin Result := Self.Leave(ReleaseCount, PrevCount); END;

(*----------------------------------------------------------------------------*)
Function TJclMeteredSectionLeave_P(Self: TJclMeteredSection;  ReleaseCount : Longint) : Boolean;
Begin Result := Self.Leave(ReleaseCount); END;

(*----------------------------------------------------------------------------*)
Function TJclMeteredSectionCreate_P(Self: TClass; CreateNewInstance: Boolean;  InitialCount, MaxCount : Longint; const Name : string):TObject;
Begin Result := TJclMeteredSection.Create(InitialCount, MaxCount, Name); END;

(*----------------------------------------------------------------------------*)
procedure TJclOptexUniProcess_R(Self: TJclOptex; var T: Boolean);
begin T := Self.UniProcess; end;

(*----------------------------------------------------------------------------*)
procedure TJclOptexSpinCount_W(Self: TJclOptex; const T: Integer);
begin Self.SpinCount := T; end;

(*----------------------------------------------------------------------------*)
procedure TJclOptexSpinCount_R(Self: TJclOptex; var T: Integer);
begin T := Self.SpinCount; end;

(*----------------------------------------------------------------------------*)
procedure TJclOptexName_R(Self: TJclOptex; var T: string);
begin T := Self.Name; end;

(*----------------------------------------------------------------------------*)
procedure TJclOptexExisted_R(Self: TJclOptex; var T: Boolean);
begin T := Self.Existed; end;

(*----------------------------------------------------------------------------*)
procedure TJclCriticalSectionExSpinCount_W(Self: TJclCriticalSectionEx; const T: Cardinal);
begin Self.SpinCount := T; end;

(*----------------------------------------------------------------------------*)
procedure TJclCriticalSectionExSpinCount_R(Self: TJclCriticalSectionEx; var T: Cardinal);
begin T := Self.SpinCount; end;

(*----------------------------------------------------------------------------*)
procedure TJclDispatcherObjectName_R(Self: TJclDispatcherObject; var T: string);
begin T := Self.Name; end;

(*----------------------------------------------------------------------------*)
procedure TJclDispatcherObjectHandle_R(Self: TJclDispatcherObject; var T: THandle);
begin T := Self.Handle; end;

(*----------------------------------------------------------------------------*)
procedure TJclDispatcherObjectExisted_R(Self: TJclDispatcherObject; var T: Boolean);
begin T := Self.Existed; end;

(*----------------------------------------------------------------------------*)
Function LockedCompareExchange1_P( var Target : Pointer; Exch, Comp : Pointer) : Pointer;
Begin Result := JclSynch.LockedCompareExchange(Target, Exch, Comp); END;

(*----------------------------------------------------------------------------*)
Function LockedCompareExchange_P( var Target : Integer; Exch, Comp : Integer) : Integer;
Begin Result := JclSynch.LockedCompareExchange(Target, Exch, Comp); END;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclMeteredSection(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclMeteredSection) do begin
    RegisterConstructor(@TJclMeteredSectionCreate_P, 'Create');
    RegisterMethod(@TJclMeteredSection.Destroy, 'Free');
     RegisterConstructor(@TJclMeteredSection.Open, 'Open');
    RegisterMethod(@TJclMeteredSection.Enter, 'Enter');
    RegisterMethod(@TJclMeteredSectionLeave_P, 'Leave');
    RegisterMethod(@TJclMeteredSectionLeave1_P, 'Leave1');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclMultiReadExclusiveWrite(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclMultiReadExclusiveWrite) do  begin
     RegisterMethod(@TJclMultiReadExclusiveWrite.Destroy, 'Free');
     RegisterVirtualConstructor(@TJclMultiReadExclusiveWrite.Create, 'Create');
    RegisterMethod(@TJclMultiReadExclusiveWrite.BeginRead, 'BeginRead');
    RegisterMethod(@TJclMultiReadExclusiveWrite.BeginWrite, 'BeginWrite');
    RegisterMethod(@TJclMultiReadExclusiveWrite.EndRead, 'EndRead');
    RegisterMethod(@TJclMultiReadExclusiveWrite.EndWrite, 'EndWrite');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclOptex(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclOptex) do begin
    RegisterConstructor(@TJclOptex.Create, 'Create');
   RegisterMethod(@TJclOptex.Destroy, 'Free');
     RegisterMethod(@TJclOptex.Enter, 'Enter');
    RegisterMethod(@TJclOptex.Leave, 'Leave');
    RegisterMethod(@TJclOptex.TryEnter, 'TryEnter');
    RegisterPropertyHelper(@TJclOptexExisted_R,nil,'Existed');
    RegisterPropertyHelper(@TJclOptexName_R,nil,'Name');
    RegisterPropertyHelper(@TJclOptexSpinCount_R,@TJclOptexSpinCount_W,'SpinCount');
    RegisterPropertyHelper(@TJclOptexUniProcess_R,nil,'UniProcess');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclMutex(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclMutex) do begin
    RegisterConstructor(@TJclMutex.Create, 'Create');
    RegisterConstructor(@TJclMutex.Open, 'Open');
    RegisterMethod(@TJclMutex.Release, 'Release');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclSemaphore(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclSemaphore) do begin
    RegisterConstructor(@TJclSemaphore.Create, 'Create');
    RegisterConstructor(@TJclSemaphore.Open, 'Open');
    RegisterMethod(@TJclSemaphore.Release, 'Release');
    RegisterMethod(@TJclSemaphore.ReleasePrev, 'ReleasePrev');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclWaitableTimer(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclWaitableTimer) do
  begin
    RegisterConstructor(@TJclWaitableTimer.Create, 'Create');
    RegisterConstructor(@TJclWaitableTimer.Open, 'Open');
    RegisterMethod(@TJclWaitableTimer.Cancel, 'Cancel');
    RegisterMethod(@TJclWaitableTimer.SetTimer, 'SetTimer');
    RegisterMethod(@TJclWaitableTimer.SetTimerApc, 'SetTimerApc');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclEvent(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclEvent) do
  begin
    RegisterConstructor(@TJclEvent.Create, 'Create');
    RegisterConstructor(@TJclEvent.Open, 'Open');
    RegisterMethod(@TJclEvent.Pulse, 'Pulse');
    RegisterMethod(@TJclEvent.ResetEvent, 'ResetEvent');
    RegisterMethod(@TJclEvent.SetEvent, 'SetEvent');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclCriticalSectionEx(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclCriticalSectionEx) do begin
    RegisterConstructor(@TJclCriticalSectionEx.Create, 'Create');
       RegisterMethod(@TJclCriticalSectionEx.Destroy, 'Free');
     RegisterVirtualConstructor(@TJclCriticalSectionEx.CreateEx, 'CreateEx');
    RegisterMethod(@TJclCriticalSectionEx.GetSpinTimeOut, 'GetSpinTimeOut');
    RegisterMethod(@TJclCriticalSectionEx.SetSpinTimeOut, 'SetSpinTimeOut');
    RegisterMethod(@TJclCriticalSectionEx.TryEnter, 'TryEnter');
    RegisterPropertyHelper(@TJclCriticalSectionExSpinCount_R,@TJclCriticalSectionExSpinCount_W,'SpinCount');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclCriticalSection(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclCriticalSection) do begin
    RegisterVirtualConstructor(@TJclCriticalSection.Create, 'Create');
    RegisterMethod(@TJclCriticalSection.Destroy, 'Free');
     RegisterMethod(@TJclCriticalSection.CreateAndEnter, 'CreateAndEnter');
    RegisterMethod(@TJclCriticalSection.Enter, 'Enter');
    RegisterMethod(@TJclCriticalSection.Leave, 'Leave');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_TJclDispatcherObject(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(TJclDispatcherObject) do
  begin
    RegisterConstructor(@TJclDispatcherObject.Attach, 'Attach');
    RegisterMethod(@TJclDispatcherObject.SignalAndWait, 'SignalAndWait');
    RegisterMethod(@TJclDispatcherObject.WaitAlertable, 'WaitAlertable');
    RegisterMethod(@TJclDispatcherObject.WaitFor, 'WaitFor');
    RegisterMethod(@TJclDispatcherObject.WaitForever, 'WaitForever');
    RegisterPropertyHelper(@TJclDispatcherObjectExisted_R,nil,'Existed');
    RegisterPropertyHelper(@TJclDispatcherObjectHandle_R,nil,'Handle');
    RegisterPropertyHelper(@TJclDispatcherObjectName_R,nil,'Name');
  end;
end;

(*----------------------------------------------------------------------------*)
procedure RIRegister_JclSynch_Routines(S: TPSExec);
begin
 S.RegisterDelphiFunction(@LockedAdd, 'LockedAdd', cdRegister);
 S.RegisterDelphiFunction(@LockedCompareExchange, 'LockedCompareExchange', cdRegister);
 S.RegisterDelphiFunction(@LockedCompareExchange1_P, 'LockedCompareExchange1', cdRegister);
 S.RegisterDelphiFunction(@LockedDec, 'LockedDec', cdRegister);
 S.RegisterDelphiFunction(@LockedExchange, 'LockedExchange', cdRegister);
 S.RegisterDelphiFunction(@LockedExchangeAdd, 'LockedExchangeAdd', cdRegister);
 S.RegisterDelphiFunction(@LockedExchangeDec, 'LockedExchangeDec', cdRegister);
 S.RegisterDelphiFunction(@LockedExchangeInc, 'LockedExchangeInc', cdRegister);
 S.RegisterDelphiFunction(@LockedExchangeSub, 'LockedExchangeSub', cdRegister);
 S.RegisterDelphiFunction(@LockedInc, 'LockedInc', cdRegister);
 S.RegisterDelphiFunction(@LockedSub, 'LockedSub', cdRegister);
 // RIRegister_TJclDispatcherObject(CL);
 S.RegisterDelphiFunction(@WaitForMultipleObjects, 'WaitForMultipleObjects', cdRegister);
 S.RegisterDelphiFunction(@WaitAlertableForMultipleObjects, 'WaitAlertableForMultipleObjects', cdRegister);
 { RIRegister_TJclCriticalSection(CL);
  RIRegister_TJclCriticalSectionEx(CL);
  RIRegister_TJclEvent(CL);
  RIRegister_TJclWaitableTimer(CL);
  RIRegister_TJclSemaphore(CL);
  RIRegister_TJclMutex(CL);
  RIRegister_TJclOptex(CL);
  RIRegister_TJclMultiReadExclusiveWrite(CL);
  RIRegister_TJclMeteredSection(CL);}
 S.RegisterDelphiFunction(@QueryCriticalSection, 'QueryCriticalSection', cdRegister);
 S.RegisterDelphiFunction(@QueryEvent, 'QueryEvent', cdRegister);
 S.RegisterDelphiFunction(@QueryMutex, 'QueryMutex', cdRegister);
 S.RegisterDelphiFunction(@QuerySemaphore, 'QuerySemaphore', cdRegister);
 S.RegisterDelphiFunction(@QueryTimer, 'QueryTimer', cdRegister);
 end;

procedure RIRegister_JclSynch(CL: TPSRuntimeClassImporter);
begin
   with CL.Add(EJclWin32HandleObjectError) do
  with CL.Add(EJclDispatcherObjectError) do
  with CL.Add(EJclCriticalSectionError) do
  with CL.Add(EJclEventError) do
  with CL.Add(EJclWaitableTimerError) do
  with CL.Add(EJclSemaphoreError) do
  with CL.Add(EJclMutexError) do
  with CL.Add(EJclMeteredSectionError) do

  RIRegister_TJclDispatcherObject(CL);
// S.RegisterDelphiFunction(@WaitForMultipleObjects, 'WaitForMultipleObjects', cdRegister);
 //S.RegisterDelphiFunction(@WaitAlertableForMultipleObjects, 'WaitAlertableForMultipleObjects', cdRegister);
  RIRegister_TJclCriticalSection(CL);
  RIRegister_TJclCriticalSectionEx(CL);
  RIRegister_TJclEvent(CL);
  RIRegister_TJclWaitableTimer(CL);
  RIRegister_TJclSemaphore(CL);
  RIRegister_TJclMutex(CL);
  RIRegister_TJclOptex(CL);
  RIRegister_TJclMultiReadExclusiveWrite(CL);
  RIRegister_TJclMeteredSection(CL);

end;

 
 
{ TPSImport_JclSynch }
(*----------------------------------------------------------------------------*)
procedure TPSImport_JclSynch.CompileImport1(CompExec: TPSScript);
begin
  SIRegister_JclSynch(CompExec.Comp);
end;
(*----------------------------------------------------------------------------*)
procedure TPSImport_JclSynch.ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter);
begin
  RIRegister_JclSynch(ri);
  RIRegister_JclSynch_Routines(CompExec.Exec); // comment it if no routines
end;
(*----------------------------------------------------------------------------*)
 
 
end.
