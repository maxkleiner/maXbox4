unit uPSI_MathMax;
{
This file has been generated by UnitParser v0.7, written by M. Knight
and updated by NP. v/d Spek and George Birbilis. 
enhanced by max  - 3.6.3 JCLmath  added  - radtograd bugfix
comparevalue missing, samevalue added  , hextodouble!
more from upsi_jclmath   , define extended      check arctan
}
interface
 
uses
   SysUtils
  ,uPSComponent
  ,uPSRuntime
  ,uPSCompiler
  ;
 
type
(*----------------------------------------------------------------------------*)
  TPSImport_MathMax = class(TPSPlugin)
  protected
    procedure CompileImport1(CompExec: TPSScript); override;
    procedure ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter); override;
  end;


{ compile-time registration functions }
procedure SIRegister_EInvalidArgument(CL: TPSPascalCompiler);
procedure SIRegister_MathMax(CL: TPSPascalCompiler);

{ run-time registration functions }
procedure RIRegister_EInvalidArgument(CL: TPSRuntimeClassImporter);
procedure RIRegister_MathMax_Routines(S: TPSExec);

procedure Register;

implementation

uses
   Types, MathMax, JCLMath_max;


type
  TRoundToRange = -37..37;

type
 TRoundToEXRangeExtended = -20..20;


procedure Register;
begin
  //RegisterComponents('Pascal Script', [TPSImport_MathMax]);
end;

(* === compile-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure SIRegister_EInvalidArgument(CL: TPSPascalCompiler);
begin
  //with RegClassS(CL,'EMathError', 'EInvalidArgument') do
  with CL.AddClassN(CL.FindClass('EMathError'),'EInvalidArgument') do
  begin
  end;
end;


function SameValueE(const A, B: Extended; Epsilon: Double): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := Max(Min(Abs(A), Abs(B)) * ExtendedResolution, ExtendedResolution);
  if A > B then
    Result := (A - B) <= Epsilon
  else
    Result := (B - A) <= Epsilon;
end;


function SameValue1(const A, B: Double; Epsilon: Double): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := Max(Min(Abs(A), Abs(B)) * DoubleResolution, DoubleResolution);
  if A > B then
    Result := (A - B) <= Epsilon
  else
    Result := (B - A) <= Epsilon;
end;

function SameValue2(const A, B: Single; Epsilon: Single): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := Max(Min(Abs(A), Abs(B)) * SingleResolution, SingleResolution);
  if A > B then
    Result := (A - B) <= Epsilon
  else
    Result := (B - A) <= Epsilon;
end;




function IsZero1(const A: Double; Epsilon: Double): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := DoubleResolution;
  Result := Abs(A) <= Epsilon;
end;

function IsZero2(const A: Single; Epsilon: Single): Boolean;
begin
  if Epsilon = 0 then
    Epsilon := SingleResolution;
  Result := Abs(A) <= Epsilon;
end;

function HexToInt(hexnum: string): LongInt;
begin
  result:= StrToInt64('$' + hexnum);
end;

function getPI: extended;
begin
  result:= PI;
end;


function IntToBin(Int: Integer): String; //is in IdGlobal 64bit
var
  i: integer;
begin
  Result:= '';
  for i:= 31 downto 0 do
  Result:= Result + IntToStr((Int shr i) and 1);
end;


function HexToBin2(HexNum: string): string;
begin
  Result:= IntToBin(HexToInt(HexNum));
end;


function FloatToBin(const D: Double): string;
begin
   result:= HexToBin2(DoubleToHex(D));
//   HexToBin(DoubleToHex(D));
  // Look at element 2 before element 1 because of "Little Endian" order.
  //Result := IntToHex(Overlay[2], 8) + IntToHex(Overlay[1], 8);
end;

 //function RoundTo(const AValue: Extended;
    //             const ADigit: TRoundToEXRangeExtended): Extended;

procedure RoundExError;
begin
  raise Exception.Create('SVarInvalid');
end;


function RoundTo(const AValue: Extended;
                 const ADigit: TRoundToEXRangeExtended): Extended;
type
  TFactors = array[1..2] of Extended;
const
  CW8087X : Word = 4978;
  LFactorArray : array[-20..20] of TFactors = (
    (1E-20, 1E20), (1E-19, 1E19), (1E-18, 1E18), (1E-17, 1E17), (1E-16, 1E16),
    (1E-15, 1E15), (1E-14, 1E14), (1E-13, 1E13), (1E-12, 1E12), (1E-11, 1E11),
    (1E-10, 1E10), (1E-09, 1E09), (1E-08, 1E08), (1E-07, 1E07), (1E-06, 1E06),
    (1E-05, 1E05), (1E-04, 1E04), (1E-03, 1E03), (1E-02, 1E02), (1E-01, 1E01),
    (1, 1),
    (1E01, 1E-01), (1E02, 1E-02), (1E03, 1E-03), (1E04, 1E-04), (1E05, 1E-05),
    (1E06, 1E-06), (1E07, 1E-07), (1E08, 1E-08), (1E09, 1E-09), (1E10, 1E-10),
    (1E11, 1E-11), (1E12, 1E-12), (1E13, 1E-13), (1E14, 1E-14), (1E15, 1E-15),
    (1E16, 1E-16), (1E17, 1E-17), (1E18, 1E-18), (1E19, 1E-19), (1E20, 1E-20));
asm
  movsx   eax,al
  cmp     eax, 20
  jg      RoundExError
  cmp     eax, -20
  jl      RoundExError
  sub     esp, 4
  fstcw   word ptr [esp]
  fldcw   word ptr [CW8087X]
  lea     eax, [eax+eax*4]
  lea     eax, [eax*4 + LFactorArray + 20*20]
  fld     tbyte ptr [eax]
  fld     tbyte ptr [eax+10]
  fld     AValue
  fmulp
  frndint
  fmulp
  fldcw   word ptr [esp]
  wait
  pop     eax {Restore Stack}
end;

function SimpleRoundTo(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;
var
  LFactor: Extended;
begin
  LFactor := IntPower(10, ADigit);
  if AValue < 0 then
    Result := Trunc((AValue / LFactor) - 0.5) * LFactor
  else
    Result := Trunc((AValue / LFactor) + 0.5) * LFactor;
end;


(*----------------------------------------------------------------------------*)
procedure SIRegister_MathMax(CL: TPSPascalCompiler);
begin


 CL.AddConstantN('MinSingle','Extended').setExtended( 1.5e-45);
 CL.AddConstantN('MaxSingle','Extended').setExtended( 3.4e+38);
 CL.AddConstantN('MinDouble','Extended').setExtended( 5.0e-324);
 CL.AddConstantN('MaxDouble','Extended').setExtended( 1.7e+308);
 CL.AddConstantN('MinExtended','Extended').setExtended(3.4e-4932);
 CL.AddConstantN('MaxExtended','Extended').setExtended(1.1e+4932);
 CL.AddConstantN('MinComp','Extended').setExtended(- 9.223372036854775807e+18);
 CL.AddConstantN('MaxComp','Extended').setExtended(9.223372036854775807e+18);
 CL.AddConstantN('NaN','Extended').setExtended( 0.0 / 0.0);
 CL.AddConstantN('Infinity','Extended').setExtended( 1.0 / 0.0);
 CL.AddConstantN('NegInfinity','Extended').setExtended( - 1.0 / 0.0);
 //JCLMath
  CL.AddClassN(CL.FindClass('TOBJECT'),'EJclMathError');
 // CL.AddTypeS('TFloatingPointClass', '( fpZero, fpNormal, fpDenormal, fpInfinit'
 //  +'e, fpNaN, fpInvalid, fpEmpty )');
 // JCL begin
 CL.AddConstantN('Bernstein','Extended').SetExtended( 0.2801694990238691330364364912307);
 CL.AddConstantN('Cbrt2','Extended').SetExtended( 1.2599210498948731647672106072782);
 CL.AddConstantN('Cbrt3','Extended').SetExtended( 1.4422495703074083823216383107801);
 CL.AddConstantN('Cbrt10','Extended').SetExtended( 2.1544346900318837217592935665194);
 CL.AddConstantN('Cbrt100','Extended').SetExtended( 4.6415888336127788924100763509194);
 CL.AddConstantN('CbrtPi','Extended').SetExtended( 1.4645918875615232630201425272638);
 CL.AddConstantN('Catalan','Extended').SetExtended( 0.9159655941772190150546035149324);
 CL.AddConstantN('PiJ','Extended').SetExtended( 3.1415926535897932384626433832795);
 CL.AddConstantN('PiOn2','Extended').SetExtended( 1.5707963267948966192313216916398);
 CL.AddConstantN('PiOn3','Extended').SetExtended( 1.0471975511965977461542144610932);
 CL.AddConstantN('PiOn4','Extended').SetExtended( 0.78539816339744830961566084581988);
 CL.AddConstantN('Sqrt2','Extended').SetExtended( 1.4142135623730950488016887242097);
 CL.AddConstantN('Sqrt3','Extended').SetExtended( 1.7320508075688772935274463415059);
 CL.AddConstantN('Sqrt5','Extended').SetExtended( 2.2360679774997896964091736687313);
 CL.AddConstantN('Sqrt10','Extended').SetExtended( 3.1622776601683793319988935444327);
 CL.AddConstantN('SqrtPi','Extended').SetExtended( 1.7724538509055160272981674833411);
 CL.AddConstantN('Sqrt2Pi','Extended').SetExtended( 2.506628274631000502415765284811);
 CL.AddConstantN('TwoPi','Extended').SetExtended( 6.283185307179586476925286766559);
 CL.AddConstantN('ThreePi','Extended').SetExtended( 9.4247779607693797153879301498385);
 CL.AddConstantN('Ln2','Extended').SetExtended( 0.69314718055994530941723212145818);
 CL.AddConstantN('Ln10','Extended').SetExtended( 2.3025850929940456840179914546844);
 CL.AddConstantN('LnPi','Extended').SetExtended( 1.1447298858494001741434273513531);
 CL.AddConstantN('Log2J','Extended').SetExtended( 0.30102999566398119521373889472449);
 CL.AddConstantN('Log3','Extended').SetExtended( 0.47712125471966243729502790325512);
 CL.AddConstantN('LogPi','Extended').SetExtended( 0.4971498726941338543512682882909);
 CL.AddConstantN('LogE','Extended').SetExtended( 0.43429448190325182765112891891661);
 CL.AddConstantN('Euler','Extended').SetExtended( 2.7182818284590452353602874713527);
 CL.AddConstantN('hLn2Pi','Extended').SetExtended( 0.91893853320467274178032973640562);
 CL.AddConstantN('inv2Pi','Extended').SetExtended( 0.15915494309189533576888376337251436203445964574046);
 CL.AddConstantN('TwoToPower63','Extended').SetExtended( 9223372036854775808.0);
 CL.AddConstantN('GoldenMean','Extended').SetExtended( 1.618033988749894848204586834365638);
 CL.AddConstantN('EulerMascheroni','Extended').SetExtended( 0.5772156649015328606065120900824);
 CL.AddConstantN('MaxAngle','Extended').SetExtended( 9223372036854775808.0);
 CL.AddConstantN('MaxTanH','Extended').SetExtended( 5678.2617031470719747459655389854);
 CL.AddConstantN('MaxFactorial','LongInt').SetInt( 1754);
 CL.AddConstantN('MaxFloatingPoint','Extended').SetExtended(1.189731495357231765085759326628E+4932);
 CL.AddConstantN('MinFloatingPoint','Extended').SetExtended(3.3621031431120935062626778173218E-4932);
 CL.AddConstantN('MaxTanH','Extended').SetExtended( 354.89135644669199842162284618659);
 CL.AddConstantN('MaxFactorial','LongInt').SetInt( 170);
 CL.AddConstantN('MaxFloatingPointD','Extended').SetExtended(1.797693134862315907729305190789E+308);
 CL.AddConstantN('MinFloatingPointD','Extended').SetExtended(2.2250738585072013830902327173324E-308);
 CL.AddConstantN('MaxTanH','Extended').SetExtended( 44.361419555836499802702855773323);
 CL.AddConstantN('MaxFactorial','LongInt').SetInt( 33);
 CL.AddConstantN('MaxFloatingPointS','Extended').SetExtended( 3.4028236692093846346337460743177E+38);
 CL.AddConstantN('MinFloatingPointS','Extended').SetExtended( 1.1754943508222875079687365372222E-38);
 CL.AddConstantN('PiExt','Extended').setExtended( 3.1415926535897932384626433832795);
 CL.AddConstantN('RatioDegToRad','Extended').setExtended( PiExt / 180.0);
 CL.AddConstantN('RatioGradToRad','Extended').setExtended( PiExt / 200.0);
 CL.AddConstantN('RatioDegToGrad','Extended').setExtended( 200.0 / 180.0);
 CL.AddConstantN('RatioGradToDeg','Extended').setExtended( 180.0 / 200.0);
//CL.AddConstantN('Euler','Extended').SetExtended(2.7182818284590452353602874713527);  // Natural constant

    CL.AddTypeS('TPrimalityTestMethod', '( ptTrialDivision, ptRabinMiller )');
   CL.AddTypeS('TDynCardinalArray', 'array of Cardinal');
   CL.AddTypeS('TFloatingPointClass', '( fpZero, fpNormal, fpDenormal, fpInfinit'
   +'e, fpNaN, fpInvalid, fpEmpty )');
   // CL.AddTypeS('TRoundToEXRangeExtended', '(-20..20)');
    CL.AddTypeS('TRoundToEXRangeExtended', 'INTEGER');
    CL.AddTypeS('TRoundToRange', 'INTEGER');

    //TRoundToRange

   //type TRoundToEXRangeExtended = -20..20;


 // TDynCardinalArray = array of Cardinal;
 CL.AddConstantN('Crc16PolynomCCITT','LongWord').SetUInt( $1021);
 CL.AddConstantN('Crc16PolynomIBM','LongWord').SetUInt( $8005);
 CL.AddConstantN('Crc16Bits','LongInt').SetInt( 16);
 CL.AddConstantN('Crc16Bytes','LongInt').SetInt( 2);
 CL.AddConstantN('Crc16HighBit','LongWord').SetUInt( $8000);
 CL.AddConstantN('NotCrc16HighBit','LongWord').SetUInt( $7FFF);
  CL.AddConstantN('Crc32PolynomIEEE','LongWord').SetUInt( $04C11DB7);
 CL.AddConstantN('Crc32PolynomCastagnoli','LongWord').SetUInt( $1EDC6F41);
 CL.AddConstantN('Crc32Koopman','LongWord').SetUInt( $741B8CD7);
 CL.AddConstantN('Crc32Bits','LongInt').SetInt( 32);
 CL.AddConstantN('Crc32Bytes','LongInt').SetInt( 4);
 CL.AddConstantN('Crc32HighBit','LongWord').SetUInt( $80000000);
 CL.AddConstantN('NotCrc32HighBit','LongWord').SetUInt( $7FFFFFFF);
  CL.AddTypeS('TNaNTag', 'Integer');
 //CL.AddConstantN('LowValidNaNTag','LongWord').SetUInt(-$3FFFFF);
 CL.AddConstantN('HighValidNaNTag','LongWord').SetUInt($3FFFFE);
  CL.AddTypeS('TDynDoubleArray', 'array of Double');     //of jclbase!
  CL.AddTypeS('TDynSingleArray', 'array of Single');
  CL.AddTypeS('TDynByteArray', 'array of Byte');


  CL.AddDelphiFunction('function SameValue(const A, B: Extended; Epsilon: Extended): Boolean'); //overload;
  CL.AddDelphiFunction('function SameValueE(const A, B: Extended; Epsilon: Extended): Boolean'); //overload;
 CL.AddDelphiFunction('function SameValueD(const A, B: Double; Epsilon: Double): Boolean'); //overload;
 CL.AddDelphiFunction('function SameValueS(const A, B: Single; Epsilon: Single): Boolean'); //overload;

 CL.AddDelphiFunction('function SameValue1(const A, B: Double; Epsilon: Double): Boolean'); //overload;
 CL.AddDelphiFunction('function SameValue2(const A, B: Single; Epsilon: Single): Boolean'); //overload;
 CL.AddDelphiFunction('function IsZero(const A: Extended; Epsilon: Extended): Boolean'); //overload;
 CL.AddDelphiFunction('function IsZero1(const A: Double; Epsilon: Double): Boolean'); //overload;
 CL.AddDelphiFunction('function IsZero2(const A: Single; Epsilon: Single): Boolean'); //overload;

  CL.AddDelphiFunction('function CompareValue(const A, B: Extended; Epsilon: Extended): TValueRelationship;'); //overload;
  CL.AddDelphiFunction('function CompareValueE(const A, B: Extended; Epsilon: Extended): TValueRelationship;'); //overload;
  CL.AddDelphiFunction('function CompareValueD(const A, B: Double; Epsilon: Extended): TValueRelationship;'); //overload;
  CL.AddDelphiFunction('function CompareValueS(const A, B: Single; Epsilon: Extended): TValueRelationship;'); //overload;
  CL.AddDelphiFunction('function CompareValueI(const A, B: Integer): TValueRelationship;'); //overload;
  CL.AddDelphiFunction('function CompareValueI64(const A, B: Int64): TValueRelationship;'); //overload;



 CL.AddDelphiFunction('Procedure CalcMachineEpsSingle');
 CL.AddDelphiFunction('Procedure CalcMachineEpsDouble');
 CL.AddDelphiFunction('Procedure CalcMachineEpsExtended');
 CL.AddDelphiFunction('Procedure CalcMachineEps');
 CL.AddDelphiFunction('Procedure SetPrecisionToleranceToEpsilon');
 //CL.AddDelphiFunction('Procedure SwapFloats( var X, Y : Float)');
 CL.AddDelphiFunction('Function CheckCrc32( var X : array of Byte; N : Integer; Crc : Cardinal) : Integer;');
 CL.AddDelphiFunction('Procedure SetRectComplexFormatStr( const S : string)');
 CL.AddDelphiFunction('Procedure SetPolarComplexFormatStr( const S : string)');

  CL.AddDelphiFunction('Procedure SwapOrd( var X, Y : Integer)');
 CL.AddDelphiFunction('Function DoubleToHex( const D : Double) : string');
 CL.AddDelphiFunction('Function FloatToBin( const D : Double) : string');
 CL.AddDelphiFunction('Function HexToDouble( const Hex : string) : Double');
 CL.AddDelphiFunction('Function Ackermann( const A, B : Integer) : Integer');
 CL.AddDelphiFunction('Function Ceiling( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function CommercialRound( const X : Extended) : Int64');
 CL.AddDelphiFunction('Function Factorial( const N : Integer) : Extended');
 CL.AddDelphiFunction('Function Fibonacci( const N : Integer) : Integer');
 CL.AddDelphiFunction('Function FloorJ( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function GCDJ( X, Y : Cardinal) : Cardinal');
 CL.AddDelphiFunction('Function ISqrt( const I : Smallint) : Smallint');
 CL.AddDelphiFunction('Function LCMJ( const X, Y : Cardinal) : Cardinal');
 CL.AddDelphiFunction('Function NormalizeAngle( const Angle : Extended) : Extended');
 CL.AddDelphiFunction('Function Pythagoras( const X, Y : Extended) : Extended');
 CL.AddDelphiFunction('Function Sgn( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function Sign( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function Signe( const X, Y : Extended) : Extended');
 CL.AddDelphiFunction('Function DegToRadE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function DegToRad1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function DegToRad2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastDegToRad');
 CL.AddDelphiFunction('Function RadToDegE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function RadToDeg1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function RadToDeg2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastRadToDeg');
 CL.AddDelphiFunction('Function GradToRadE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function GradToRad1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function GradToRad2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastGradToRad');
 CL.AddDelphiFunction('Function RadToGradE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function RadToGrad1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function RadToGrad2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastRadToGrad');
 CL.AddDelphiFunction('Function DegToGradE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function DegToGrad1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function DegToGrad2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastDegToGrad');
 CL.AddDelphiFunction('Function GradToDegE( const Value : Extended) : Extended;');
 CL.AddDelphiFunction('Function GradToDeg1( const Value : Double) : Double;');
 CL.AddDelphiFunction('Function GradToDeg2( const Value : Single) : Single;');
 CL.AddDelphiFunction('Procedure FastGradToDeg');

 CL.AddDelphiFunction('Function CotH( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function SecH( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function CscH( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCot( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSec( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCsc( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCotH( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSecH( const X : Extended) : Extended');
 //3.9 points to mathmax
 CL.AddDelphiFunction('Function ArcCot1( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSec1( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCsc1( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCotH1( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSecH1( const X : Extended) : Extended');

  CL.AddTypeS('Float', 'Extended');
  //Float =  Extended;  //mX 3.9

 CL.AddDelphiFunction('function LogBase10(X: Extended): Extended;');
 CL.AddDelphiFunction('Function LogBase2(X: Float): Float;');
 CL.AddDelphiFunction('Function LogBaseN(Base, X: Float): Float;');

 CL.AddDelphiFunction('Function LogBaseN(Base, X: Float): Float;');
 CL.AddDelphiFunction('Function getLAT_CONV_FACTOR: double;');
 CL.AddDelphiFunction('Function Latitude2WGS84(lat: double): double;');

 CL.AddDelphiFunction('Function Coversine( X : Float) : Float');
 CL.AddDelphiFunction('Function CscJ( X : Float) : Float');
 CL.AddDelphiFunction('Function Exsecans( X : Float) : Float');
 CL.AddDelphiFunction('Function Haversine( X : Float) : Float');
 CL.AddDelphiFunction('Function SecJ( X : Float) : Float');
 CL.AddDelphiFunction('Function SinJ( X : Float) : Float');
 CL.AddDelphiFunction('Function CosJ( X : Float) : Float');
 CL.AddDelphiFunction('Function CotJ( X : Float) : Float');

 CL.AddDelphiFunction('Procedure SinCosD( X : Double; out Sin, Cos : Double)');
 CL.AddDelphiFunction('Procedure SinCosE( X : Extended; out Sin, Cos : Extended)');
 CL.AddDelphiFunction('Procedure SinCosJ( X : Extended; out Sin, Cos : Extended)');
 CL.AddDelphiFunction('Function TanJ( X : Float) : Float');
 CL.AddDelphiFunction('Function Versine( X : Float) : Float');
 CL.AddDelphiFunction('Function DegMinSecToFloat( const Degs, Mins, Secs : Float) : Float');
 CL.AddDelphiFunction('Procedure FloatToDegMinSec( const X : Float; var Degs, Mins, Secs : Float)');
 CL.AddDelphiFunction('Function ExpJ( const X : Float) : Float;');
 CL.AddDelphiFunction('Function PowerJ( const Base, Exponent : Float) : Float;');
 CL.AddDelphiFunction('Function PowerIntJ( const X : Float; N : Integer) : Float;');
 CL.AddDelphiFunction('Function TenToY( const Y : Float) : Float');
 CL.AddDelphiFunction('Function TruncPower( const Base, Exponent : Float) : Float');
 CL.AddDelphiFunction('Function TwoToY( const Y : Float) : Float');
 CL.AddDelphiFunction('Function IsFloatZero( const X : Float) : Boolean');
 CL.AddDelphiFunction('Function FloatsEqual( const X, Y : Float) : Boolean');
 CL.AddDelphiFunction('Function MaxFloat( const X, Y : Float) : Float');
 CL.AddDelphiFunction('Function MinFloat( const X, Y : Float) : Float');
 CL.AddDelphiFunction('Function ModFloat( const X, Y : Float) : Float');
 CL.AddDelphiFunction('Function RemainderFloat( const X, Y : Float) : Float');
 CL.AddDelphiFunction('Function SetPrecisionTolerance( NewTolerance : Float) : Float');
 CL.AddDelphiFunction('Procedure SwapFloats( var X, Y : Float)');
 CL.AddDelphiFunction('Function EnsureRange( const AValue, AMin, AMax : Integer) : Integer;');
 CL.AddDelphiFunction('Function EnsureRange1( const AValue, AMin, AMax : Int64) : Int64;');
 CL.AddDelphiFunction('Function EnsureRange2( const AValue, AMin, AMax : Double) : Double;');
 CL.AddDelphiFunction('Function IsRelativePrime( const X, Y : Cardinal) : Boolean');
 CL.AddDelphiFunction('Function IsPrimeTD( N : Cardinal) : Boolean');
 CL.AddDelphiFunction('Function IsPrimeRM( N : Cardinal) : Boolean');
 CL.AddDelphiFunction('Function IsPrimeFactor( const F, N : Cardinal) : Boolean');
 CL.AddDelphiFunction('Function PrimeFactors( N : Cardinal) : TDynCardinalArray');
 CL.AddDelphiFunction('Procedure SetPrimalityTest( const Method : TPrimalityTestMethod)');
  CL.AddTypeS('TFloatingPointClass', '( fpZero, fpNormal, fpDenormal, fpInfinit'
   +'e, fpNaN, fpInvalid, fpEmpty )');
 CL.AddDelphiFunction('Function CosH( const Z : Float) : Float;');
 CL.AddDelphiFunction('Function SinH( const Z : Float) : Float;');
 CL.AddDelphiFunction('Function TanH( const Z : Float) : Float;');
  CL.AddDelphiFunction('Function IsInfinite1( const Value : Double) : Boolean;');
 CL.AddDelphiFunction('Function IsInfinite2( const Value : Extended) : Boolean;');
 CL.AddDelphiFunction('Function IsNaN( const Value : Single) : Boolean;');
 CL.AddDelphiFunction('Function IsNaN1( const Value : Double) : Boolean;');
 CL.AddDelphiFunction('Function IsNaN2( const Value : Extended) : Boolean;');
 CL.AddDelphiFunction('Function IsSpecialValue( const X : Float) : Boolean');
 CL.AddDelphiFunction('Procedure MakeQuietNaN( var X : Single; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MakeQuietNaN1( var X : Double; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MakeQuietNaN2( var X : Extended; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MakeSignalingNaN( var X : Single; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MakeSignalingNaN1( var X : Double; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MakeSignalingNaN2( var X : Extended; Tag : TNaNTag);');
 CL.AddDelphiFunction('Procedure MineSingleBuffer( var Buffer, Count : Integer; StartTag : TNaNTag)');
 CL.AddDelphiFunction('Procedure MineDoubleBuffer( var Buffer, Count : Integer; StartTag : TNaNTag)');
 CL.AddDelphiFunction('Function MinedSingleArray( Length : Integer) : TDynSingleArray');
 CL.AddDelphiFunction('Function MinedDoubleArray( Length : Integer) : TDynDoubleArray');
 CL.AddDelphiFunction('Function GetNaNTag( const NaN : Single) : TNaNTag;');
 CL.AddDelphiFunction('Function GetNaNTag1( const NaN : Double) : TNaNTag;');
 CL.AddDelphiFunction('Function GetNaNTag2( const NaN : Extended) : TNaNTag;');
 CL.AddDelphiFunction('Procedure DomainCheck( Err : Boolean)');
 CL.AddDelphiFunction('Function GetParity( Buffer : TDynByteArray; Len : Integer) : Boolean;');
 CL.AddDelphiFunction('Function FloatingPointClass( const Value : Single) : TFloatingPointClass;');
 CL.AddDelphiFunction('Function FloatingPointClass1( const Value : Double) : TFloatingPointClass;');
 CL.AddDelphiFunction('Function FloatingPointClass2( const Value : Extended) : TFloatingPointClass;');


 // JCL end
 // borland math
  CL.AddDelphiFunction('Function ArcCos( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSin( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcTan2( const Y, X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcTan( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcTan3( const X : Extended) : Extended');

 CL.AddDelphiFunction('Procedure SinCos( const Theta : Extended; var Sin, Cos : Extended)');
 CL.AddDelphiFunction('Function Tan( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Cotan( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Secant( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Cosecant( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Hypot( const X, Y : Extended) : Extended');
 CL.AddDelphiFunction('Function RadToDeg( const Radians : Extended) : Extended');
 CL.AddDelphiFunction('Function RadToGrad( const Radians : Extended) : Extended');
 CL.AddDelphiFunction('Function RadToCycle( const Radians : Extended) : Extended');
 CL.AddDelphiFunction('Function DegToRad( const Degrees : Extended) : Extended');
 CL.AddDelphiFunction('Function DegToGrad( const Degrees : Extended) : Extended');
 CL.AddDelphiFunction('Function DegToCycle( const Degrees : Extended) : Extended');
 CL.AddDelphiFunction('Function GradToRad( const Grads : Extended) : Extended');
 CL.AddDelphiFunction('Function GradToDeg( const Grads : Extended) : Extended');
 CL.AddDelphiFunction('Function GradToCycle( const Grads : Extended) : Extended');
 CL.AddDelphiFunction('Function CycleToRad( const Cycles : Extended) : Extended');
 CL.AddDelphiFunction('Function CycleToDeg( const Cycles : Extended) : Extended');
 CL.AddDelphiFunction('Function CycleToGrad( const Cycles : Extended) : Extended');
 CL.AddDelphiFunction('Function Cot( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Sec( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Csc( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCosh( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcSinh( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function ArcCscH( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function LnXP1( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Log10( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Log( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function Log2( const X : Extended) : Extended');
 CL.AddDelphiFunction('Function LogN( const Base, X : Extended) : Extended');
 CL.AddDelphiFunction('Function IntPower( const Base : Extended; const Exponent : Integer) : Extended');
 CL.AddDelphiFunction('Function Power( const Base, Exponent : Extended) : Extended');
 CL.AddDelphiFunction('Function Pow( const Base, Exponent : Extended) : Extended');
 CL.AddDelphiFunction('Procedure Frexp( const X : Extended; var Mantissa : Extended; var Exponent : Integer)');
 CL.AddDelphiFunction('Function Ldexp( const X : Extended; const P : Integer) : Extended');
 CL.AddDelphiFunction('Function Ceil( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function Floor( const X : Extended) : Integer');
 CL.AddDelphiFunction('Function Poly( const X : Extended; const Coefficients : array of Double) : Extended');
 CL.AddDelphiFunction('Function Mean( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function Sum( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function SumInt( const Data : array of Integer) : Integer');
 CL.AddDelphiFunction('Function SumOfSquares( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Procedure SumsAndSquares( const Data : array of Double; var Sum, SumOfSquares : Extended)');
 CL.AddDelphiFunction('Function MinValue( const Data : array of Double) : Double');
 CL.AddDelphiFunction('Function MinIntValue( const Data : array of Integer) : Integer');
 CL.AddDelphiFunction('Function StdDev( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Procedure MeanAndStdDev( const Data : array of Double; var Mean, StdDev : Extended)');
 CL.AddDelphiFunction('Function PopnStdDev( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function Variance( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function PopnVariance( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function TotalVariance( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Function Norm( const Data : array of Double) : Extended');
 CL.AddDelphiFunction('Procedure MomentSkewKurtosis( const Data : array of Double; var M1, M2, M3, M4, Skew, Kurtosis : Extended)');
 CL.AddDelphiFunction('Function RandG( Mean, StdDev : Extended) : Extended');
 CL.AddDelphiFunction('Function IsInfinite( const AValue : Double) : Boolean');
 CL.AddDelphiFunction('Function RandomRange( const AFrom, ATo : Integer) : Integer');
 CL.AddDelphiFunction('Procedure DivMod( Dividend : Integer; Divisor : Word; var Result, Remainder : Word)');
  CL.AddTypeS('TPaymentTime', '( ptEndOfPeriod, ptStartOfPeriod )');
 CL.AddDelphiFunction('Function DoubleDecliningBalance( const Cost, Salvage : Extended; Life, Period : Integer) : Extended');
 CL.AddDelphiFunction('Function FutureValue( const Rate : Extended; NPeriods : Integer; const Payment, PresentValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function InterestPayment( const Rate : Extended; Period, NPeriods : Integer; const PresentValue, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function InterestRate( NPeriods : Integer; const Payment, PresentValue, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function InternalRateOfReturn( const Guess : Extended; const CashFlows : array of Double) : Extended');
 CL.AddDelphiFunction('Function NumberOfPeriods( const Rate : Extended; Payment : Extended; const PresentValue, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function NetPresentValue( const Rate : Extended; const CashFlows : array of Double; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function Payment( Rate : Extended; NPeriods : Integer; const PresentValue, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function PeriodPayment( const Rate : Extended; Period, NPeriods : Integer; const PresentValue, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function PresentValue( const Rate : Extended; NPeriods : Integer; const Payment, FutureValue : Extended; PaymentTime : TPaymentTime) : Extended');
 CL.AddDelphiFunction('Function SLNDepreciation( const Cost, Salvage : Extended; Life : Integer) : Extended');
 CL.AddDelphiFunction('Function SYDDepreciation( const Cost, Salvage : Extended; Life, Period : Integer) : Extended');
 CL.AddDelphiFunction('Function FactInt(numb: integer): int64;');
 CL.AddDelphiFunction('Function Fact(numb: integer): Extended;');
 CL.AddDelphiFunction('Function Fibo(numb: integer): Extended;');
 CL.AddDelphiFunction('Function FiboInt(numb: integer): Int64;');
 CL.AddDelphiFunction('Procedure FillChar2(var X: PChar ; count: integer; value: char)');
 CL.AddDelphiFunction('Procedure FillByte2(var X: Byte ; count: integer; value: byte)');
 CL.AddDelphiFunction('Function IntToStr64(Value: Int64): string)');
 CL.AddDelphiFunction('function IntToHex64(Value: Int64; Digits: Integer): string)');

 CL.AddDelphiFunction('function MaxIntValue(const Data: array of Integer):Integer)');
 CL.AddDelphiFunction('function MaxValue(const Data: array of Double): Double)');
 CL.AddDelphiFunction('function MinIntValue(const Data: array of Integer):Integer)');
 CL.AddDelphiFunction('function MinValue(const Data: array of Double): Double)');
 CL.AddDelphiFunction('Function Round64(e: extended): Int64;');
 CL.AddDelphiFunction('Function Trunc64(e: extended): Int64;');
 CL.AddDelphiFunction('function getPI: extended;');

   CL.AddDelphiFunction('function RoundTo(const AValue: Extended; const ADigit: TRoundToEXRangeExtended): Extended;');
 CL.AddDelphiFunction('function SimpleRoundTo(const AValue: Extended; const ADigit: TRoundToRange): Extended;');


{ This variation of the RoundTo function follows the asymmetric arithmetic
  rounding algorithm (if Frac(X) < .5 then return X else return X + 1).  This
  function defaults to rounding to the hundredth's place (cents). }
//function SimpleRoundTo(const AValue: Extended; const ADigit: TRoundToRange = -2): Extended;


  SIRegister_EInvalidArgument(CL);
end;

(* === run-time registration functions === *)


(*----------------------------------------------------------------------------*)
Function RadToDeg2_P( const Value : Single) : Single;
Begin Result := JclMath_max.RadToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function RadToDeg1_P( const Value : Double) : Double;
Begin Result := JclMath_max.RadToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function RadToDeg_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.RadToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToRad2_P( const Value : Single) : Single;
Begin Result := JclMath_max.DegToRad(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToRad1_P( const Value : Double) : Double;
Begin Result := JclMath_max.DegToRad(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToRad_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.DegToRad(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToDeg2_P( const Value : Single) : Single;
Begin Result := JclMath_max.GradToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToDeg1_P( const Value : Double) : Double;
Begin Result := JclMath_max.GradToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToDeg_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.GradToDeg(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToGrad2_P( const Value : Single) : Single;
Begin Result := JclMath_max.DegToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToGrad1_P( const Value : Double) : Double;
Begin Result := JclMath_max.DegToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function DegToGrad_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.DegToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function RadToGrad2_P( const Value : Single) : Single;
Begin Result := JclMath_max.RadToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function RadToGrad1_P( const Value : Double) : Double;
Begin Result := JclMath_max.RadToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function RadToGrad_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.RadToGrad(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToRad2_P( const Value : Single) : Single;
Begin Result := JclMath_max.GradToRad(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToRad1_P( const Value : Double) : Double;
Begin Result := JclMath_max.GradToRad(Value); END;

(*----------------------------------------------------------------------------*)
Function GradToRad_P( const Value : Extended) : Extended;
Begin Result := JclMath_max.GradToRad(Value); END;

Function Round64(e: extended): Int64;
Begin Result:= Round(e); END;

Function Trunc64(e: extended): Int64;
Begin Result:= Trunc(e); END;

(*----------------------------------------------------------------------------*)
Function EnsureRange2_P( const AValue, AMin, AMax : Double) : Double;
Begin Result := JclMath_max.EnsureRange(AValue, AMin, AMax); END;

(*----------------------------------------------------------------------------*)
Function EnsureRange1_P( const AValue, AMin, AMax : Int64) : Int64;
Begin Result := JclMath_max.EnsureRange(AValue, AMin, AMax); END;


Function CompareValueE(const A, B: Extended; Epsilon: Extended) : TValueRelationship;
Begin Result:= mathmax.CompareValue(A,B,Epsilon); END;

Function CompareValueD(const A, B: Double; Epsilon: Extended) : TValueRelationship;
Begin Result:= mathmax.CompareValue(A,B,Epsilon); END;

Function CompareValueS(const A, B: Single; Epsilon: Extended) : TValueRelationship;
Begin Result:= mathmax.CompareValue(A,B,Epsilon); END;

Function CompareValueI(const A, B: Integer) : TValueRelationship;
Begin Result:= mathmax.CompareValue(A,B); END;

Function CompareValueI64(const A, B: Int64) : TValueRelationship;
Begin Result:= mathmax.CompareValue(A,B); END;


{function CompareValue(const A, B: Extended; Epsilon: Extended = 0): TValueRelationship; overload;
function CompareValue(const A, B: Double; Epsilon: Double = 0): TValueRelationship; overload;
function CompareValue(const A, B: Single; Epsilon: Single = 0): TValueRelationship; overload;
function CompareValue(const A, B: Integer): TValueRelationship; overload;
function CompareValue(const A, B: Int64): TValueRelationship; overload;}


(*----------------------------------------------------------------------------*)
procedure RIRegister_EInvalidArgument(CL: TPSRuntimeClassImporter);
begin
  with CL.Add(EInvalidArgument) do
  begin
    //round(4.6)
  end;
end;

(*----------------------------------------------------------------------------*)
Function FloatingPointClass2_P( const Value : Extended) : TFloatingPointClass;
Begin Result := JclMath_max.FloatingPointClass(Value); END;

(*----------------------------------------------------------------------------*)
Function FloatingPointClass1_P( const Value : Double) : TFloatingPointClass;
Begin Result := JclMath_max.FloatingPointClass(Value); END;

(*----------------------------------------------------------------------------*)
Function FloatingPointClass_P( const Value : Single) : TFloatingPointClass;
Begin Result := JclMath_max.FloatingPointClass(Value); END;



(*----------------------------------------------------------------------------*)
Function GetNaNTag2_P( const NaN : Extended) : TNaNTag;
Begin Result := JclMath_max.GetNaNTag(NaN); END;

(*----------------------------------------------------------------------------*)
Function GetNaNTag1_P( const NaN : Double) : TNaNTag;
Begin Result := JclMath_max.GetNaNTag(NaN); END;

(*----------------------------------------------------------------------------*)
Function GetNaNTag_P( const NaN : Single) : TNaNTag;
Begin Result := JclMath_max.GetNaNTag(NaN); END;

(*----------------------------------------------------------------------------*)
Procedure MakeSignalingNaN2_P( var X : Extended; Tag : TNaNTag);
Begin JclMath_max.MakeSignalingNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Procedure MakeSignalingNaN1_P( var X : Double; Tag : TNaNTag);
Begin JclMath_max.MakeSignalingNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Procedure MakeSignalingNaN_P( var X : Single; Tag : TNaNTag);
Begin JclMath_max.MakeSignalingNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Procedure MakeQuietNaN2_P( var X : Extended; Tag : TNaNTag);
Begin JclMath_max.MakeQuietNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Procedure MakeQuietNaN1_P( var X : Double; Tag : TNaNTag);
Begin JclMath_max.MakeQuietNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Procedure MakeQuietNaN_P( var X : Single; Tag : TNaNTag);
Begin JclMath_max.MakeQuietNaN(X, Tag); END;

(*----------------------------------------------------------------------------*)
Function IsNaN2_P( const Value : Extended) : Boolean;
Begin Result := JclMath_max.IsNaN(Value); END;

(*----------------------------------------------------------------------------*)
Function IsNaN1_P( const Value : Double) : Boolean;
Begin Result := JclMath_max.IsNaN(Value); END;

(*----------------------------------------------------------------------------*)
Function IsNaN_P( const Value : Single) : Boolean;
Begin Result := JclMath_max.IsNaN(Value); END;

(*----------------------------------------------------------------------------*)
Function IsInfinite2_P( const Value : Extended) : Boolean;
Begin Result := JclMath_max.IsInfinite(Value); END;

(*----------------------------------------------------------------------------*)
Function IsInfinite1_P( const Value : Double) : Boolean;
Begin Result := JclMath_max.IsInfinite(Value); END;

(*----------------------------------------------------------------------------*)
Function IsInfinite_P( const Value : Single) : Boolean;
Begin Result := JclMath_max.IsInfinite(Value); END;



(*----------------------------------------------------------------------------*)
procedure RIRegister_MathMax_Routines(S: TPSExec);
begin
 S.RegisterDelphiFunction(@mathmax.ArcCos, 'ArcCos', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcSin, 'ArcSin', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcTan2, 'ArcTan2', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcTan3, 'ArcTan3', cdRegister);

 S.RegisterDelphiFunction(@mathmax.ArcTan, 'ArcTan', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SinCos, 'SinCos', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Tan, 'Tan', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Cotan, 'Cotan', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Secant, 'Secant', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Cosecant, 'Cosecant', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Hypot, 'Hypot', cdRegister);
 S.RegisterDelphiFunction(@mathmax.RadToDeg, 'RadToDeg', cdRegister);
 S.RegisterDelphiFunction(@mathmax.RadToGrad, 'RadToGrad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.RadToCycle, 'RadToCycle', cdRegister);
 S.RegisterDelphiFunction(@mathmax.DegToRad, 'DegToRad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.DegToGrad, 'DegToGrad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.DegToCycle, 'DegToCycle', cdRegister);
 S.RegisterDelphiFunction(@mathmax.GradToRad, 'GradToRad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.GradToDeg, 'GradToDeg', cdRegister);
 S.RegisterDelphiFunction(@mathmax.GradToCycle, 'GradToCycle', cdRegister);
 S.RegisterDelphiFunction(@mathmax.CycleToRad, 'CycleToRad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.CycleToDeg, 'CycleToDeg', cdRegister);
 S.RegisterDelphiFunction(@mathmax.CycleToGrad, 'CycleToGrad', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Cot, 'Cot', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Sec, 'Sec', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Csc, 'Csc', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcCosh, 'ArcCosh', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcSinh, 'ArcSinh', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcCscH, 'ArcCscH', cdRegister);
 S.RegisterDelphiFunction(@mathmax.LnXP1, 'LnXP1', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Log10, 'Log10', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Log2, 'Log2', cdRegister);
 S.RegisterDelphiFunction(@mathmax.LogN, 'LogN', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Log10, 'Log', cdRegister);  //alias to
 S.RegisterDelphiFunction(@mathmax.IntPower, 'IntPower', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Power, 'Power', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Power, 'Pow', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Frexp, 'Frexp', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Ldexp, 'Ldexp', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Ceil, 'Ceil', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Floor, 'Floor', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Poly, 'Poly', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Mean, 'Mean', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Sum, 'Sum', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SumInt, 'SumInt', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SumOfSquares, 'SumOfSquares', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SumsAndSquares, 'SumsAndSquares', cdRegister);
 S.RegisterDelphiFunction(@mathmax.MinValue, 'MinValue', cdRegister);
 S.RegisterDelphiFunction(@mathmax.MinIntValue, 'MinIntValue', cdRegister);
 S.RegisterDelphiFunction(@mathmax.StdDev, 'StdDev', cdRegister);
 S.RegisterDelphiFunction(@mathmax.MeanAndStdDev, 'MeanAndStdDev', cdRegister);
 S.RegisterDelphiFunction(@mathmax.PopnStdDev, 'PopnStdDev', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Variance, 'Variance', cdRegister);
 S.RegisterDelphiFunction(@mathmax.PopnVariance, 'PopnVariance', cdRegister);
 S.RegisterDelphiFunction(@mathmax.TotalVariance, 'TotalVariance', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Norm, 'Norm', cdRegister);
 S.RegisterDelphiFunction(@mathmax.MomentSkewKurtosis, 'MomentSkewKurtosis', cdRegister);
 S.RegisterDelphiFunction(@mathmax.RandG, 'RandG', cdRegister);
 S.RegisterDelphiFunction(@mathmax.IsInfinite, 'IsInfinite', cdRegister);
 S.RegisterDelphiFunction(@mathmax.RandomRange, 'RandomRange', cdRegister);
 S.RegisterDelphiFunction(@mathmax.DivMod, 'DivMod', cdRegister);
 S.RegisterDelphiFunction(@mathmax.DoubleDecliningBalance, 'DoubleDecliningBalance', cdRegister);
 S.RegisterDelphiFunction(@mathmax.FutureValue, 'FutureValue', cdRegister);
 S.RegisterDelphiFunction(@mathmax.InterestPayment, 'InterestPayment', cdRegister);
 S.RegisterDelphiFunction(@mathmax.InterestRate, 'InterestRate', cdRegister);
 S.RegisterDelphiFunction(@mathmax.InternalRateOfReturn, 'InternalRateOfReturn', cdRegister);
 S.RegisterDelphiFunction(@mathmax.NumberOfPeriods, 'NumberOfPeriods', cdRegister);
 S.RegisterDelphiFunction(@mathmax.NetPresentValue, 'NetPresentValue', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Payment, 'Payment', cdRegister);
 S.RegisterDelphiFunction(@mathmax.PeriodPayment, 'PeriodPayment', cdRegister);
 S.RegisterDelphiFunction(@mathmax.PresentValue, 'PresentValue', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SLNDepreciation, 'SLNDepreciation', cdRegister);
 S.RegisterDelphiFunction(@mathmax.SYDDepreciation, 'SYDDepreciation', cdRegister);
 S.RegisterDelphiFunction(@mathmax.FactInt, 'FactInt', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Fact, 'Fact', cdRegister);
 S.RegisterDelphiFunction(@mathmax.Fibo, 'Fibo', cdRegister);
 S.RegisterDelphiFunction(@mathmax.FiboInt, 'FiboInt', cdRegister);
 S.RegisterDelphiFunction(@mathmax.FillChar2, 'FillChar2', cdRegister);
 S.RegisterDelphiFunction(@mathmax.FillByte2, 'FillByte2', cdRegister);
 S.RegisterDelphiFunction(@mathmax.IntToStr64, 'IntToStr64', cdRegister); //overload
 S.RegisterDelphiFunction(@mathmax.IntToHex64, 'IntToHex64', cdRegister); //overload
 S.RegisterDelphiFunction(@mathmax.getLAT_CONV_FACTOR, 'getLAT_CONV_FACTOR', cdRegister); //overload
 S.RegisterDelphiFunction(@mathmax.Latitude2WGS84, 'Latitude2WGS84', cdRegister); //overload
 S.RegisterDelphiFunction(@mathmax.ArcCot, 'ArcCot1', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcSec, 'ArcSec1', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcCsc, 'ArcCsc1', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcCotH, 'ArcCotH1', cdRegister);
 S.RegisterDelphiFunction(@mathmax.ArcSecH, 'ArcSecH1', cdRegister);
 //mX3.9
 S.RegisterDelphiFunction(@mathmax.SameValue, 'SameValue', cdRegister);
 S.RegisterDelphiFunction(@SameValueE, 'SameValueE', cdRegister);
 S.RegisterDelphiFunction(@SameValue1, 'SameValueD', cdRegister);
 S.RegisterDelphiFunction(@SameValue2, 'SameValueS', cdRegister);

 S.RegisterDelphiFunction(@SameValue1, 'SameValue1', cdRegister);
 S.RegisterDelphiFunction(@SameValue2, 'SameValue2', cdRegister);
 S.RegisterDelphiFunction(@mathmax.IsZero, 'IsZero', cdRegister);
 S.RegisterDelphiFunction(@IsZero1, 'IsZero1', cdRegister);
 S.RegisterDelphiFunction(@IsZero2, 'IsZero2', cdRegister);

  //JCLMath
 S.RegisterDelphiFunction(@CotH, 'CotH', cdRegister);
 S.RegisterDelphiFunction(@SecH, 'SecH', cdRegister);
 S.RegisterDelphiFunction(@CscH, 'CscH', cdRegister);
 S.RegisterDelphiFunction(@ArcCot, 'ArcCot', cdRegister);
 S.RegisterDelphiFunction(@ArcSec, 'ArcSec', cdRegister);
 S.RegisterDelphiFunction(@ArcCsc, 'ArcCsc', cdRegister);
 S.RegisterDelphiFunction(@ArcCotH, 'ArcCotH', cdRegister);
 S.RegisterDelphiFunction(@ArcSecH, 'ArcSecH', cdRegister);

 S.RegisterDelphiFunction(@LogBase10, 'LogBase10', cdRegister);
 S.RegisterDelphiFunction(@LogBase2, 'LogBase2', cdRegister);
 S.RegisterDelphiFunction(@LogBaseN, 'LogBaseN', cdRegister);

 S.RegisterDelphiFunction(@SwapOrd, 'SwapOrd', cdRegister);
 S.RegisterDelphiFunction(@DoubleToHex, 'DoubleToHex', cdRegister);
 S.RegisterDelphiFunction(@HexToDouble, 'HexToDouble', cdRegister);
 S.RegisterDelphiFunction(@FloatToBin, 'FloatToBin', cdRegister);
 S.RegisterDelphiFunction(@Ackermann, 'Ackermann', cdRegister);
 S.RegisterDelphiFunction(@Ceiling, 'Ceiling', cdRegister);
 S.RegisterDelphiFunction(@CommercialRound, 'CommercialRound', cdRegister);
 S.RegisterDelphiFunction(@Factorial, 'Factorial', cdRegister);
 S.RegisterDelphiFunction(@Fibonacci, 'Fibonacci', cdRegister);
 S.RegisterDelphiFunction(@FloorJ, 'FloorJ', cdRegister);
 S.RegisterDelphiFunction(@GCD, 'GCDJ', cdRegister);
 S.RegisterDelphiFunction(@ISqrt, 'ISqrt', cdRegister);
 S.RegisterDelphiFunction(@LCM, 'LCMJ', cdRegister);
 S.RegisterDelphiFunction(@NormalizeAngle, 'NormalizeAngle', cdRegister);
 S.RegisterDelphiFunction(@Pythagoras, 'Pythagoras', cdRegister);
 S.RegisterDelphiFunction(@Sgn, 'Sgn', cdRegister);
 S.RegisterDelphiFunction(@Sgn, 'Sign', cdRegister);
 S.RegisterDelphiFunction(@Signe, 'Signe', cdRegister);
 S.RegisterDelphiFunction(@Round64, 'Round64', cdRegister);
 S.RegisterDelphiFunction(@Trunc64, 'Trunc64', cdRegister);


 S.RegisterDelphiFunction(@DegToRad_P, 'DegToRadE', cdRegister);
 S.RegisterDelphiFunction(@DegToRad1_P, 'DegToRad1', cdRegister);
 S.RegisterDelphiFunction(@DegToRad2_P, 'DegToRad2', cdRegister);
 S.RegisterDelphiFunction(@FastDegToRad, 'FastDegToRad', cdRegister);
 S.RegisterDelphiFunction(@RadToDeg_P, 'RadToDegE', cdRegister);
 S.RegisterDelphiFunction(@RadToDeg1_P, 'RadToDeg1', cdRegister);
 S.RegisterDelphiFunction(@RadToDeg2_P, 'RadToDeg2', cdRegister);
 S.RegisterDelphiFunction(@FastRadToDeg, 'FastRadToDeg', cdRegister);
 S.RegisterDelphiFunction(@GradToRad_P, 'GradToRadE', cdRegister);
 S.RegisterDelphiFunction(@GradToRad1_P, 'GradToRad1', cdRegister);
 S.RegisterDelphiFunction(@GradToRad2_P, 'GradToRad2', cdRegister);
 S.RegisterDelphiFunction(@FastGradToRad, 'FastGradToRad', cdRegister);
 S.RegisterDelphiFunction(@RadToGrad_P, 'RadToGradE', cdRegister);
 S.RegisterDelphiFunction(@RadToGrad1_P, 'RadToGrad1', cdRegister);
 S.RegisterDelphiFunction(@RadToGrad2_P, 'RadToGrad2', cdRegister);
 S.RegisterDelphiFunction(@FastRadToGrad, 'FastRadToGrad', cdRegister);
 S.RegisterDelphiFunction(@DegToGrad_P, 'DegToGradE', cdRegister);
 S.RegisterDelphiFunction(@DegToGrad1_P, 'DegToGrad1', cdRegister);
 S.RegisterDelphiFunction(@DegToGrad2_P, 'DegToGrad2', cdRegister);
 S.RegisterDelphiFunction(@FastDegToGrad, 'FastDegToGrad', cdRegister);
 S.RegisterDelphiFunction(@GradToDeg_P, 'GradToDegE', cdRegister);
 S.RegisterDelphiFunction(@GradToDeg1_P, 'GradToDeg1', cdRegister);
 S.RegisterDelphiFunction(@GradToDeg2_P, 'GradToDeg2', cdRegister);
 S.RegisterDelphiFunction(@FastGradToDeg, 'FastGradToDeg', cdRegister);


 S.RegisterDelphiFunction(@Coversine, 'Coversine', cdRegister);
 S.RegisterDelphiFunction(@Csc, 'CscJ', cdRegister);
 S.RegisterDelphiFunction(@Exsecans, 'Exsecans', cdRegister);
 S.RegisterDelphiFunction(@Haversine, 'Haversine', cdRegister);
 S.RegisterDelphiFunction(@Sec, 'SecJ', cdRegister);
 S.RegisterDelphiFunction(@Sin, 'SinJ', cdRegister);
 S.RegisterDelphiFunction(@Cos, 'CosJ', cdRegister);
 S.RegisterDelphiFunction(@Cot, 'CotJ', cdRegister);
 S.RegisterDelphiFunction(@CosH, 'CosH', cdRegister);
 S.RegisterDelphiFunction(@SinH, 'SinH', cdRegister);
 S.RegisterDelphiFunction(@TanH, 'TanH', cdRegister);
 S.RegisterDelphiFunction(@IsInfinite, 'IsInfinite1', cdRegister);
 S.RegisterDelphiFunction(@IsInfinite, 'IsInfinite2', cdRegister);
 S.RegisterDelphiFunction(@IsNaN_P, 'IsNaN', cdRegister);
 S.RegisterDelphiFunction(@IsNaN1_P, 'IsNaN1', cdRegister);
 S.RegisterDelphiFunction(@IsNaN2_P, 'IsNaN2', cdRegister);
 S.RegisterDelphiFunction(@IsSpecialValue, 'IsSpecialValue', cdRegister);
 S.RegisterDelphiFunction(@MakeQuietNaN_P, 'MakeQuietNaN', cdRegister);
 S.RegisterDelphiFunction(@MakeQuietNaN1_P, 'MakeQuietNaN1', cdRegister);
 S.RegisterDelphiFunction(@MakeQuietNaN2_P, 'MakeQuietNaN2', cdRegister);
 S.RegisterDelphiFunction(@MakeSignalingNaN_P, 'MakeSignalingNaN', cdRegister);
 S.RegisterDelphiFunction(@MakeSignalingNaN1_P, 'MakeSignalingNaN1', cdRegister);
 S.RegisterDelphiFunction(@MakeSignalingNaN2_P, 'MakeSignalingNaN2', cdRegister);
 S.RegisterDelphiFunction(@MineSingleBuffer, 'MineSingleBuffer', cdRegister);
 S.RegisterDelphiFunction(@MineDoubleBuffer, 'MineDoubleBuffer', cdRegister);
 S.RegisterDelphiFunction(@MinedSingleArray, 'MinedSingleArray', cdRegister);
 S.RegisterDelphiFunction(@MinedDoubleArray, 'MinedDoubleArray', cdRegister);
 S.RegisterDelphiFunction(@GetNaNTag_P, 'GetNaNTag', cdRegister);
 S.RegisterDelphiFunction(@GetNaNTag1_P, 'GetNaNTag1', cdRegister);
 S.RegisterDelphiFunction(@GetNaNTag2_P, 'GetNaNTag2', cdRegister);
 S.RegisterDelphiFunction(@CalcMachineEpsSingle, 'CalcMachineEpsSingle', cdRegister);
 S.RegisterDelphiFunction(@CalcMachineEpsDouble, 'CalcMachineEpsDouble', cdRegister);
 S.RegisterDelphiFunction(@CalcMachineEpsExtended, 'CalcMachineEpsExtended', cdRegister);
 S.RegisterDelphiFunction(@CalcMachineEps, 'CalcMachineEps', cdRegister);
 S.RegisterDelphiFunction(@SetPrecisionToleranceToEpsilon, 'SetPrecisionToleranceToEpsilon', cdRegister);
 //S.RegisterDelphiFunction(@CheckCrc32, 'CheckCrc32', cdRegister);
 S.RegisterDelphiFunction(@SetRectComplexFormatStr, 'SetRectComplexFormatStr', cdRegister);
 S.RegisterDelphiFunction(@SetPolarComplexFormatStr, 'SetPolarComplexFormatStr', cdRegister);

  S.RegisterDelphiFunction(@SinCos, 'SinCosD', cdRegister);
 S.RegisterDelphiFunction(@SinCosE, 'SinCosE', cdRegister);
 S.RegisterDelphiFunction(@SinCosE, 'SinCosJ', cdRegister);
 S.RegisterDelphiFunction(@Tan, 'TanJ', cdRegister);
 S.RegisterDelphiFunction(@Versine, 'Versine', cdRegister);
 S.RegisterDelphiFunction(@DegMinSecToFloat, 'DegMinSecToFloat', cdRegister);
 S.RegisterDelphiFunction(@FloatToDegMinSec, 'FloatToDegMinSec', cdRegister);
 S.RegisterDelphiFunction(@Exp, 'ExpJ', cdRegister);
 S.RegisterDelphiFunction(@PowerJ, 'PowerJ', cdRegister);
 S.RegisterDelphiFunction(@PowerIntJ, 'PowerIntJ', cdRegister);
 S.RegisterDelphiFunction(@TenToY, 'TenToY', cdRegister);
 S.RegisterDelphiFunction(@TruncPower, 'TruncPower', cdRegister);
 S.RegisterDelphiFunction(@TwoToY, 'TwoToY', cdRegister);
 S.RegisterDelphiFunction(@IsFloatZero, 'IsFloatZero', cdRegister);
 S.RegisterDelphiFunction(@FloatsEqual, 'FloatsEqual', cdRegister);
 S.RegisterDelphiFunction(@MaxFloat, 'MaxFloat', cdRegister);
 S.RegisterDelphiFunction(@MinFloat, 'MinFloat', cdRegister);
 S.RegisterDelphiFunction(@ModFloat, 'ModFloat', cdRegister);
 S.RegisterDelphiFunction(@RemainderFloat, 'RemainderFloat', cdRegister);
 S.RegisterDelphiFunction(@SetPrecisionTolerance, 'SetPrecisionTolerance', cdRegister);
 S.RegisterDelphiFunction(@SwapFloats, 'SwapFloats', cdRegister);
 S.RegisterDelphiFunction(@EnsureRange, 'EnsureRange', cdRegister);
 S.RegisterDelphiFunction(@EnsureRange1_P, 'EnsureRange1', cdRegister);
 S.RegisterDelphiFunction(@EnsureRange2_P, 'EnsureRange2', cdRegister);
 S.RegisterDelphiFunction(@IsRelativePrime, 'IsRelativePrime', cdRegister);
 S.RegisterDelphiFunction(@IsPrimeTD, 'IsPrimeTD', cdRegister);
 S.RegisterDelphiFunction(@IsPrimeRM, 'IsPrimeRM', cdRegister);
 S.RegisterDelphiFunction(@IsPrimeFactor, 'IsPrimeFactor', cdRegister);
 S.RegisterDelphiFunction(@PrimeFactors, 'PrimeFactors', cdRegister);
 S.RegisterDelphiFunction(@SetPrimalityTest, 'SetPrimalityTest', cdRegister);
 S.RegisterDelphiFunction(@FloatingPointClass_P, 'FloatingPointClass', cdRegister);
 S.RegisterDelphiFunction(@FloatingPointClass1_P, 'FloatingPointClass1', cdRegister);
 S.RegisterDelphiFunction(@FloatingPointClass2_P, 'FloatingPointClass2', cdRegister);

 S.RegisterDelphiFunction(@MaxIntValue, 'MaxIntValue', cdRegister);
 S.RegisterDelphiFunction(@MaxValue, 'MaxValue', cdRegister);
 S.RegisterDelphiFunction(@MinIntValue, 'MinIntValue', cdRegister);
 S.RegisterDelphiFunction(@MinIntValue, 'MinIntValue', cdRegister);
 S.RegisterDelphiFunction(@RoundTo, 'RoundTo', cdRegister);
 S.RegisterDelphiFunction(@SimpleRoundTo, 'SimpleRoundTo', cdRegister);
 S.RegisterDelphiFunction(@CompareValueE, 'CompareValue', cdRegister);
 S.RegisterDelphiFunction(@CompareValueD, 'CompareValueD', cdRegister);
 S.RegisterDelphiFunction(@CompareValueS, 'CompareValueS', cdRegister);
 S.RegisterDelphiFunction(@CompareValueI, 'CompareValueI', cdRegister);
 S.RegisterDelphiFunction(@CompareValueI64, 'CompareValueI64', cdRegister);
 S.RegisterDelphiFunction(@CompareValueE, 'CompareValueE', cdRegister);
 S.RegisterDelphiFunction(@getPI, 'getPI', cdRegister);

 //inrange

//CompareValue
 // CL.AddDelphiFunction('function RoundTo(const AValue: Extended; const ADigit: TRoundToEXRangeExtended): Extended;');
 //CL.AddDelphiFunction('function SimpleRoundTo(const AValue: Extended): Extended;');

 //RIRegister_EInvalidArgument(S);
end;



{ TPSImport_MathMax }
(*----------------------------------------------------------------------------*)
procedure TPSImport_MathMax.CompileImport1(CompExec: TPSScript);
begin
  SIRegister_MathMax(CompExec.Comp);
end;
(*----------------------------------------------------------------------------*)
procedure TPSImport_MathMax.ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter);
begin
  //RIRegister_MathMax(ri);
  RIRegister_MathMax_Routines(CompExec.Exec); // comment it if no routines
end;
(*----------------------------------------------------------------------------*)


end.
