<html>
<head>
<title>AsyncCalls - asynchronous function calls</title>
<style type="text/css">
<!--
a {
  text-decoration: none;
  color: #4444ff;
}
a:hover { 
  text-decoration: underline;
  color: #ff0000;
}

body {
  margin: 10px;
  padding: 0px;
}

body, p, td, table, li, ol, ul {
  font-family: verdana, arial, helvetica;
  font-size: 12px;
  line-height: 13pt;
}

p {
  font-size: 12px;
  line-height: 13pt;
  text-align: justify;
}

h1, h2, h3, h4, h5, h6 {
  text-align: left;
  font-weight: normal;
  font-family: arial, verdana, helvetica;
}

h3 { font-weight: bold; }

h3.Example { position: relative; left: 20px; }

ol {
  margin-top: 5px;
  margin-bottom: 5px;
}

div.code {
  font-family: "Courier New"; font-size: 10pt;
  border: 1px dotted gray;
  padding-left: 2px;
  padding-right: 2px;
  background-color: #f0f0e0;
  position: relative;
  left: 20px;
  width: 98%;
}


.center { text-align: center; }
.right { text-align: right; }
.left { text-align: left; }
.block { text-align: justify; }

.u0 { color: #FF0000; }
.u1 { font-style: italic; color: #008000; }
.u2 { color: #0000FF; }
.u3 { color: #008000; }
.u4 { color: #000000; }
.u5 { font-weight: bold; color: #000080; }
.u6 { color: #000080; }
.u7 { color: #000000; }
.u8 { color: #0000FF; }
.u9 { color: #000000; }
.u10 { color: #0000FF; }

// -->
</style>
</head>
<body bgcolor="white">
<h1>AsyncCalls - asynchronous function calls</h1>
<p>With AsyncCalls you can execute multiple functions at the same time and synchronize them at every point in
the function or method that started them. This allows you to execute time consuming code whos result is needed
at a later time in a different thread. While the asynchronous function is executed the caller function can do
other tasks.</p>
<p>The AsyncCalls unit offers a variety of function prototypes to call asynchronous functions. There are functions
that can call asynchron functions with one single parameter of the type: TObject, Integer, AnsiString, WideString,
IInterface, Extended and Variant. Another function allows you to transfer a user defined value type (record) to the asynchron
function where it can be modify. And there are functions that can call asynchron functions with a variable number of
arguments. The arguments are specified in an <span class="u5">const array of const</span> and are automatically
mapped to normal function arguments.</p>
<p>Inlined VCL/main thread synchronization is supported starting with version 2.0. With this you can implement
the code that calls a VCL function directly in your thread method without having to use a helper method and
TThread.Synchronize. You have full access to all local variables.<br/>
Version 2.9 introduces the TAsyncCalls class that utilizes generics and anonymous methods (Delphi 2009 or newer).</p>


<h2>Download</h2>
<p><a href="AsyncCalls.zip">AsyncCalls.zip</a> Version 2.99 (34 KB)</p>

<h2>License</h2>
<p>The AsyncCalls unit is licensed under the <a href="http://www.mozilla.org/MPL/MPL-1.1.html">Mozilla Public Licence ("MPL") version 1.1</a>.

<h2>Installation</h2>
<p>Extract the AsyncCalls.zip to a directory of your choice. Add the AnyncCalls.pas unit to your project and uses statements.</p>

<h2>Requirements</h2>
<p>Works with Delphi 5, 6, 7, 2005, BDS/Turbo 2006 and RAD Studio 2007, 2009, 2010, XE, XE2</p>

<h2>Changelog</h2>
<p>
<ul>
  <li><b>Version: 2.99 (2011-12-14)</b>:<br/>
      Added: IAsyncCall.CancelInvocation method<br/>
      Added: IAsyncCall.Forget method<br/>
      &nbsp;</li>

  <li><b>Version: 2.98 (2011-10-22)</b>:<br/>
      Added: Support for RAD Studio XE 64 bit<br/>
      &nbsp;</li>

  <li><b>Version: 2.97 (2011-05-21)</b>:<br/>
      Fixed: Replaced Suspend/Resume code to prevent a race condition where all threads are suspended but their FSuspended flag is false.<br/>
      Fixed: Exception handling in TAsyncCall.InternExecuteSyncCall. Quit wasn't called after an exception was raised.<br/>
      &nbsp;</li>

  <li><b>Version: 2.96 (2010-09-12)</b>:<br/>
      Fixed: CoInitialize call was missing<br/>
      &nbsp;</li>

  <li><b>Version: 2.95 (2010-09-12)</b>:<br/>
      Added: Support for RAD Studio XE<br/>
      Added: Support for UnicodeString<br/>
      &nbsp;</li>

  <li><b>Version: 2.92 (2009-08-30)</b>:<br/>
      Added: Support for RAD Studio 2010<br/>
      Restored: Delphi 2009 Update 1 fixed the compiler bug. All generic methods are now available.<br/>
      &nbsp;</li>

  <li><b>Version 2.91 (2008-09-29)</b>:<br/>
      Fixed: All generic methods are now disabled due to an internal compiler error in Delphi 2009<br/>
	  &nbsp;</li>

  <li><b>Version 2.9 (2008-09-27)</b>:<br/>
      Fixed: Window message handling<br/>
      Added: Delphi 2009 support with generics and anonymous methods<br/>
	  Added: AsyncCall(Runnable: IAsyncRunnable)<br/>
	  &nbsp;</li>

  <li><b>Version 2.21 (2008-05-14)</b>:<br/>
      Fixed: Bug in AsyncMultiSync<br/>
	  &nbsp;</li>
  <li><b>Version 2.2 (2008-05-12)</b>:<br/>
      Fixed: Bugs in main thread AsyncMultiSync implementation<br/>
      Added: Delphi 5 support<br/>
	  &nbsp;</li>
  <li><b>Version 2.1 (2008-05-06)</b>:<br/>
      Added: Delphi 6 support<br/>
	  Added: Support for "Exit;" in the MainThread block<br/>
	  Fixed: Exception handling for Delphi 6, 7 and 2005<br/>
	  Fixed: EBX, ESI and ESI are now copied into the synchronized block (Self-Pointer)<br/>
	  &nbsp;</li>
  <li><b>Version 2.0 (2008-05-04)</b>:<br/>
      Added: EnterMainThread/LeaveMainThread<br/>
      Added: LocalVclCall, LocalAsyncVclCall, MsgAsyncMultiSync<br/>
	  Added: LocalAsyncExec, AsyncExec<br/>
	  Added: IAsyncCall.ForceDifferentThread<br/>
	  Fixed: Exception handling<br/>
	  Removed: Delphi 5 and 6 support<br/>
	  &nbsp;
  <li><b>Version 1.2 (2008-02-10)</b>:<br/>
      Added CoInitialize for the threads<br/>
      LocalAsyncCall function<br/>
      Exception handling<br/>
	  &nbsp;</li>
  <li><b>Version 1.1 (2007-08-14)</b>:<br/>
      Workaround for TThread.Resume bug<br />
	  &nbsp;</li>
  <li><b>Version 1.0 (2006-12-23)</b>:<br/>
      Fixed: Exception where Thread was destroyed while the finalization code accessed it.</li>
</ul>
</p>


<h2>Example</h2>
<div class="code">
<!--<span class="u5">function</span>&nbsp;<span class="u4">TForm1</span><span class="u9">.</span><span class="u4">DoSomething</span><span class="u9">(</span><span class="u4">Value</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">):</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">Result</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">0</span><span class="u9">;</span>
<br><span class="u5">end</span><span class="u9">;</span>
<br>
<br>--><span class="u5">procedure</span>&nbsp;<span class="u4">TForm1</span><span class="u9">.</span><span class="u4">Button3Click</span><span class="u9">(</span><span class="u4">Sender</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">);</span>
<br><span class="u5">var</span>
<br>&nbsp;&nbsp;<span class="u4">Value</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<!--<br>&nbsp;&nbsp;<span class="u4">TAsyncCalls</span><span class="u9">.</span><span class="u4">Invoke</span><span class="u9">&lt;</span><span class="u4">TObject</span><span class="u9">&gt;(</span><span class="u4">DoSomething</span><span class="u9">,</span>&nbsp;<span class="u5">nil</span><span class="u9">);</span>
<br>-->
<br>&nbsp;&nbsp;<span class="u4">TAsyncCalls</span><span class="u9">.</span><span class="u4">Invoke</span><span class="u9">(</span><span class="u5">procedure</span>
<br>&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Value</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">10</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">TAsyncCalls</span><span class="u9">.</span><span class="u4">VCLInvoke</span><span class="u9">(</span><span class="u5">procedure</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">ShowMessage</span><span class="u9">(</span><span class="u8">'The&nbsp;value&nbsp;may&nbsp;not&nbsp;equal&nbsp;10:&nbsp;'</span>&nbsp;<span class="u9">+</span>&nbsp;<span class="u4">IntToStr</span><span class="u9">(</span><span class="u4">Value</span><span class="u9">));</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Value</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">20</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">TAsyncCalls</span><span class="u9">.</span><span class="u4">VCLSync</span><span class="u9">(</span><span class="u5">procedure</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">ShowMessage</span><span class="u9">(</span><span class="u8">'The&nbsp;value&nbsp;equals&nbsp;20:&nbsp;'</span>&nbsp;<span class="u9">+</span>&nbsp;<span class="u4">IntToStr</span><span class="u9">(</span><span class="u4">Value</span><span class="u9">));</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Value</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">30</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">);</span>
<br>
<br>&nbsp;&nbsp;<span class="u4">Sleep</span><span class="u9">(</span><span class="u6">1000</span><span class="u9">);</span>
<br><span class="u5">end</span><span class="u9">;</span>
</div>
<br />
<div class="code">
<span class="u1">{ The cdecl function GetFiles() has two arguments, a string and an object which are declared like normal arguments. }</span>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">GetFiles</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">Directory</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">;</span>&nbsp;<span class="u4">Filenames</span><span class="u9">:</span>&nbsp;<span class="u4">TStrings</span><span class="u9">);</span>&nbsp;<span class="u5">cdecl</span><span class="u9">;</span>
<br><span class="u5">var</span>
<br>&nbsp;&nbsp;<span class="u4">h</span><span class="u9">:</span>&nbsp;<span class="u4">THandle</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">FindData</span><span class="u9">:</span>&nbsp;<span class="u4">TWin32FindData</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">h</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">FindFirstFile</span><span class="u9">(</span><span class="u4">PChar</span><span class="u9">(</span><span class="u4">Directory</span>&nbsp;<span class="u9">+</span>&nbsp;<span class="u8">'\*.*'</span><span class="u9">),</span>&nbsp;<span class="u4">FindData</span><span class="u9">);</span>
<br>&nbsp;&nbsp;<span class="u5">if</span>&nbsp;<span class="u4">h</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u4">INVALID_HANDLE_VALUE</span>&nbsp;<span class="u5">then</span>
<br>&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">repeat</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">if</span>&nbsp;<span class="u9">(</span><span class="u4">StrComp</span><span class="u9">(</span><span class="u4">FindData</span><span class="u9">.</span><span class="u4">cFileName</span><span class="u9">,</span>&nbsp;<span class="u8">'.'</span><span class="u9">)</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u6">0</span><span class="u9">)</span>&nbsp;<span class="u5">and</span>&nbsp;<span class="u9">(</span><span class="u4">StrComp</span><span class="u9">(</span><span class="u4">FindData</span><span class="u9">.</span><span class="u4">cFileName</span><span class="u9">,</span>&nbsp;<span class="u8">'..'</span><span class="u9">)</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u6">0</span><span class="u9">)</span>&nbsp;<span class="u5">then</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Filenames</span><span class="u9">.</span><span class="u4">Add</span><span class="u9">(</span><span class="u4">Directory</span>&nbsp;<span class="u9">+</span>&nbsp;<span class="u8">'\'</span>&nbsp;<span class="u9">+</span>&nbsp;<span class="u4">FindData</span><span class="u9">.</span><span class="u4">cFileName</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">if</span>&nbsp;<span class="u4">FindData</span><span class="u9">.</span><span class="u4">dwFileAttributes</span>&nbsp;<span class="u5">and</span>&nbsp;<span class="u4">FILE_ATTRIBUTE_DIRECTORY</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u6">0</span>&nbsp;<span class="u5">then</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">GetFiles</span><span class="u9">(</span><span class="u4">Filenames</span><span class="u9">[</span><span class="u4">Filenames</span><span class="u9">.</span><span class="u4">Count</span>&nbsp;<span class="u9">-</span>&nbsp;<span class="u6">1</span><span class="u9">],</span>&nbsp;<span class="u4">Filenames</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">until</span>&nbsp;<span class="u5">not</span>&nbsp;<span class="u4">FindNextFile</span><span class="u9">(</span><span class="u4">h</span><span class="u9">,</span>&nbsp;<span class="u4">FindData</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Windows</span><span class="u9">.</span><span class="u4">FindClose</span><span class="u9">(</span><span class="u4">h</span><span class="u9">);</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br><span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">TFormMain</span><span class="u9">.</span><span class="u4">ButtonGetFilesClick</span><span class="u9">(</span><span class="u4">Sender</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">);</span>
<br><span class="u5">var</span>
<br>&nbsp;&nbsp;<span class="u4">Dir1</span><span class="u9">,</span>&nbsp;<span class="u4">Dir2</span><span class="u9">,</span>&nbsp;<span class="u4">Dir3</span><span class="u9">:</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">Dir1Files</span><span class="u9">,</span>&nbsp;<span class="u4">Dir2Files</span><span class="u9">,</span>&nbsp;<span class="u4">Dir3Files</span><span class="u9">:</span>&nbsp;<span class="u4">TStrings</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">Dir1Files</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">TStringList</span><span class="u9">.</span><span class="u4">Create</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">Dir2Files</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">TStringList</span><span class="u9">.</span><span class="u4">Create</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">Dir3Files</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">TStringList</span><span class="u9">.</span><span class="u4">Create</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">ButtonGetFiles</span><span class="u9">.</span><span class="u4">Enabled</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">False</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">try</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u1">{ Call the cdecl function GetFiles() with two arguments, a string and an object. }</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir1</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(@</span><span class="u4">GetFiles</span><span class="u9">,</span>&nbsp;<span class="u9">[</span><span class="u8">'C:\Windows'</span><span class="u9">,</span>&nbsp;<span class="u4">Dir1Files</span><span class="u9">]);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u1">{ Call the cdecl function GetFiles() with two arguments, a string and an object. }</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir2</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(@</span><span class="u4">GetFiles</span><span class="u9">,</span>&nbsp;<span class="u9">[</span><span class="u8">'D:\Html'</span><span class="u9">,</span>&nbsp;<span class="u4">Dir2Files</span><span class="u9">]);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u1">{ Call the cdecl function GetFiles() with two arguments, a string and an object. }</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir3</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(@</span><span class="u4">GetFiles</span><span class="u9">,</span>&nbsp;<span class="u9">[</span><span class="u8">'E:'</span><span class="u9">,</span>&nbsp;<span class="u4">Dir3Files</span><span class="u9">]);</span>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u1">{ Wait until both async functions have finished their work. While waiting make the UI reacting on user interaction. }</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">while</span>&nbsp;<span class="u4">AsyncMultiSync</span><span class="u9">([</span><span class="u4">Dir1</span><span class="u9">,</span>&nbsp;<span class="u4">Dir2</span><span class="u9">],</span>&nbsp;<span class="u4">True</span><span class="u9">,</span>&nbsp;<span class="u6">10</span><span class="u9">)</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u6">WAIT_TIMEOUT</span>&nbsp;<span class="u5">do</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Application</span><span class="u9">.</span><span class="u4">ProcessMessages</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir3.Sync<span class="u9">;</span>&nbsp;<span class="u1">// Force the Dir3 function to finish here</span></span>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">MemoFiles</span><span class="u9">.</span><span class="u4">Lines</span><span class="u9">.</span><span class="u4">Assign</span><span class="u9">(</span><span class="u4">Dir1Files</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">MemoFiles</span><span class="u9">.</span><span class="u4">Lines</span><span class="u9">.</span><span class="u4">AddStrings</span><span class="u9">(</span><span class="u4">Dir2Files</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">MemoFiles</span><span class="u9">.</span><span class="u4">Lines</span><span class="u9">.</span><span class="u4">AddStrings</span><span class="u9">(</span><span class="u4">Dir3Files</span><span class="u9">);</span>
<br>&nbsp;&nbsp;<span class="u5">finally</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">ButtonGetFiles</span><span class="u9">.</span><span class="u4">Enabled</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">True</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir3Files</span><span class="u9">.</span><span class="u4">Free</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir2Files</span><span class="u9">.</span><span class="u4">Free</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Dir1Files</span><span class="u9">.</span><span class="u4">Free</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br><span class="u5">end</span><span class="u9">;</span>
</div>

<p>&nbsp;</p>
<hr noshade="noshade">

<h2>IAsyncCall interface</h2>
<p>All AsyncCall functions return an IAsyncCall interface that allows to synchronize the functions.
<div class="code">
&nbsp;&nbsp;<span class="u4">IAsyncCall</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u5">interface</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">function</span>&nbsp;<span class="u4">Sync</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">function</span>&nbsp;<span class="u4">Finished</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">function</span>&nbsp;<span class="u4">ReturnValue</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">function</span>&nbsp;<span class="u4">Canceled</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">ForceDifferentThread</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">CancelInvocation</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">Forget</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
</div>
<ul>
 <li>The <b>Sync</b> method waits until the function is finished and returns the return value of the function which is
undefined for procedures.
 <li>The <b>Finished</b> method returns True when the asynchron function is finished. Otherwise it returns False.
 <li>The <b>ReturnValue</b> method returns the asynchron function's return value which is undefined for procedures. If
the asynchron function is still executed <b>ReturnValue</b> raises an EAsyncCallError exception.
 <li>The <b>Canceled</b> method returns True if the AsyncCall was canceled by <b>CancelInvocation</b>.
 <li>The <b>ForceDifferentThread</b> method tells AsyncCalls that the assigned function must
not be executed in the current thread.</li>
 <li>The <b>CancelInvocation</b> method stopps the AsyncCall from being invoked. If the AsyncCall is already
processed, a call to <b>CancelInvocation</b> has no effect and the <b>Canceled</b> function will
return False as the AsyncCall wasn't canceled.</li>
 <li>The <b>Forget</b> method unlinks the IAsyncCall interface from the internal AsyncCall. This means that
if the last reference to the IAsyncCall interface is gone, the asynchronous call will
be still executed. The interface's methods will throw an exception if called after calling
<b>Forget</b>. The async function must not call into the main thread because it could be executed
after the TThread.Synchronize/Queue mechanism was shut down by the RTL what can cause a
dead lock.</li>
</ul>


<p>&nbsp;</p>
<h2>LocalAsyncCall function</h2>
<p>LocalAsyncCall() executes the given local function/procedure in a separate thread.
  The result value of the asynchronous function is returned by IAsyncCall.Sync() and
  IAsyncCall.ReturnValue().<br/>
  The LocalAsyncExec() function calls the IdleMsgMethod while the local procedure is
  executed.</p>
<div class="code">
<span class="u5">function</span>&nbsp;<span class="u4">LocalAsyncCall</span><span class="u9">(</span><span class="u4">LocalProc</span><span class="u9">:</span>&nbsp;<span class="u4">TLocalAsyncProc</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">LocalAsyncCallEx</span><span class="u9">(</span><span class="u4">LocalProc</span><span class="u9">:</span>&nbsp;<span class="u4">TLocalAsyncProcEx</span><span class="u9">;</span>&nbsp;<span class="u4">Param</span><span class="u9">:</span>&nbsp;<span class="u4">INT_PTR</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">LocalAsyncExec</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TLocalAsyncProc</span><span class="u9">;</span>&nbsp;<span class="u4">IdleMsgMethod</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncIdleMsgMethod</span><span class="u9">);</span>
</div>
<ul>
 <li><b>LocalProc</b>: A local function that should be executed asynchron.
</ul>
<h3 class="Example">Example</h3>
<div class="code">
<span class="u5">procedure</span>&nbsp;<span class="u4">MainProc</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">S</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">);</span>
<br><span class="u5">var</span>
<br>&nbsp;&nbsp;<span class="u4">Value</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">a</span><span class="u9">:</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
<br>
<br>&nbsp;&nbsp;<span class="u5">function</span>&nbsp;<span class="u4">DoSomething</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">if</span>&nbsp;<span class="u4">S</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u8">'Abc'</span>&nbsp;<span class="u5">then</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Value</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">1</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Result</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">0</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">a</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">LocalAsyncCall</span><span class="u9">(@</span><span class="u4">DoSomething</span><span class="u9">);</span>
<br>&nbsp;&nbsp;<span class="u9"></span><span class="u1">//&nbsp;do&nbsp;something</span>
<br>&nbsp;&nbsp;<span class="u4">a</span><span class="u9">.</span><span class="u4">Sync</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">LocalAsyncExec</span><span class="u9">(@</span><span class="u4">DoSomething</span><span class="u9">,</span>&nbsp;<span class="u4">Application</span><span class="u9">.</span><span class="u4">ProcessMessages</span><span class="u9">);</span>
<br><span class="u5">end</span><span class="u9">;</span>
</div>





<p>&nbsp;</p>
<h2>VCL synchronization</h2>
<p>LocalVclCall() executes the given local function/procedure in the main thread. It
  uses the TThread.Synchronize function which blocks the current thread.
  LocalAsyncVclCall() execute the given local function/procedure in the main thread.
  It does not wait for the main thread to execute the function unless the current
  thread is the main thread. In that case it executes and waits for the specified
  function in the current thread like LocalVclCall().<br/>
<br/>
  The result value of the asynchronous function is returned by IAsyncCall.Sync() and
  IAsyncCall.ReturnValue().</p>

<div class="code">
<span class="u5">procedure</span>&nbsp;<span class="u4">LocalVclCall</span><span class="u9">(</span><span class="u4">LocalProc</span><span class="u9">:</span>&nbsp;<span class="u4">TLocalVclProc</span><span class="u9">;</span>&nbsp;<span class="u4">Param</span><span class="u9">:</span>&nbsp;<span class="u4">INT_PTR</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u6">0</span><span class="u9">);</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">LocalAsyncVclCall</span><span class="u9">(</span><span class="u4">LocalProc</span><span class="u9">:</span>&nbsp;<span class="u4">TLocalVclProc</span><span class="u9">;</span>&nbsp;<span class="u4">Param</span><span class="u9">:</span>&nbsp;<span class="u4">INT_PTR</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u6">0</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
</div>

<h3 class="Example">Example</h3>
<div class="code">
<span class="u5">procedure</span>&nbsp;<span class="u4">TForm1</span><span class="u9">.</span><span class="u4">MainProc</span><span class="u9">;</span>
<br>
<br>&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">DoSomething</span><span class="u9">;</span>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">UpdateProgressBar</span><span class="u9">(</span><span class="u4">Percentage</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">ProgressBar</span><span class="u9">.</span><span class="u4">Position</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">Percentage</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Sleep</span><span class="u9">(</span><span class="u6">20</span><span class="u9">);</span>&nbsp;<span class="u9"></span><span class="u1">//&nbsp;This&nbsp;delay&nbsp;does&nbsp;not&nbsp;affect&nbsp;the&nbsp;time&nbsp;for&nbsp;the&nbsp;0..100&nbsp;loop</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u9"></span><span class="u1">//&nbsp;because&nbsp;UpdateProgressBar&nbsp;is&nbsp;non-blocking.</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">procedure</span>&nbsp;<span class="u4">Finished</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">ShowMessage</span><span class="u9">(</span><span class="u8">'Finished'</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br>&nbsp;&nbsp;<span class="u5">var</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">I</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">for</span>&nbsp;<span class="u4">I</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">0</span>&nbsp;<span class="u5">to</span>&nbsp;<span class="u6">100</span>&nbsp;<span class="u5">do</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">begin</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u9"></span><span class="u1">//&nbsp;Do&nbsp;some&nbsp;time&nbsp;consuming&nbsp;stuff</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Sleep</span><span class="u9">(</span><span class="u6">30</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">LocalAsyncVclCall</span><span class="u9">(@</span><span class="u4">UpdateProgressBar</span><span class="u9">,</span>&nbsp;<span class="u4">I</span><span class="u9">);</span>&nbsp;<span class="u9"></span><span class="u1">//&nbsp;non-blocking</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">LocalVclCall</span><span class="u9">(@</span><span class="u4">Finished</span><span class="u9">);</span>&nbsp;<span class="u9"></span><span class="u1">//&nbsp;blocking</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u5">var</span>
<br>&nbsp;&nbsp;<span class="u4">a</span><span class="u9">:</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">a</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">LocalAsyncCall</span><span class="u9">(@</span><span class="u4">DoSomething</span><span class="u9">);</span>
<br>&nbsp;&nbsp;<span class="u4">a</span><span class="u9">.</span><span class="u4">ForceDifferentThread</span><span class="u9">;</span>&nbsp;<span class="u9"></span><span class="u1">//&nbsp;Do&nbsp;not&nbsp;execute&nbsp;in&nbsp;the&nbsp;main&nbsp;thread&nbsp;because&nbsp;this&nbsp;will</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="u9"></span><span class="u1">//&nbsp;change&nbsp;LocalAyncVclCall&nbsp;into&nbsp;a&nbsp;blocking&nbsp;LocalVclCall</span>
<br>&nbsp;&nbsp;<span class="u9"></span><span class="u1">//&nbsp;do&nbsp;something</span>
<br>&nbsp;&nbsp;<span class="u9"></span><span class="u1">//a.Sync;&nbsp;The&nbsp;Compiler&nbsp;will&nbsp;call&nbsp;this&nbsp;for&nbsp;us&nbsp;in&nbsp;the&nbsp;Interface._Release&nbsp;method</span>
<br><span class="u5">end</span><span class="u9">;</span>
</div>


<p>&nbsp;</p>
<h2>EnterMainThread/LeaveMainThread</h2>
<p>EnterMainThread/LeaveMainThread can be used to temporary switch to the
   main thread. The code that should be synchonized (blocking) has to be put
   into a try/finally block and the LeaveMainThread() function must be called
   from the finally block. A missing try/finally will lead to an access violation.</p>
<div class="code">
<span class="u5">procedure</span>&nbsp;<span class="u4">EnterMainThread</span><span class="u9">;</span>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">LeaveMainThread</span><span class="u9">;</span>
</div>   
<ul>
   <li>All local variables can be used. (EBP points to the thread's stack while
     ESP points the the main thread's stack)</li>
   <li>Unhandled exceptions are passed to the surrounding thread.</li>
   <li>The integrated Debugger is not able to follow the execution flow. You have
     to use break points instead of "Step over/in".</li>
   <li>Nested calls to EnterMainThread/LeaveMainThread are ignored. But they must
     strictly follow the try/finally structure.</li>
</ul>
<h3 class="Example">Example</h3>
<div class="code">
<span class="u5">procedure</span>&nbsp;<span class="u4">MyThreadProc</span><span class="u9">;</span>
<br><span class="u5">var</span>
<br>&nbsp;<span class="u4">S</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;<span class="u4">Assert</span><span class="u9">(</span><span class="u4">GetCurrentThreadId</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u4">MainThreadId</span><span class="u9">);</span>
<br>&nbsp;<span class="u4">S</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u8">'Hallo,&nbsp;I'</span><span class="u8">'m&nbsp;executed&nbsp;in&nbsp;the&nbsp;main&nbsp;thread'</span><span class="u9">;</span>
<br>
<br>&nbsp;<span class="u4">EnterMainThread</span><span class="u9">;</span>
<br>&nbsp;<span class="u5">try</span>
<br>&nbsp;&nbsp;&nbsp;<span class="u4">Assert</span><span class="u9">(</span><span class="u4">GetCurrentThreadId</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u4">MainThreadId</span><span class="u9">);</span>
<br>&nbsp;&nbsp;&nbsp;<span class="u4">ShowMessage</span><span class="u9">(</span><span class="u4">S</span><span class="u9">);</span>
<br>&nbsp;<span class="u5">finally</span>
<br>&nbsp;&nbsp;&nbsp;<span class="u4">LeaveMainThread</span><span class="u9">;</span>
<br>&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br>&nbsp;<span class="u4">Assert</span><span class="u9">(</span><span class="u4">GetCurrentThreadId</span>&nbsp;<span class="u9">&lt;&gt;</span>&nbsp;<span class="u4">MainThreadId</span><span class="u9">);</span>
<br><span class="u5">end</span><span class="u9">;</span>
</div>






<p>&nbsp;</p>
<h2>AsyncCall functions</h2>
<p>The AsyncCall() functions start a specified asynchronous function.<br/>
The AsyncExec() function calls the IdleMsgMethod in a loop, while the async.
method is executed.</p>
<div class="code">
<span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgObjectProc</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgIntegerProc</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgStringProc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgWideStringProc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">WideString</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgInterfaceProc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">IInterface</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgExtendedProc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Extended</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCallVar</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgVariantProc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Variant</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgObjectMethod</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgIntegerMethod</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgStringMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgWideStringMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">WideString</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgInterfaceMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">IInterface</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgExtendedMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Extended</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCallVar</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgVariantMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Variant</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgObjectEvent</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgIntegerEvent</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgStringEvent</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgWideStringEvent</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">WideString</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgInterfaceEvent</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">IInterface</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgExtendedEvent</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Extended</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCallVar</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgVariantEvent</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">Variant</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br/>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">AsyncExec</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TNotifyEvent</span><span class="u9">;</span>&nbsp;<span class="u4">Arg</span><span class="u9">:</span>&nbsp;<span class="u4">TObject</span><span class="u9">;</span>&nbsp;<span class="u4">IdleMsgMethod</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncIdleMsgMethod</span><span class="u9">);</span>
</div>
<ul>
 <li><b>Proc/Method</b>: Function that should be executed asynchron.
 <li><b>Arg</b>: User defined argument that is copied to the asynchron function argument.
</ul>
<h3 class="Example">Example</h3>
<div class="code"><span class="u5">function</span>&nbsp;<span class="u4">TestFunc</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">Text</span><span class="u9">:</span>&nbsp;<span class="u5">string</span><span class="u9">):</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">Result</span>&nbsp;<span class="u9">:=</span>&nbsp;TimeConsumingFuncion<span class="u9">(</span><span class="u4">Text</span><span class="u9">);</span>
<br><span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u4">a</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">TestFunc</span><span class="u9">,</span>&nbsp;<span class="u8">'A Text'</span><span class="u9">);</span>
</div>



<p>&nbsp;</p>
<h2>AsyncCallEx functions</h2>
<p>The AsyncCallEx() functions start a specified asynchronous function with a referenced value type (record) that can
be manipulated in the asynchron function.</p>
<div class="code">
<span class="u5">function</span>&nbsp;<span class="u4">AsyncCallEx</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgRecordProc</span><span class="u9">;</span>&nbsp;<span class="u5">var</span>&nbsp;<span class="u4">Arg</span><span class="u1">{:&nbsp;TRecordType}</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCallEx</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgRecordMethod</span><span class="u9">;</span>&nbsp;<span class="u5">var</span>&nbsp;<span class="u4">Arg</span><span class="u1">{:&nbsp;TRecordType}</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCallEx</span><span class="u9">(</span><span class="u4">Method</span><span class="u9">:</span>&nbsp;<span class="u4">TAsyncCallArgRecordEvent</span><span class="u9">;</span>&nbsp;<span class="u5">var</span>&nbsp;<span class="u4">Arg</span><span class="u1">{:&nbsp;TRecordType}</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
</div>
<ul>
 <li><b>Proc/Method</b>: Function that should be executed asynchron.
 <li><b>Arg</b>: User defined value type (record).
</ul>
<h3 class="Example">Example</h3>
<div class="code"><span class="u5">type</span>
<br>&nbsp;&nbsp;<span class="u4">TData</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u5">record</span>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="u4">Value</span><span class="u9">:</span>&nbsp;<span class="u4">Integer</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u5">procedure</span>&nbsp;<span class="u4">TestRec</span><span class="u9">(</span><span class="u5">var</span>&nbsp;<span class="u4">Data</span><span class="u9">:</span>&nbsp;<span class="u4">TData</span><span class="u9">);</span>
<br><span class="u5">begin</span>
<br>&nbsp;&nbsp;<span class="u4">Data</span><span class="u9">.</span><span class="u4">Value</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u6">70</span><span class="u9">;</span>
<br><span class="u5">end</span><span class="u9">;</span>
<br>
<br><span class="u4">a</span>&nbsp;<span class="u9">:=</span>&nbsp;<span class="u4">AsyncCallEx</span><span class="u9">(@</span><span class="u4">TestRec</span><span class="u9">,</span>&nbsp;<span class="u4">MyData</span><span class="u9">);</span>
<br><span class="u1">{ Don't access "MyData" here until the async. function has finished. }</span>
<br><span class="u4">a</span><span class="u9">.</span><span class="u4">Sync</span><span class="u9">;</span>&nbsp;<span class="u1">//&nbsp;MyData.Value&nbsp;is&nbsp;now&nbsp;70</span>
</div>



<p>&nbsp;</p>
<h2>AsyncCall functions with a variable number of arguments</h2>
<p>This AsyncCall() functions start a specified asynchronous function with a variable number of argument. The asynchron function must be declared as
<span class"u5">cdecl</span> and the argument's modifier must be <span class"u5">const</span> for Variants. All other types can have the
<span class"u5">const</span> modified but it is not necessary.</p>
<div class="code">
<span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TCdeclFunc</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Args</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u5">const</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncCall</span><span class="u9">(</span><span class="u4">Proc</span><span class="u9">:</span>&nbsp;<span class="u4">TCdeclMethod</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Args</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u5">const</span><span class="u9">):</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">overload</span><span class="u9">;</span>
</div>
<ul>
 <li><b>Proc/Method</b>: Function that should be executed asynchron.
 <li><b>Args</b>: An open array that specifies the asynchron function arguments. The values are either copied or the reference counter
 is increased during the execution of the asynchron function.
</ul>



<p>&nbsp;</p>
<h2>AsyncMultiSync</h2>
<p>AsyncMultiSync() waits for the async calls and other handles to finish.
   MsgAsyncMultiSync() waits for the async calls, other handles and the message queue.</p>
<div class="code">
<span class="u5">function</span>&nbsp;<span class="u4">AsyncMultiSync</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">List</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u4">WaitAll</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u4">True</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">Milliseconds</span><span class="u9">:</span>&nbsp;<span class="u4">Cardinal</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u4">INFINITE</span><span class="u9">):</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">AsyncMultiSyncEx</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">List</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Handles</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">THandle</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">WaitAll</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u4">True</span><span class="u9">;</span>&nbsp;<span class="u4">Milliseconds</span><span class="u9">:</span>&nbsp;<span class="u4">Cardinal</span>&nbsp;<span class="u9">=</span>&nbsp;<span class="u4">INFINITE</span><span class="u9">):</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">MsgAsyncMultiSync</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">List</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u4">WaitAll</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">Milliseconds</span><span class="u9">:</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>&nbsp;<span class="u4">dwWakeMask</span><span class="u9">:</span>&nbsp;<span class="u4">DWORD</span><span class="u9">):</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>
<br><span class="u5">function</span>&nbsp;<span class="u4">MsgAsyncMultiSyncEx</span><span class="u9">(</span><span class="u5">const</span>&nbsp;<span class="u4">List</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">IAsyncCall</span><span class="u9">;</span>&nbsp;<span class="u5">const</span>&nbsp;<span class="u4">Handles</span><span class="u9">:</span>&nbsp;<span class="u5">array</span>&nbsp;<span class="u5">of</span>&nbsp;<span class="u4">THandle</span><span class="u9">;</span>
<br>&nbsp;&nbsp;<span class="u4">WaitAll</span><span class="u9">:</span>&nbsp;<span class="u4">Boolean</span><span class="u9">;</span>&nbsp;<span class="u4">Milliseconds</span><span class="u9">:</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>&nbsp;<span class="u4">dwWakeMask</span><span class="u9">:</span>&nbsp;<span class="u4">DWORD</span><span class="u9">):</span>&nbsp;<span class="u4">Cardinal</span><span class="u9">;</span>
</div>
<blockquote>
<h3>Arguments</h3>
<blockquote>
<table border="0" width="100%" style="background-color: #f0f0f0;">
<tr>
 <td valign="top" width="150"><b>List</b></td>
 <td valign="top">An array of IAsyncCall interfaces for which the function should wait.</td>
</tr>
<tr>
 <td valign="top" width="150"><b>Handles</b></td>
 <td valign="top">An array of THandle for which the function should wait.</td>
</tr>
<tr>
 <td valign="top" width="150"><b>WaitAll = True</b></td>
 <td valign="top">The function returns when all listed async calls have
     finished. If Milliseconds is INFINITE the async calls
     meight be executed in the current thread.
     The return value is zero when all async calls have finished.
     Otherwise it is <b>WAIT_FAILED</b>.</td>
</tr>
<tr>
 <td valign="top" width="150"><b>WaitAll = False</b></td>
 <td valign="top">The function returns when at least one of the async calls
     has finished. The return value is the list index of the
     first finished async call. If there was a timeout, the
     return value is <b>WAIT_FAILED</b>.</td>
</tr>
<tr>
 <td valign="top" width="150"><b>Milliseconds</b></td>
 <td valign="top">Specifies the number of milliseconds to wait until a
     timeout happens. The value INFINITE lets the function wait
     until all async calls have finished.</td>
</tr>
<tr>
 <td valign="top" width="150"><b>dwWakeMask</b></td>
 <td valign="top">see Windows.MsgWaitForMultipleObjects()</td>
</tr>
</table></blockquote>
<h3>Limitations</h3>
<blockquote><p>Length(List)+Length(Handles) must not exceed <b>MAXIMUM_ASYNC_WAIT_OBJECTS</b> &nbsp;&nbsp;(61 elements).</p></blockquote>
<h3>Return value</h3>
<blockquote>
<ul>
 <li><b>WAIT_TIMEOUT</b><br/>
     The function timed out<br/>&nbsp;</li>

 <li><b>WAIT_OBJECT_0+index</b><br/>
     The first finished async call</li>
 <li><b>WAIT_OBJECT_0+Length(List)+index</b><br/>
     The first signaled handle</li>
 <li><b>WAIT_OBJECT_0+Length(List)+Length(Handles)</b><br/>
     A message was signaled<br/>&nbsp;</li>
	 
 <li><b>WAIT_ABANDONED_0+index</b><br/>
     The abandoned async call</li>
 <li><b>WAIT_ABANDONED_0+Length(List)+index</b><br/>
     The abandoned handle<br/>&nbsp;</li>

<li><b>WAIT_FAILED</b><br/>
     The function failed</li>
</ul>
</blockquote>
</blockquote> 








<p>&nbsp;</p>
<hr noshade="noshade">
<p>&nbsp;</p>
<h2>AsyncCalls Internals - Thread pool and waiting-queue</h2>
<p>An execution request is added to the waiting-queue when an async. function is started. This request forces the thread pool to
check if there is an idle/suspended thread that could do the job. If such a thread exists, it is reactivated/resumed. If no thread
is available then it depends on the number of threads in the pool what happens. If the maximum thread number is already reached the
request remains in the waiting-queue. Otherwise a new thread is added to the thread pool.</p>
<p>Threads that aren't idle/suspended take the oldest request from the waiting-queue an execute the associated async. function. If the
waiting queue is empty the threads becomes idle/suspended.</p>

<p>&nbsp;</p>
<p align="right">
<script language="JavaScript">
<!--
a1 = "An";a2 = "Ha"; a3 = "dr"; a4 = "us"; a5 = "ea"; a6 = "la"; a7 = "s"; a8 = "de"; a9 = "n"; a10 = "gm"; a11 = "x";
s = a1 + a3 + a5 + a7 + "." + a2 + a4 + a6 + a8 + a9 + "@" + a10 + a11 + ".de";
s2 = a1 + a3 + a5 + a7 + " " + a2 + a4 + a6 + a8 + a9;
b1 = "il"; b2 = "ma"; b3 = "to";
s = b2 + b1 + b3 + ":" + s;
document.write("<a href='" + s + "?subject=AsyncCalls'>" + "(C) 2006-2011 " + s2 + "</a>");
//-->
</script>
</p>

<!--<p align="right">(C) 2006-2011 Andreas Hausladen</p>-->
</body>