unit uPSI_MaskUtils;
{
This file has been generated by UnitParser v0.7, written by M. Knight
and updated by NP. v/d Spek and George Birbilis.
  add to maskedit

}
interface
 
uses
   SysUtils
  ,Classes
  ,uPSComponent
  ,uPSRuntime
  ,uPSCompiler
  ;
 
type 
(*----------------------------------------------------------------------------*)
  TPSImport_MaskUtils = class(TPSPlugin)
  protected
    procedure CompileImport1(CompExec: TPSScript); override;
    procedure ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter); override;
  end;
 
 
{ compile-time registration functions }
procedure SIRegister_MaskUtils(CL: TPSPascalCompiler);

{ run-time registration functions }
procedure RIRegister_MaskUtils_Routines(S: TPSExec);

procedure Register;

implementation


uses
   MaskUtils
  ;
 
 
procedure Register;
begin
  RegisterComponents('Pascal Script', [TPSImport_MaskUtils]);
end;

(* === compile-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure SIRegister_MaskUtils(CL: TPSPascalCompiler);
begin
 CL.AddConstantN('mDirReverse','String').SetString( '!');
 CL.AddConstantN('mDirUpperCase','String').SetString( '>');
 CL.AddConstantN('mDirLowerCase','String').SetString( '<');
 CL.AddConstantN('mDirLiteral','String').SetString( '\');
 CL.AddConstantN('mMskAlpha','String').SetString( 'L');
 CL.AddConstantN('mMskAlphaOpt','String').SetString( 'l');
 CL.AddConstantN('mMskAlphaNum','String').SetString( 'A');
 CL.AddConstantN('mMskAlphaNumOpt','String').SetString( 'a');
 CL.AddConstantN('mMskAscii','String').SetString( 'C');
 CL.AddConstantN('mMskAsciiOpt','String').SetString( 'c');
 CL.AddConstantN('mMskNumeric','String').SetString( '0');
 CL.AddConstantN('mMskNumericOpt','String').SetString( '9');
 CL.AddConstantN('mMskNumSymOpt','String').SetString( '#');
 CL.AddConstantN('mMskTimeSeparator','String').SetString( ':');
 CL.AddConstantN('mMskDateSeparator','String').SetString( '/');
  CL.AddTypeS('TMaskCharType', '( mcNone, mcLiteral, mcIntlLiteral, mcDirective'
   +', mcMask, mcMaskOpt, mcFieldSeparator, mcField )');
  CL.AddTypeS('TMaskDirectives', ' (mdReverseDir, mdUpperCase, mdLowerCase,mdLiteralChar)');
  CL.AddTypeS('TMaskedText', 'string');
  CL.AddTypeS('TEditMask', 'string');
 CL.AddDelphiFunction('Function FormatMaskText( const EditMask : string; const Value : string) : string');
 CL.AddDelphiFunction('Function MaskGetMaskSave( const EditMask : string) : Boolean');
 CL.AddDelphiFunction('Function MaskGetMaskBlank( const EditMask : string) : Char');
 CL.AddDelphiFunction('Function MaskGetFldSeparator( const EditMask : string) : Integer');
 CL.AddDelphiFunction('Function PadInputLiterals( const EditMask : String; const Value : string; Blank : Char) : string');
 CL.AddDelphiFunction('Function MaskOffsetToOffset( const EditMask : String; MaskOffset : Integer) : Integer');
 CL.AddDelphiFunction('Function MaskOffsetToWideOffset( const EditMask : String; MaskOffset : Integer) : Integer');
 CL.AddDelphiFunction('Function IsLiteralChar( const EditMask : string; Offset : Integer) : Boolean');
 CL.AddDelphiFunction('Function MaskGetCharType( const EditMask : string; MaskOffset : Integer) : TMaskCharType');
 CL.AddDelphiFunction('Function MaskGetCurrentDirectives( const EditMask : string; MaskOffset : Integer) : TMaskDirectives');
 CL.AddDelphiFunction('Function MaskIntlLiteralToChar( IChar : Char) : Char');
 CL.AddDelphiFunction('Function OffsetToMaskOffset( const EditMask : string; Offset : Integer) : Integer');
 CL.AddDelphiFunction('Function MaskDoFormatText( const EditMask : string; const Value : string; Blank : Char) : string');
end;

(* === run-time registration functions === *)
(*----------------------------------------------------------------------------*)
procedure RIRegister_MaskUtils_Routines(S: TPSExec);
begin
 S.RegisterDelphiFunction(@FormatMaskText, 'FormatMaskText', cdRegister);
 S.RegisterDelphiFunction(@MaskGetMaskSave, 'MaskGetMaskSave', cdRegister);
 S.RegisterDelphiFunction(@MaskGetMaskBlank, 'MaskGetMaskBlank', cdRegister);
 S.RegisterDelphiFunction(@MaskGetFldSeparator, 'MaskGetFldSeparator', cdRegister);
 S.RegisterDelphiFunction(@PadInputLiterals, 'PadInputLiterals', cdRegister);
 S.RegisterDelphiFunction(@MaskOffsetToOffset, 'MaskOffsetToOffset', cdRegister);
 S.RegisterDelphiFunction(@MaskOffsetToWideOffset, 'MaskOffsetToWideOffset', cdRegister);
 S.RegisterDelphiFunction(@IsLiteralChar, 'IsLiteralChar', cdRegister);
 S.RegisterDelphiFunction(@MaskGetCharType, 'MaskGetCharType', cdRegister);
 S.RegisterDelphiFunction(@MaskGetCurrentDirectives, 'MaskGetCurrentDirectives', cdRegister);
 S.RegisterDelphiFunction(@MaskIntlLiteralToChar, 'MaskIntlLiteralToChar', cdRegister);
 S.RegisterDelphiFunction(@OffsetToMaskOffset, 'OffsetToMaskOffset', cdRegister);
 S.RegisterDelphiFunction(@MaskDoFormatText, 'MaskDoFormatText', cdRegister);
end;

 
 
{ TPSImport_MaskUtils }
(*----------------------------------------------------------------------------*)
procedure TPSImport_MaskUtils.CompileImport1(CompExec: TPSScript);
begin
  SIRegister_MaskUtils(CompExec.Comp);
end;
(*----------------------------------------------------------------------------*)
procedure TPSImport_MaskUtils.ExecImport1(CompExec: TPSScript; const ri: TPSRuntimeClassImporter);
begin
  //RIRegister_MaskUtils(ri);
  RIRegister_MaskUtils_Routines(CompExec.Exec); // comment it if no routines
end;
(*----------------------------------------------------------------------------*)
 
 
end.
